/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
package com.gpudb.protocol;

import java.nio.ByteBuffer;
import java.util.LinkedHashMap;
import java.util.Map;
import org.apache.avro.Schema;
import org.apache.avro.SchemaBuilder;
import org.apache.avro.generic.GenericData;
import org.apache.avro.generic.IndexedRecord;

/**
 * A set of parameters for {@link
 * com.gpudb.GPUdb#insertRecordsFromPayload(InsertRecordsFromPayloadRequest)
 * GPUdb.insertRecordsFromPayload}.
 * <p>
 * Reads from the given text-based or binary payload and inserts the data into
 * a new or existing table.  The table will be created if it doesn't already
 * exist.
 * <p>
 * Returns once all records are processed.
 */
public class InsertRecordsFromPayloadRequest implements IndexedRecord {
    private static final Schema schema$ = SchemaBuilder
            .record("InsertRecordsFromPayloadRequest")
            .namespace("com.gpudb")
            .fields()
                .name("tableName").type().stringType().noDefault()
                .name("dataText").type().stringType().noDefault()
                .name("dataBytes").type().bytesType().noDefault()
                .name("modifyColumns").type().map().values().map().values().stringType().noDefault()
                .name("createTableOptions").type().map().values().stringType().noDefault()
                .name("options").type().map().values().stringType().noDefault()
            .endRecord();

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @return The schema for the class.
     */
    public static Schema getClassSchema() {
        return schema$;
    }

    /**
     * A set of string constants for the {@link
     * InsertRecordsFromPayloadRequest} parameter {@link
     * #getCreateTableOptions() createTableOptions}.
     * <p>
     * Options used when creating the target table. Includes type to use. The
     * other options match those in {@link
     * com.gpudb.GPUdb#createTable(CreateTableRequest) GPUdb.createTable}
     */
    public static final class CreateTableOptions {
        /**
         * ID of a currently registered <a
         * href="../../../../../../concepts/types/" target="_top">type</a>. The
         * default value is ''.
         */
        public static final String TYPE_ID = "type_id";

        /**
         * If {@link CreateTableOptions#TRUE TRUE}, prevents an error from
         * occurring if the table already exists and is of the given type.  If
         * a table with the same ID but a different type exists, it is still an
         * error.
         * Supported values:
         * <ul>
         *     <li>{@link CreateTableOptions#TRUE TRUE}
         *     <li>{@link CreateTableOptions#FALSE FALSE}
         * </ul>
         * The default value is {@link CreateTableOptions#FALSE FALSE}.
         */
        public static final String NO_ERROR_IF_EXISTS = "no_error_if_exists";

        public static final String TRUE = "true";
        public static final String FALSE = "false";

        /**
         * Affects the <a
         * href="../../../../../../concepts/tables/#distribution"
         * target="_top">distribution scheme</a> for the table's data.  If
         * {@link CreateTableOptions#TRUE TRUE} and the given type has no
         * explicit <a href="../../../../../../concepts/tables/#shard-key"
         * target="_top">shard key</a> defined, the table will be <a
         * href="../../../../../../concepts/tables/#replication"
         * target="_top">replicated</a>.  If {@link CreateTableOptions#FALSE
         * FALSE}, the table will be <a
         * href="../../../../../../concepts/tables/#sharding"
         * target="_top">sharded</a> according to the shard key specified in
         * the given {@link CreateTableOptions#TYPE_ID TYPE_ID}, or <a
         * href="../../../../../../concepts/tables/#random-sharding"
         * target="_top">randomly sharded</a>, if no shard key is specified.
         * Note that a type containing a shard key cannot be used to create a
         * replicated table.
         * Supported values:
         * <ul>
         *     <li>{@link CreateTableOptions#TRUE TRUE}
         *     <li>{@link CreateTableOptions#FALSE FALSE}
         * </ul>
         * The default value is {@link CreateTableOptions#FALSE FALSE}.
         */
        public static final String IS_REPLICATED = "is_replicated";

        /**
         * Semicolon-separated list of <a
         * href="../../../../../../concepts/tables/#foreign-keys"
         * target="_top">foreign keys</a>, of the format '(source_column_name
         * [, ...]) references target_table_name(primary_key_column_name [,
         * ...]) [as foreign_key_name]'.
         */
        public static final String FOREIGN_KEYS = "foreign_keys";

        /**
         * Foreign shard key of the format 'source_column references
         * shard_by_column from target_table(primary_key_column)'.
         */
        public static final String FOREIGN_SHARD_KEY = "foreign_shard_key";

        /**
         * <a href="../../../../../../concepts/tables/#partitioning"
         * target="_top">Partitioning</a> scheme to use.
         * Supported values:
         * <ul>
         *     <li>{@link CreateTableOptions#RANGE RANGE}: Use <a
         *         href="../../../../../../concepts/tables/#partitioning-by-range"
         *         target="_top">range partitioning</a>.
         *     <li>{@link CreateTableOptions#INTERVAL INTERVAL}: Use <a
         *         href="../../../../../../concepts/tables/#partitioning-by-interval"
         *         target="_top">interval partitioning</a>.
         *     <li>{@link CreateTableOptions#LIST LIST}: Use <a
         *         href="../../../../../../concepts/tables/#partitioning-by-list"
         *         target="_top">list partitioning</a>.
         *     <li>{@link CreateTableOptions#HASH HASH}: Use <a
         *         href="../../../../../../concepts/tables/#partitioning-by-hash"
         *         target="_top">hash partitioning</a>.
         *     <li>{@link CreateTableOptions#SERIES SERIES}: Use <a
         *         href="../../../../../../concepts/tables/#partitioning-by-series"
         *         target="_top">series partitioning</a>.
         * </ul>
         */
        public static final String PARTITION_TYPE = "partition_type";

        /**
         * Use <a
         * href="../../../../../../concepts/tables/#partitioning-by-range"
         * target="_top">range partitioning</a>.
         */
        public static final String RANGE = "RANGE";

        /**
         * Use <a
         * href="../../../../../../concepts/tables/#partitioning-by-interval"
         * target="_top">interval partitioning</a>.
         */
        public static final String INTERVAL = "INTERVAL";

        /**
         * Use <a
         * href="../../../../../../concepts/tables/#partitioning-by-list"
         * target="_top">list partitioning</a>.
         */
        public static final String LIST = "LIST";

        /**
         * Use <a
         * href="../../../../../../concepts/tables/#partitioning-by-hash"
         * target="_top">hash partitioning</a>.
         */
        public static final String HASH = "HASH";

        /**
         * Use <a
         * href="../../../../../../concepts/tables/#partitioning-by-series"
         * target="_top">series partitioning</a>.
         */
        public static final String SERIES = "SERIES";

        /**
         * Comma-separated list of partition keys, which are the columns or
         * column expressions by which records will be assigned to partitions
         * defined by {@link CreateTableOptions#PARTITION_DEFINITIONS
         * PARTITION_DEFINITIONS}.
         */
        public static final String PARTITION_KEYS = "partition_keys";

        /**
         * Comma-separated list of partition definitions, whose format depends
         * on the choice of {@link CreateTableOptions#PARTITION_TYPE
         * PARTITION_TYPE}.  See <a
         * href="../../../../../../concepts/tables/#partitioning-by-range"
         * target="_top">range partitioning</a>, <a
         * href="../../../../../../concepts/tables/#partitioning-by-interval"
         * target="_top">interval partitioning</a>, <a
         * href="../../../../../../concepts/tables/#partitioning-by-list"
         * target="_top">list partitioning</a>, <a
         * href="../../../../../../concepts/tables/#partitioning-by-hash"
         * target="_top">hash partitioning</a>, or <a
         * href="../../../../../../concepts/tables/#partitioning-by-series"
         * target="_top">series partitioning</a> for example formats.
         */
        public static final String PARTITION_DEFINITIONS = "partition_definitions";

        /**
         * If {@link CreateTableOptions#TRUE TRUE}, a new partition will be
         * created for values which don't fall into an existing partition.
         * Currently only supported for <a
         * href="../../../../../../concepts/tables/#partitioning-by-list"
         * target="_top">list partitions</a>.
         * Supported values:
         * <ul>
         *     <li>{@link CreateTableOptions#TRUE TRUE}
         *     <li>{@link CreateTableOptions#FALSE FALSE}
         * </ul>
         * The default value is {@link CreateTableOptions#FALSE FALSE}.
         */
        public static final String IS_AUTOMATIC_PARTITION = "is_automatic_partition";

        /**
         * Sets the <a href="../../../../../../concepts/ttl/"
         * target="_top">TTL</a> of the table specified in {@link
         * #getTableName() tableName}.
         */
        public static final String TTL = "ttl";

        /**
         * Indicates the number of records per chunk to be used for this table.
         */
        public static final String CHUNK_SIZE = "chunk_size";

        /**
         * Indicates the target maximum data size for each column in a chunk to
         * be used for this table.
         */
        public static final String CHUNK_COLUMN_MAX_MEMORY = "chunk_column_max_memory";

        /**
         * Indicates the target maximum data size for all columns in a chunk to
         * be used for this table.
         */
        public static final String CHUNK_MAX_MEMORY = "chunk_max_memory";

        /**
         * Indicates whether the table is a <a
         * href="../../../../../../concepts/tables_memory_only/"
         * target="_top">memory-only table</a>. A result table cannot contain
         * columns with text_search <a
         * href="../../../../../../concepts/types/#data-handling"
         * target="_top">data-handling</a>, and it will not be retained if the
         * server is restarted.
         * Supported values:
         * <ul>
         *     <li>{@link CreateTableOptions#TRUE TRUE}
         *     <li>{@link CreateTableOptions#FALSE FALSE}
         * </ul>
         * The default value is {@link CreateTableOptions#FALSE FALSE}.
         */
        public static final String IS_RESULT_TABLE = "is_result_table";

        /**
         * The <a href="../../../../../../rm/concepts/#tier-strategies"
         * target="_top">tier strategy</a> for the table and its columns.
         */
        public static final String STRATEGY_DEFINITION = "strategy_definition";

        private CreateTableOptions() {  }
    }

    /**
     * A set of string constants for the {@link
     * InsertRecordsFromPayloadRequest} parameter {@link #getOptions()
     * options}.
     * <p>
     * Optional parameters.
     */
    public static final class Options {
        /**
         * Optional number of bytes to skip when reading an avro record.
         */
        public static final String AVRO_HEADER_BYTES = "avro_header_bytes";

        /**
         * Optional number of avro records, if data includes only records.
         */
        public static final String AVRO_NUM_RECORDS = "avro_num_records";

        /**
         * Optional string representing avro schema, for insert records in avro
         * format, that does not include is schema.
         */
        public static final String AVRO_SCHEMA = "avro_schema";

        /**
         * When user provides 'avro_schema', avro data is assumed to be
         * schemaless, unless specified. Default is 'true' when given
         * avro_schema. Igonred when avro_schema is not given.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         */
        public static final String AVRO_SCHEMALESS = "avro_schemaless";

        /**
         * Upsert new records when primary keys match existing records
         */
        public static final String TRUE = "true";

        /**
         * Reject new records when primary keys match existing records
         */
        public static final String FALSE = "false";

        /**
         * Optional name of a table to which records that were rejected are
         * written.  The bad-record-table has the following columns:
         * line_number (long), line_rejected (string), error_message (string).
         */
        public static final String BAD_RECORD_TABLE_NAME = "bad_record_table_name";

        /**
         * A positive integer indicating the maximum number of records that can
         * be  written to the bad-record-table.   Default value is 10000
         */
        public static final String BAD_RECORD_TABLE_LIMIT = "bad_record_table_limit";

        /**
         * For subscriptions: A positive integer indicating the maximum number
         * of records that can be written to the bad-record-table per
         * file/payload. Default value will be 'bad_record_table_limit' and
         * total size of the table per rank is limited to
         * 'bad_record_table_limit'
         */
        public static final String BAD_RECORD_TABLE_LIMIT_PER_INPUT = "bad_record_table_limit_per_input";

        /**
         * Internal tuning parameter--number of records per batch when
         * inserting data.
         */
        public static final String BATCH_SIZE = "batch_size";

        /**
         * For each target column specified, applies the column-property-bound
         * format to the source data loaded into that column.  Each column
         * format will contain a mapping of one or more of its column
         * properties to an appropriate format for each property.  Currently
         * supported column properties include date, time, & datetime. The
         * parameter value must be formatted as a JSON string of maps of column
         * names to maps of column properties to their corresponding column
         * formats, e.g., '{ "order_date" : { "date" : "%Y.%m.%d" },
         * "order_time" : { "time" : "%H:%M:%S" } }'.
         * <p>
         * See {@link Options#DEFAULT_COLUMN_FORMATS DEFAULT_COLUMN_FORMATS}
         * for valid format syntax.
         */
        public static final String COLUMN_FORMATS = "column_formats";

        /**
         * Specifies a comma-delimited list of columns from the source data to
         * load.  If more than one file is being loaded, this list applies to
         * all files.
         * <p>
         * Column numbers can be specified discretely or as a range.  For
         * example, a value of '5,7,1..3' will insert values from the fifth
         * column in the source data into the first column in the target table,
         * from the seventh column in the source data into the second column in
         * the target table, and from the first through third columns in the
         * source data into the third through fifth columns in the target
         * table.
         * <p>
         * If the source data contains a header, column names matching the file
         * header names may be provided instead of column numbers.  If the
         * target table doesn't exist, the table will be created with the
         * columns in this order.  If the target table does exist with columns
         * in a different order than the source data, this list can be used to
         * match the order of the target table.  For example, a value of 'C, B,
         * A' will create a three column table with column C, followed by
         * column B, followed by column A; or will insert those fields in that
         * order into a table created with columns in that order.  If the
         * target table exists, the column names must match the source data
         * field names for a name-mapping to be successful.
         * <p>
         * Mutually exclusive with {@link Options#COLUMNS_TO_SKIP
         * COLUMNS_TO_SKIP}.
         */
        public static final String COLUMNS_TO_LOAD = "columns_to_load";

        /**
         * Specifies a comma-delimited list of columns from the source data to
         * skip.  Mutually exclusive with {@link Options#COLUMNS_TO_LOAD
         * COLUMNS_TO_LOAD}.
         */
        public static final String COLUMNS_TO_SKIP = "columns_to_skip";

        /**
         * Optional: payload compression type.
         * Supported values:
         * <ul>
         *     <li>{@link Options#NONE NONE}: Uncompressed
         *     <li>{@link Options#AUTO AUTO}: Default. Auto detect compression
         *         type
         *     <li>{@link Options#GZIP GZIP}: gzip file compression.
         *     <li>{@link Options#BZIP2 BZIP2}: bzip2 file compression.
         * </ul>
         * The default value is {@link Options#AUTO AUTO}.
         */
        public static final String COMPRESSION_TYPE = "compression_type";

        /**
         * Uncompressed
         */
        public static final String NONE = "none";

        /**
         * Default. Auto detect compression type
         */
        public static final String AUTO = "auto";

        /**
         * gzip file compression.
         */
        public static final String GZIP = "gzip";

        /**
         * bzip2 file compression.
         */
        public static final String BZIP2 = "bzip2";

        /**
         * Specifies the default format to be applied to source data loaded
         * into columns with the corresponding column property.  Currently
         * supported column properties include date, time, & datetime.  This
         * default column-property-bound format can be overridden by specifying
         * a column property & format for a given target column in {@link
         * Options#COLUMN_FORMATS COLUMN_FORMATS}. For each specified
         * annotation, the format will apply to all columns with that
         * annotation unless a custom {@link Options#COLUMN_FORMATS
         * COLUMN_FORMATS} for that annotation is specified.
         * <p>
         * The parameter value must be formatted as a JSON string that is a map
         * of column properties to their respective column formats, e.g., '{
         * "date" : "%Y.%m.%d", "time" : "%H:%M:%S" }'.  Column formats are
         * specified as a string of control characters and plain text. The
         * supported control characters are 'Y', 'm', 'd', 'H', 'M', 'S', and
         * 's', which follow the Linux 'strptime()' specification, as well as
         * 's', which specifies seconds and fractional seconds (though the
         * fractional component will be truncated past milliseconds).
         * <p>
         * Formats for the 'date' annotation must include the 'Y', 'm', and 'd'
         * control characters. Formats for the 'time' annotation must include
         * the 'H', 'M', and either 'S' or 's' (but not both) control
         * characters. Formats for the 'datetime' annotation meet both the
         * 'date' and 'time' control character requirements. For example,
         * '{"datetime" : "%m/%d/%Y %H:%M:%S" }' would be used to interpret
         * text as "05/04/2000 12:12:11"
         */
        public static final String DEFAULT_COLUMN_FORMATS = "default_column_formats";

        /**
         * Specifies how errors should be handled upon insertion.
         * Supported values:
         * <ul>
         *     <li>{@link Options#PERMISSIVE PERMISSIVE}: Records with missing
         *         columns are populated with nulls if possible; otherwise, the
         *         malformed records are skipped.
         *     <li>{@link Options#IGNORE_BAD_RECORDS IGNORE_BAD_RECORDS}:
         *         Malformed records are skipped.
         *     <li>{@link Options#ABORT ABORT}: Stops current insertion and
         *         aborts entire operation when an error is encountered.
         *         Primary key collisions are considered abortable errors in
         *         this mode.
         * </ul>
         * The default value is {@link Options#ABORT ABORT}.
         */
        public static final String ERROR_HANDLING = "error_handling";

        /**
         * Records with missing columns are populated with nulls if possible;
         * otherwise, the malformed records are skipped.
         */
        public static final String PERMISSIVE = "permissive";

        /**
         * Malformed records are skipped.
         */
        public static final String IGNORE_BAD_RECORDS = "ignore_bad_records";

        /**
         * Stops current insertion and aborts entire operation when an error is
         * encountered.  Primary key collisions are considered abortable errors
         * in this mode.
         */
        public static final String ABORT = "abort";

        /**
         * Specifies the type of the file(s) whose records will be inserted.
         * Supported values:
         * <ul>
         *     <li>{@link Options#AVRO AVRO}: Avro file format
         *     <li>{@link Options#DELIMITED_TEXT DELIMITED_TEXT}: Delimited
         *         text file format; e.g., CSV, TSV, PSV, etc.
         *     <li>{@link Options#GDB GDB}: Esri/GDB file format
         *     <li>{@link Options#JSON JSON}: Json file format
         *     <li>{@link Options#PARQUET PARQUET}: Apache Parquet file format
         *     <li>{@link Options#SHAPEFILE SHAPEFILE}: ShapeFile file format
         * </ul>
         * The default value is {@link Options#DELIMITED_TEXT DELIMITED_TEXT}.
         */
        public static final String FILE_TYPE = "file_type";

        /**
         * Avro file format
         */
        public static final String AVRO = "avro";

        /**
         * Delimited text file format; e.g., CSV, TSV, PSV, etc.
         */
        public static final String DELIMITED_TEXT = "delimited_text";

        /**
         * Esri/GDB file format
         */
        public static final String GDB = "gdb";

        /**
         * Json file format
         */
        public static final String JSON = "json";

        /**
         * Apache Parquet file format
         */
        public static final String PARQUET = "parquet";

        /**
         * ShapeFile file format
         */
        public static final String SHAPEFILE = "shapefile";

        /**
         * Specifies how to handle nested columns.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Break up nested columns to
         *         multiple columns
         *     <li>{@link Options#FALSE FALSE}: Treat nested columns as json
         *         columns instead of flattening
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String FLATTEN_COLUMNS = "flatten_columns";

        /**
         * Comma separated list of gdal conf options, for the specific requets:
         * key=value. The default value is ''.
         */
        public static final String GDAL_CONFIGURATION_OPTIONS = "gdal_configuration_options";

        /**
         * Specifies the record collision error-suppression policy for
         * inserting into a table with a <a
         * href="../../../../../../concepts/tables/#primary-keys"
         * target="_top">primary key</a>, only used when not in upsert mode
         * (upsert mode is disabled when {@link Options#UPDATE_ON_EXISTING_PK
         * UPDATE_ON_EXISTING_PK} is {@link Options#FALSE FALSE}).  If set to
         * {@link Options#TRUE TRUE}, any record being inserted that is
         * rejected for having primary key values that match those of an
         * existing table record will be ignored with no error generated.  If
         * {@link Options#FALSE FALSE}, the rejection of any record for having
         * primary key values matching an existing record will result in an
         * error being reported, as determined by {@link Options#ERROR_HANDLING
         * ERROR_HANDLING}.  If the specified table does not have a primary key
         * or if upsert mode is in effect ({@link Options#UPDATE_ON_EXISTING_PK
         * UPDATE_ON_EXISTING_PK} is {@link Options#TRUE TRUE}), then this
         * option has no effect.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Ignore new records whose primary
         *         key values collide with those of existing records
         *     <li>{@link Options#FALSE FALSE}: Treat as errors any new records
         *         whose primary key values collide with those of existing
         *         records
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String IGNORE_EXISTING_PK = "ignore_existing_pk";

        /**
         * Whether to do a full load, dry run, or perform a type inference on
         * the source data.
         * Supported values:
         * <ul>
         *     <li>{@link Options#FULL FULL}: Run a type inference on the
         *         source data (if needed) and ingest
         *     <li>{@link Options#DRY_RUN DRY_RUN}: Does not load data, but
         *         walks through the source data and determines the number of
         *         valid records, taking into account the current mode of
         *         {@link Options#ERROR_HANDLING ERROR_HANDLING}.
         *     <li>{@link Options#TYPE_INFERENCE_ONLY TYPE_INFERENCE_ONLY}:
         *         Infer the type of the source data and return, without
         *         ingesting any data.  The inferred type is returned in the
         *         response.
         * </ul>
         * The default value is {@link Options#FULL FULL}.
         */
        public static final String INGESTION_MODE = "ingestion_mode";

        /**
         * Run a type inference on the source data (if needed) and ingest
         */
        public static final String FULL = "full";

        /**
         * Does not load data, but walks through the source data and determines
         * the number of valid records, taking into account the current mode of
         * {@link Options#ERROR_HANDLING ERROR_HANDLING}.
         */
        public static final String DRY_RUN = "dry_run";

        /**
         * Infer the type of the source data and return, without ingesting any
         * data.  The inferred type is returned in the response.
         */
        public static final String TYPE_INFERENCE_ONLY = "type_inference_only";

        /**
         * Optional: geo files layer(s) name(s): comma separated. The default
         * value is ''.
         */
        public static final String LAYER = "layer";

        /**
         * Scheme for distributing the extraction and loading of data from the
         * source data file(s). This option applies only when loading files
         * that are local to the database.
         * Supported values:
         * <ul>
         *     <li>{@link Options#HEAD HEAD}: The head node loads all data. All
         *         files must be available to the head node.
         *     <li>{@link Options#DISTRIBUTED_SHARED DISTRIBUTED_SHARED}: The
         *         head node coordinates loading data by worker processes
         *         across all nodes from shared files available to all workers.
         *         NOTE:  Instead of existing on a shared source, the files can
         *         be duplicated on a source local to each host to improve
         *         performance, though the files must appear as the same data
         *         set from the perspective of all hosts performing the load.
         *     <li>{@link Options#DISTRIBUTED_LOCAL DISTRIBUTED_LOCAL}: A
         *         single worker process on each node loads all files that are
         *         available to it. This option works best when each worker
         *         loads files from its own file system, to maximize
         *         performance. In order to avoid data duplication, either each
         *         worker performing the load needs to have visibility to a set
         *         of files unique to it (no file is visible to more than one
         *         node) or the target table needs to have a primary key (which
         *         will allow the worker to automatically deduplicate data).
         *         NOTE:  If the target table doesn't exist, the table
         *         structure will be determined by the head node. If the head
         *         node has no files local to it, it will be unable to
         *         determine the structure and the request will fail.  If the
         *         head node is configured to have no worker processes, no data
         *         strictly accessible to the head node will be loaded.
         * </ul>
         * The default value is {@link Options#HEAD HEAD}.
         */
        public static final String LOADING_MODE = "loading_mode";

        /**
         * The head node loads all data. All files must be available to the
         * head node.
         */
        public static final String HEAD = "head";

        /**
         * The head node coordinates loading data by worker processes across
         * all nodes from shared files available to all workers.
         * <p>
         * NOTE:
         * <p>
         * Instead of existing on a shared source, the files can be duplicated
         * on a source local to each host to improve performance, though the
         * files must appear as the same data set from the perspective of all
         * hosts performing the load.
         */
        public static final String DISTRIBUTED_SHARED = "distributed_shared";

        /**
         * A single worker process on each node loads all files that are
         * available to it. This option works best when each worker loads files
         * from its own file system, to maximize performance. In order to avoid
         * data duplication, either each worker performing the load needs to
         * have visibility to a set of files unique to it (no file is visible
         * to more than one node) or the target table needs to have a primary
         * key (which will allow the worker to automatically deduplicate data).
         * <p>
         * NOTE:
         * <p>
         * If the target table doesn't exist, the table structure will be
         * determined by the head node. If the head node has no files local to
         * it, it will be unable to determine the structure and the request
         * will fail.
         * <p>
         * If the head node is configured to have no worker processes, no data
         * strictly accessible to the head node will be loaded.
         */
        public static final String DISTRIBUTED_LOCAL = "distributed_local";

        /**
         * For Avro local timestamp columns
         */
        public static final String LOCAL_TIME_OFFSET = "local_time_offset";

        /**
         * Limit the number of records to load in this request: If this number
         * is larger than a batch_size, then the number of records loaded will
         * be limited to the next whole number of batch_size (per working
         * thread). The default value is ''.
         */
        public static final String MAX_RECORDS_TO_LOAD = "max_records_to_load";

        /**
         * Optional: number of tasks for reading file per rank. Default will be
         * external_file_reader_num_tasks
         */
        public static final String NUM_TASKS_PER_RANK = "num_tasks_per_rank";

        /**
         * If {@link Options#TRUE TRUE}, the number of seconds between attempts
         * to load external files into the table.  If zero, polling will be
         * continuous as long as data is found.  If no data is found, the
         * interval will steadily increase to a maximum of 60 seconds.
         */
        public static final String POLL_INTERVAL = "poll_interval";

        /**
         * Optional: comma separated list of column names, to set as primary
         * keys, when not specified in the type. The default value is ''.
         */
        public static final String PRIMARY_KEYS = "primary_keys";

        public static final String SCHEMA_REGISTRY_SCHEMA_ID = "schema_registry_schema_id";
        public static final String SCHEMA_REGISTRY_SCHEMA_NAME = "schema_registry_schema_name";
        public static final String SCHEMA_REGISTRY_SCHEMA_VERSION = "schema_registry_schema_version";

        /**
         * Optional: comma separated list of column names, to set as primary
         * keys, when not specified in the type. The default value is ''.
         */
        public static final String SHARD_KEYS = "shard_keys";

        /**
         * Skip number of lines from begining of file.
         */
        public static final String SKIP_LINES = "skip_lines";

        /**
         * Continuously poll the data source to check for new data and load it
         * into the table.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String SUBSCRIBE = "subscribe";

        /**
         * Optional: table_insert_mode. When inserting records from multiple
         * files: if table_per_file then insert from each file into a new
         * table. Currently supported only for shapefiles.
         * Supported values:
         * <ul>
         *     <li>{@link Options#SINGLE SINGLE}
         *     <li>{@link Options#TABLE_PER_FILE TABLE_PER_FILE}
         * </ul>
         * The default value is {@link Options#SINGLE SINGLE}.
         */
        public static final String TABLE_INSERT_MODE = "table_insert_mode";

        public static final String SINGLE = "single";
        public static final String TABLE_PER_FILE = "table_per_file";

        /**
         * Specifies the character string that should be interpreted as a
         * comment line prefix in the source data.  All lines in the data
         * starting with the provided string are ignored.
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only. The default value is '#'.
         */
        public static final String TEXT_COMMENT_STRING = "text_comment_string";

        /**
         * Specifies the character delimiting field values in the source data
         * and field names in the header (if present).
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only. The default value is ','.
         */
        public static final String TEXT_DELIMITER = "text_delimiter";

        /**
         * Specifies the character that is used to escape other characters in
         * the source data.
         * <p>
         * An 'a', 'b', 'f', 'n', 'r', 't', or 'v' preceded by an escape
         * character will be interpreted as the ASCII bell, backspace, form
         * feed, line feed, carriage return, horizontal tab, & vertical tab,
         * respectively.  For example, the escape character followed by an 'n'
         * will be interpreted as a newline within a field value.
         * <p>
         * The escape character can also be used to escape the quoting
         * character, and will be treated as an escape character whether it is
         * within a quoted field value or not.
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only.
         */
        public static final String TEXT_ESCAPE_CHARACTER = "text_escape_character";

        /**
         * Indicates whether the source data contains a header row.
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#TRUE TRUE}.
         */
        public static final String TEXT_HAS_HEADER = "text_has_header";

        /**
         * Specifies the delimiter for <a
         * href="../../../../../../concepts/types/#column-properties"
         * target="_top">column properties</a> in the header row (if present).
         * Cannot be set to same value as {@link Options#TEXT_DELIMITER
         * TEXT_DELIMITER}.
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only. The default value is '|'.
         */
        public static final String TEXT_HEADER_PROPERTY_DELIMITER = "text_header_property_delimiter";

        /**
         * Specifies the character string that should be interpreted as a null
         * value in the source data.
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only. The default value is '\N'.
         */
        public static final String TEXT_NULL_STRING = "text_null_string";

        /**
         * Specifies the character that should be interpreted as a field value
         * quoting character in the source data.  The character must appear at
         * beginning and end of field value to take effect.  Delimiters within
         * quoted fields are treated as literals and not delimiters.  Within a
         * quoted field, two consecutive quote characters will be interpreted
         * as a single literal quote character, effectively escaping it.  To
         * not have a quote character, specify an empty string.
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only. The default value is '"'.
         */
        public static final String TEXT_QUOTE_CHARACTER = "text_quote_character";

        /**
         * Add 'text_search' property to internally inferenced string columns.
         * Comma seperated list of column names or '*' for all columns. To add
         * text_search property only to string columns of minimum size, set
         * also the option 'text_search_min_column_length'
         */
        public static final String TEXT_SEARCH_COLUMNS = "text_search_columns";

        /**
         * Set minimum column size. Used only when 'text_search_columns' has a
         * value.
         */
        public static final String TEXT_SEARCH_MIN_COLUMN_LENGTH = "text_search_min_column_length";

        /**
         * If set to {@link Options#TRUE TRUE}, truncate string values that are
         * longer than the column's type size.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String TRUNCATE_STRINGS = "truncate_strings";

        /**
         * If set to {@link Options#TRUE TRUE}, truncates the table specified
         * by {@link #getTableName() tableName} prior to loading the file(s).
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String TRUNCATE_TABLE = "truncate_table";

        /**
         * optimize type inference for:
         * Supported values:
         * <ul>
         *     <li>{@link Options#ACCURACY ACCURACY}: Scans data to get
         *         exactly-typed & sized columns for all data scanned.
         *     <li>{@link Options#SPEED SPEED}: Scans data and picks the widest
         *         possible column types so that 'all' values will fit with
         *         minimum data scanned
         * </ul>
         * The default value is {@link Options#ACCURACY ACCURACY}.
         */
        public static final String TYPE_INFERENCE_MODE = "type_inference_mode";

        /**
         * Scans data to get exactly-typed & sized columns for all data
         * scanned.
         */
        public static final String ACCURACY = "accuracy";

        /**
         * Scans data and picks the widest possible column types so that 'all'
         * values will fit with minimum data scanned
         */
        public static final String SPEED = "speed";

        /**
         * Specifies the record collision policy for inserting into a table
         * with a <a href="../../../../../../concepts/tables/#primary-keys"
         * target="_top">primary key</a>. If set to {@link Options#TRUE TRUE},
         * any existing table record with primary key values that match those
         * of a record being inserted will be replaced by that new record (the
         * new data will be "upserted"). If set to {@link Options#FALSE FALSE},
         * any existing table record with primary key values that match those
         * of a record being inserted will remain unchanged, while the new
         * record will be rejected and the error handled as determined by
         * {@link Options#IGNORE_EXISTING_PK IGNORE_EXISTING_PK} & {@link
         * Options#ERROR_HANDLING ERROR_HANDLING}.  If the specified table does
         * not have a primary key, then this option has no effect.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Upsert new records when primary
         *         keys match existing records
         *     <li>{@link Options#FALSE FALSE}: Reject new records when primary
         *         keys match existing records
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String UPDATE_ON_EXISTING_PK = "update_on_existing_pk";

        private Options() {  }
    }

    private String tableName;
    private String dataText;
    private ByteBuffer dataBytes;
    private Map<String, Map<String, String>> modifyColumns;
    private Map<String, String> createTableOptions;
    private Map<String, String> options;

    /**
     * Constructs an InsertRecordsFromPayloadRequest object with default
     * parameters.
     */
    public InsertRecordsFromPayloadRequest() {
        tableName = "";
        dataText = "";
        dataBytes = ByteBuffer.wrap( new byte[0] );
        modifyColumns = new LinkedHashMap<>();
        createTableOptions = new LinkedHashMap<>();
        options = new LinkedHashMap<>();
    }

    /**
     * Constructs an InsertRecordsFromPayloadRequest object with the specified
     * parameters.
     *
     * @param tableName  Name of the table into which the data will be
     *                   inserted, in [schema_name.]table_name format, using
     *                   standard <a
     *                   href="../../../../../../concepts/tables/#table-name-resolution"
     *                   target="_top">name resolution rules</a>. If the table
     *                   does not exist, the table will be created using either
     *                   an existing {@link CreateTableOptions#TYPE_ID TYPE_ID}
     *                   or the type inferred from the payload, and the new
     *                   table name will have to meet standard <a
     *                   href="../../../../../../concepts/tables/#table-naming-criteria"
     *                   target="_top">table naming criteria</a>.
     * @param dataText  Records formatted as delimited text
     * @param dataBytes  Records formatted as binary data
     * @param modifyColumns  Not implemented yet. The default value is an empty
     *                       {@link Map}.
     * @param createTableOptions  Options used when creating the target table.
     *                            Includes type to use. The other options match
     *                            those in {@link
     *                            com.gpudb.GPUdb#createTable(CreateTableRequest)
     *                            GPUdb.createTable}.
     *                            <ul>
     *                                <li>{@link CreateTableOptions#TYPE_ID
     *                                    TYPE_ID}: ID of a currently
     *                                    registered <a
     *                                    href="../../../../../../concepts/types/"
     *                                    target="_top">type</a>. The default
     *                                    value is ''.
     *                                <li>{@link
     *                                    CreateTableOptions#NO_ERROR_IF_EXISTS
     *                                    NO_ERROR_IF_EXISTS}: If {@link
     *                                    CreateTableOptions#TRUE TRUE},
     *                                    prevents an error from occurring if
     *                                    the table already exists and is of
     *                                    the given type.  If a table with the
     *                                    same ID but a different type exists,
     *                                    it is still an error.
     *                                    Supported values:
     *                                    <ul>
     *                                        <li>{@link
     *                                            CreateTableOptions#TRUE TRUE}
     *                                        <li>{@link
     *                                            CreateTableOptions#FALSE
     *                                            FALSE}
     *                                    </ul>
     *                                    The default value is {@link
     *                                    CreateTableOptions#FALSE FALSE}.
     *                                <li>{@link
     *                                    CreateTableOptions#IS_REPLICATED
     *                                    IS_REPLICATED}: Affects the <a
     *                                    href="../../../../../../concepts/tables/#distribution"
     *                                    target="_top">distribution scheme</a>
     *                                    for the table's data.  If {@link
     *                                    CreateTableOptions#TRUE TRUE} and the
     *                                    given type has no explicit <a
     *                                    href="../../../../../../concepts/tables/#shard-key"
     *                                    target="_top">shard key</a> defined,
     *                                    the table will be <a
     *                                    href="../../../../../../concepts/tables/#replication"
     *                                    target="_top">replicated</a>.  If
     *                                    {@link CreateTableOptions#FALSE
     *                                    FALSE}, the table will be <a
     *                                    href="../../../../../../concepts/tables/#sharding"
     *                                    target="_top">sharded</a> according
     *                                    to the shard key specified in the
     *                                    given {@link
     *                                    CreateTableOptions#TYPE_ID TYPE_ID},
     *                                    or <a
     *                                    href="../../../../../../concepts/tables/#random-sharding"
     *                                    target="_top">randomly sharded</a>,
     *                                    if no shard key is specified.  Note
     *                                    that a type containing a shard key
     *                                    cannot be used to create a replicated
     *                                    table.
     *                                    Supported values:
     *                                    <ul>
     *                                        <li>{@link
     *                                            CreateTableOptions#TRUE TRUE}
     *                                        <li>{@link
     *                                            CreateTableOptions#FALSE
     *                                            FALSE}
     *                                    </ul>
     *                                    The default value is {@link
     *                                    CreateTableOptions#FALSE FALSE}.
     *                                <li>{@link
     *                                    CreateTableOptions#FOREIGN_KEYS
     *                                    FOREIGN_KEYS}: Semicolon-separated
     *                                    list of <a
     *                                    href="../../../../../../concepts/tables/#foreign-keys"
     *                                    target="_top">foreign keys</a>, of
     *                                    the format '(source_column_name [,
     *                                    ...]) references
     *                                    target_table_name(primary_key_column_name
     *                                    [, ...]) [as foreign_key_name]'.
     *                                <li>{@link
     *                                    CreateTableOptions#FOREIGN_SHARD_KEY
     *                                    FOREIGN_SHARD_KEY}: Foreign shard key
     *                                    of the format 'source_column
     *                                    references shard_by_column from
     *                                    target_table(primary_key_column)'.
     *                                <li>{@link
     *                                    CreateTableOptions#PARTITION_TYPE
     *                                    PARTITION_TYPE}: <a
     *                                    href="../../../../../../concepts/tables/#partitioning"
     *                                    target="_top">Partitioning</a> scheme
     *                                    to use.
     *                                    Supported values:
     *                                    <ul>
     *                                        <li>{@link
     *                                            CreateTableOptions#RANGE
     *                                            RANGE}: Use <a
     *                                            href="../../../../../../concepts/tables/#partitioning-by-range"
     *                                            target="_top">range
     *                                            partitioning</a>.
     *                                        <li>{@link
     *                                            CreateTableOptions#INTERVAL
     *                                            INTERVAL}: Use <a
     *                                            href="../../../../../../concepts/tables/#partitioning-by-interval"
     *                                            target="_top">interval
     *                                            partitioning</a>.
     *                                        <li>{@link
     *                                            CreateTableOptions#LIST
     *                                            LIST}: Use <a
     *                                            href="../../../../../../concepts/tables/#partitioning-by-list"
     *                                            target="_top">list
     *                                            partitioning</a>.
     *                                        <li>{@link
     *                                            CreateTableOptions#HASH
     *                                            HASH}: Use <a
     *                                            href="../../../../../../concepts/tables/#partitioning-by-hash"
     *                                            target="_top">hash
     *                                            partitioning</a>.
     *                                        <li>{@link
     *                                            CreateTableOptions#SERIES
     *                                            SERIES}: Use <a
     *                                            href="../../../../../../concepts/tables/#partitioning-by-series"
     *                                            target="_top">series
     *                                            partitioning</a>.
     *                                    </ul>
     *                                <li>{@link
     *                                    CreateTableOptions#PARTITION_KEYS
     *                                    PARTITION_KEYS}: Comma-separated list
     *                                    of partition keys, which are the
     *                                    columns or column expressions by
     *                                    which records will be assigned to
     *                                    partitions defined by {@link
     *                                    CreateTableOptions#PARTITION_DEFINITIONS
     *                                    PARTITION_DEFINITIONS}.
     *                                <li>{@link
     *                                    CreateTableOptions#PARTITION_DEFINITIONS
     *                                    PARTITION_DEFINITIONS}:
     *                                    Comma-separated list of partition
     *                                    definitions, whose format depends on
     *                                    the choice of {@link
     *                                    CreateTableOptions#PARTITION_TYPE
     *                                    PARTITION_TYPE}.  See <a
     *                                    href="../../../../../../concepts/tables/#partitioning-by-range"
     *                                    target="_top">range partitioning</a>,
     *                                    <a
     *                                    href="../../../../../../concepts/tables/#partitioning-by-interval"
     *                                    target="_top">interval
     *                                    partitioning</a>, <a
     *                                    href="../../../../../../concepts/tables/#partitioning-by-list"
     *                                    target="_top">list partitioning</a>,
     *                                    <a
     *                                    href="../../../../../../concepts/tables/#partitioning-by-hash"
     *                                    target="_top">hash partitioning</a>,
     *                                    or <a
     *                                    href="../../../../../../concepts/tables/#partitioning-by-series"
     *                                    target="_top">series partitioning</a>
     *                                    for example formats.
     *                                <li>{@link
     *                                    CreateTableOptions#IS_AUTOMATIC_PARTITION
     *                                    IS_AUTOMATIC_PARTITION}: If {@link
     *                                    CreateTableOptions#TRUE TRUE}, a new
     *                                    partition will be created for values
     *                                    which don't fall into an existing
     *                                    partition.  Currently only supported
     *                                    for <a
     *                                    href="../../../../../../concepts/tables/#partitioning-by-list"
     *                                    target="_top">list partitions</a>.
     *                                    Supported values:
     *                                    <ul>
     *                                        <li>{@link
     *                                            CreateTableOptions#TRUE TRUE}
     *                                        <li>{@link
     *                                            CreateTableOptions#FALSE
     *                                            FALSE}
     *                                    </ul>
     *                                    The default value is {@link
     *                                    CreateTableOptions#FALSE FALSE}.
     *                                <li>{@link CreateTableOptions#TTL TTL}:
     *                                    Sets the <a
     *                                    href="../../../../../../concepts/ttl/"
     *                                    target="_top">TTL</a> of the table
     *                                    specified in {@code tableName}.
     *                                <li>{@link CreateTableOptions#CHUNK_SIZE
     *                                    CHUNK_SIZE}: Indicates the number of
     *                                    records per chunk to be used for this
     *                                    table.
     *                                <li>{@link
     *                                    CreateTableOptions#CHUNK_COLUMN_MAX_MEMORY
     *                                    CHUNK_COLUMN_MAX_MEMORY}: Indicates
     *                                    the target maximum data size for each
     *                                    column in a chunk to be used for this
     *                                    table.
     *                                <li>{@link
     *                                    CreateTableOptions#CHUNK_MAX_MEMORY
     *                                    CHUNK_MAX_MEMORY}: Indicates the
     *                                    target maximum data size for all
     *                                    columns in a chunk to be used for
     *                                    this table.
     *                                <li>{@link
     *                                    CreateTableOptions#IS_RESULT_TABLE
     *                                    IS_RESULT_TABLE}: Indicates whether
     *                                    the table is a <a
     *                                    href="../../../../../../concepts/tables_memory_only/"
     *                                    target="_top">memory-only table</a>.
     *                                    A result table cannot contain columns
     *                                    with text_search <a
     *                                    href="../../../../../../concepts/types/#data-handling"
     *                                    target="_top">data-handling</a>, and
     *                                    it will not be retained if the server
     *                                    is restarted.
     *                                    Supported values:
     *                                    <ul>
     *                                        <li>{@link
     *                                            CreateTableOptions#TRUE TRUE}
     *                                        <li>{@link
     *                                            CreateTableOptions#FALSE
     *                                            FALSE}
     *                                    </ul>
     *                                    The default value is {@link
     *                                    CreateTableOptions#FALSE FALSE}.
     *                                <li>{@link
     *                                    CreateTableOptions#STRATEGY_DEFINITION
     *                                    STRATEGY_DEFINITION}: The <a
     *                                    href="../../../../../../rm/concepts/#tier-strategies"
     *                                    target="_top">tier strategy</a> for
     *                                    the table and its columns.
     *                            </ul>
     *                            The default value is an empty {@link Map}.
     * @param options  Optional parameters.
     *                 <ul>
     *                     <li>{@link Options#AVRO_HEADER_BYTES
     *                         AVRO_HEADER_BYTES}: Optional number of bytes to
     *                         skip when reading an avro record.
     *                     <li>{@link Options#AVRO_NUM_RECORDS
     *                         AVRO_NUM_RECORDS}: Optional number of avro
     *                         records, if data includes only records.
     *                     <li>{@link Options#AVRO_SCHEMA AVRO_SCHEMA}:
     *                         Optional string representing avro schema, for
     *                         insert records in avro format, that does not
     *                         include is schema.
     *                     <li>{@link Options#AVRO_SCHEMALESS AVRO_SCHEMALESS}:
     *                         When user provides 'avro_schema', avro data is
     *                         assumed to be schemaless, unless specified.
     *                         Default is 'true' when given avro_schema.
     *                         Igonred when avro_schema is not given.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                     <li>{@link Options#BAD_RECORD_TABLE_NAME
     *                         BAD_RECORD_TABLE_NAME}: Optional name of a table
     *                         to which records that were rejected are written.
     *                         The bad-record-table has the following columns:
     *                         line_number (long), line_rejected (string),
     *                         error_message (string).
     *                     <li>{@link Options#BAD_RECORD_TABLE_LIMIT
     *                         BAD_RECORD_TABLE_LIMIT}: A positive integer
     *                         indicating the maximum number of records that
     *                         can be  written to the bad-record-table.
     *                         Default value is 10000
     *                     <li>{@link Options#BAD_RECORD_TABLE_LIMIT_PER_INPUT
     *                         BAD_RECORD_TABLE_LIMIT_PER_INPUT}: For
     *                         subscriptions: A positive integer indicating the
     *                         maximum number of records that can be written to
     *                         the bad-record-table per file/payload. Default
     *                         value will be 'bad_record_table_limit' and total
     *                         size of the table per rank is limited to
     *                         'bad_record_table_limit'
     *                     <li>{@link Options#BATCH_SIZE BATCH_SIZE}: Internal
     *                         tuning parameter--number of records per batch
     *                         when inserting data.
     *                     <li>{@link Options#COLUMN_FORMATS COLUMN_FORMATS}:
     *                         For each target column specified, applies the
     *                         column-property-bound format to the source data
     *                         loaded into that column.  Each column format
     *                         will contain a mapping of one or more of its
     *                         column properties to an appropriate format for
     *                         each property.  Currently supported column
     *                         properties include date, time, & datetime. The
     *                         parameter value must be formatted as a JSON
     *                         string of maps of column names to maps of column
     *                         properties to their corresponding column
     *                         formats, e.g., '{ "order_date" : { "date" :
     *                         "%Y.%m.%d" }, "order_time" : { "time" :
     *                         "%H:%M:%S" } }'.  See {@link
     *                         Options#DEFAULT_COLUMN_FORMATS
     *                         DEFAULT_COLUMN_FORMATS} for valid format syntax.
     *                     <li>{@link Options#COLUMNS_TO_LOAD COLUMNS_TO_LOAD}:
     *                         Specifies a comma-delimited list of columns from
     *                         the source data to load.  If more than one file
     *                         is being loaded, this list applies to all files.
     *                         Column numbers can be specified discretely or as
     *                         a range.  For example, a value of '5,7,1..3'
     *                         will insert values from the fifth column in the
     *                         source data into the first column in the target
     *                         table, from the seventh column in the source
     *                         data into the second column in the target table,
     *                         and from the first through third columns in the
     *                         source data into the third through fifth columns
     *                         in the target table.  If the source data
     *                         contains a header, column names matching the
     *                         file header names may be provided instead of
     *                         column numbers.  If the target table doesn't
     *                         exist, the table will be created with the
     *                         columns in this order.  If the target table does
     *                         exist with columns in a different order than the
     *                         source data, this list can be used to match the
     *                         order of the target table.  For example, a value
     *                         of 'C, B, A' will create a three column table
     *                         with column C, followed by column B, followed by
     *                         column A; or will insert those fields in that
     *                         order into a table created with columns in that
     *                         order.  If the target table exists, the column
     *                         names must match the source data field names for
     *                         a name-mapping to be successful.  Mutually
     *                         exclusive with {@link Options#COLUMNS_TO_SKIP
     *                         COLUMNS_TO_SKIP}.
     *                     <li>{@link Options#COLUMNS_TO_SKIP COLUMNS_TO_SKIP}:
     *                         Specifies a comma-delimited list of columns from
     *                         the source data to skip.  Mutually exclusive
     *                         with {@link Options#COLUMNS_TO_LOAD
     *                         COLUMNS_TO_LOAD}.
     *                     <li>{@link Options#COMPRESSION_TYPE
     *                         COMPRESSION_TYPE}: Optional: payload compression
     *                         type.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#NONE NONE}: Uncompressed
     *                             <li>{@link Options#AUTO AUTO}: Default. Auto
     *                                 detect compression type
     *                             <li>{@link Options#GZIP GZIP}: gzip file
     *                                 compression.
     *                             <li>{@link Options#BZIP2 BZIP2}: bzip2 file
     *                                 compression.
     *                         </ul>
     *                         The default value is {@link Options#AUTO AUTO}.
     *                     <li>{@link Options#DEFAULT_COLUMN_FORMATS
     *                         DEFAULT_COLUMN_FORMATS}: Specifies the default
     *                         format to be applied to source data loaded into
     *                         columns with the corresponding column property.
     *                         Currently supported column properties include
     *                         date, time, & datetime.  This default
     *                         column-property-bound format can be overridden
     *                         by specifying a column property & format for a
     *                         given target column in {@link
     *                         Options#COLUMN_FORMATS COLUMN_FORMATS}. For each
     *                         specified annotation, the format will apply to
     *                         all columns with that annotation unless a custom
     *                         {@link Options#COLUMN_FORMATS COLUMN_FORMATS}
     *                         for that annotation is specified.  The parameter
     *                         value must be formatted as a JSON string that is
     *                         a map of column properties to their respective
     *                         column formats, e.g., '{ "date" : "%Y.%m.%d",
     *                         "time" : "%H:%M:%S" }'.  Column formats are
     *                         specified as a string of control characters and
     *                         plain text. The supported control characters are
     *                         'Y', 'm', 'd', 'H', 'M', 'S', and 's', which
     *                         follow the Linux 'strptime()' specification, as
     *                         well as 's', which specifies seconds and
     *                         fractional seconds (though the fractional
     *                         component will be truncated past milliseconds).
     *                         Formats for the 'date' annotation must include
     *                         the 'Y', 'm', and 'd' control characters.
     *                         Formats for the 'time' annotation must include
     *                         the 'H', 'M', and either 'S' or 's' (but not
     *                         both) control characters. Formats for the
     *                         'datetime' annotation meet both the 'date' and
     *                         'time' control character requirements. For
     *                         example, '{"datetime" : "%m/%d/%Y %H:%M:%S" }'
     *                         would be used to interpret text as "05/04/2000
     *                         12:12:11"
     *                     <li>{@link Options#ERROR_HANDLING ERROR_HANDLING}:
     *                         Specifies how errors should be handled upon
     *                         insertion.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#PERMISSIVE PERMISSIVE}:
     *                                 Records with missing columns are
     *                                 populated with nulls if possible;
     *                                 otherwise, the malformed records are
     *                                 skipped.
     *                             <li>{@link Options#IGNORE_BAD_RECORDS
     *                                 IGNORE_BAD_RECORDS}: Malformed records
     *                                 are skipped.
     *                             <li>{@link Options#ABORT ABORT}: Stops
     *                                 current insertion and aborts entire
     *                                 operation when an error is encountered.
     *                                 Primary key collisions are considered
     *                                 abortable errors in this mode.
     *                         </ul>
     *                         The default value is {@link Options#ABORT
     *                         ABORT}.
     *                     <li>{@link Options#FILE_TYPE FILE_TYPE}: Specifies
     *                         the type of the file(s) whose records will be
     *                         inserted.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#AVRO AVRO}: Avro file
     *                                 format
     *                             <li>{@link Options#DELIMITED_TEXT
     *                                 DELIMITED_TEXT}: Delimited text file
     *                                 format; e.g., CSV, TSV, PSV, etc.
     *                             <li>{@link Options#GDB GDB}: Esri/GDB file
     *                                 format
     *                             <li>{@link Options#JSON JSON}: Json file
     *                                 format
     *                             <li>{@link Options#PARQUET PARQUET}: Apache
     *                                 Parquet file format
     *                             <li>{@link Options#SHAPEFILE SHAPEFILE}:
     *                                 ShapeFile file format
     *                         </ul>
     *                         The default value is {@link
     *                         Options#DELIMITED_TEXT DELIMITED_TEXT}.
     *                     <li>{@link Options#FLATTEN_COLUMNS FLATTEN_COLUMNS}:
     *                         Specifies how to handle nested columns.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Break up
     *                                 nested columns to multiple columns
     *                             <li>{@link Options#FALSE FALSE}: Treat
     *                                 nested columns as json columns instead
     *                                 of flattening
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#GDAL_CONFIGURATION_OPTIONS
     *                         GDAL_CONFIGURATION_OPTIONS}: Comma separated
     *                         list of gdal conf options, for the specific
     *                         requets: key=value. The default value is ''.
     *                     <li>{@link Options#IGNORE_EXISTING_PK
     *                         IGNORE_EXISTING_PK}: Specifies the record
     *                         collision error-suppression policy for inserting
     *                         into a table with a <a
     *                         href="../../../../../../concepts/tables/#primary-keys"
     *                         target="_top">primary key</a>, only used when
     *                         not in upsert mode (upsert mode is disabled when
     *                         {@link Options#UPDATE_ON_EXISTING_PK
     *                         UPDATE_ON_EXISTING_PK} is {@link Options#FALSE
     *                         FALSE}).  If set to {@link Options#TRUE TRUE},
     *                         any record being inserted that is rejected for
     *                         having primary key values that match those of an
     *                         existing table record will be ignored with no
     *                         error generated.  If {@link Options#FALSE
     *                         FALSE}, the rejection of any record for having
     *                         primary key values matching an existing record
     *                         will result in an error being reported, as
     *                         determined by {@link Options#ERROR_HANDLING
     *                         ERROR_HANDLING}.  If the specified table does
     *                         not have a primary key or if upsert mode is in
     *                         effect ({@link Options#UPDATE_ON_EXISTING_PK
     *                         UPDATE_ON_EXISTING_PK} is {@link Options#TRUE
     *                         TRUE}), then this option has no effect.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Ignore new
     *                                 records whose primary key values collide
     *                                 with those of existing records
     *                             <li>{@link Options#FALSE FALSE}: Treat as
     *                                 errors any new records whose primary key
     *                                 values collide with those of existing
     *                                 records
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#INGESTION_MODE INGESTION_MODE}:
     *                         Whether to do a full load, dry run, or perform a
     *                         type inference on the source data.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#FULL FULL}: Run a type
     *                                 inference on the source data (if needed)
     *                                 and ingest
     *                             <li>{@link Options#DRY_RUN DRY_RUN}: Does
     *                                 not load data, but walks through the
     *                                 source data and determines the number of
     *                                 valid records, taking into account the
     *                                 current mode of {@link
     *                                 Options#ERROR_HANDLING ERROR_HANDLING}.
     *                             <li>{@link Options#TYPE_INFERENCE_ONLY
     *                                 TYPE_INFERENCE_ONLY}: Infer the type of
     *                                 the source data and return, without
     *                                 ingesting any data.  The inferred type
     *                                 is returned in the response.
     *                         </ul>
     *                         The default value is {@link Options#FULL FULL}.
     *                     <li>{@link Options#LAYER LAYER}: Optional: geo files
     *                         layer(s) name(s): comma separated. The default
     *                         value is ''.
     *                     <li>{@link Options#LOADING_MODE LOADING_MODE}:
     *                         Scheme for distributing the extraction and
     *                         loading of data from the source data file(s).
     *                         This option applies only when loading files that
     *                         are local to the database.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#HEAD HEAD}: The head node
     *                                 loads all data. All files must be
     *                                 available to the head node.
     *                             <li>{@link Options#DISTRIBUTED_SHARED
     *                                 DISTRIBUTED_SHARED}: The head node
     *                                 coordinates loading data by worker
     *                                 processes across all nodes from shared
     *                                 files available to all workers.  NOTE:
     *                                 Instead of existing on a shared source,
     *                                 the files can be duplicated on a source
     *                                 local to each host to improve
     *                                 performance, though the files must
     *                                 appear as the same data set from the
     *                                 perspective of all hosts performing the
     *                                 load.
     *                             <li>{@link Options#DISTRIBUTED_LOCAL
     *                                 DISTRIBUTED_LOCAL}: A single worker
     *                                 process on each node loads all files
     *                                 that are available to it. This option
     *                                 works best when each worker loads files
     *                                 from its own file system, to maximize
     *                                 performance. In order to avoid data
     *                                 duplication, either each worker
     *                                 performing the load needs to have
     *                                 visibility to a set of files unique to
     *                                 it (no file is visible to more than one
     *                                 node) or the target table needs to have
     *                                 a primary key (which will allow the
     *                                 worker to automatically deduplicate
     *                                 data).  NOTE:  If the target table
     *                                 doesn't exist, the table structure will
     *                                 be determined by the head node. If the
     *                                 head node has no files local to it, it
     *                                 will be unable to determine the
     *                                 structure and the request will fail.  If
     *                                 the head node is configured to have no
     *                                 worker processes, no data strictly
     *                                 accessible to the head node will be
     *                                 loaded.
     *                         </ul>
     *                         The default value is {@link Options#HEAD HEAD}.
     *                     <li>{@link Options#LOCAL_TIME_OFFSET
     *                         LOCAL_TIME_OFFSET}: For Avro local timestamp
     *                         columns
     *                     <li>{@link Options#MAX_RECORDS_TO_LOAD
     *                         MAX_RECORDS_TO_LOAD}: Limit the number of
     *                         records to load in this request: If this number
     *                         is larger than a batch_size, then the number of
     *                         records loaded will be limited to the next whole
     *                         number of batch_size (per working thread). The
     *                         default value is ''.
     *                     <li>{@link Options#NUM_TASKS_PER_RANK
     *                         NUM_TASKS_PER_RANK}: Optional: number of tasks
     *                         for reading file per rank. Default will be
     *                         external_file_reader_num_tasks
     *                     <li>{@link Options#POLL_INTERVAL POLL_INTERVAL}: If
     *                         {@link Options#TRUE TRUE}, the number of seconds
     *                         between attempts to load external files into the
     *                         table.  If zero, polling will be continuous as
     *                         long as data is found.  If no data is found, the
     *                         interval will steadily increase to a maximum of
     *                         60 seconds.
     *                     <li>{@link Options#PRIMARY_KEYS PRIMARY_KEYS}:
     *                         Optional: comma separated list of column names,
     *                         to set as primary keys, when not specified in
     *                         the type. The default value is ''.
     *                     <li>{@link Options#SCHEMA_REGISTRY_SCHEMA_ID
     *                         SCHEMA_REGISTRY_SCHEMA_ID}
     *                     <li>{@link Options#SCHEMA_REGISTRY_SCHEMA_NAME
     *                         SCHEMA_REGISTRY_SCHEMA_NAME}
     *                     <li>{@link Options#SCHEMA_REGISTRY_SCHEMA_VERSION
     *                         SCHEMA_REGISTRY_SCHEMA_VERSION}
     *                     <li>{@link Options#SHARD_KEYS SHARD_KEYS}: Optional:
     *                         comma separated list of column names, to set as
     *                         primary keys, when not specified in the type.
     *                         The default value is ''.
     *                     <li>{@link Options#SKIP_LINES SKIP_LINES}: Skip
     *                         number of lines from begining of file.
     *                     <li>{@link Options#SUBSCRIBE SUBSCRIBE}:
     *                         Continuously poll the data source to check for
     *                         new data and load it into the table.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#TABLE_INSERT_MODE
     *                         TABLE_INSERT_MODE}: Optional: table_insert_mode.
     *                         When inserting records from multiple files: if
     *                         table_per_file then insert from each file into a
     *                         new table. Currently supported only for
     *                         shapefiles.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#SINGLE SINGLE}
     *                             <li>{@link Options#TABLE_PER_FILE
     *                                 TABLE_PER_FILE}
     *                         </ul>
     *                         The default value is {@link Options#SINGLE
     *                         SINGLE}.
     *                     <li>{@link Options#TEXT_COMMENT_STRING
     *                         TEXT_COMMENT_STRING}: Specifies the character
     *                         string that should be interpreted as a comment
     *                         line prefix in the source data.  All lines in
     *                         the data starting with the provided string are
     *                         ignored.  For {@link Options#DELIMITED_TEXT
     *                         DELIMITED_TEXT} {@link Options#FILE_TYPE
     *                         FILE_TYPE} only. The default value is '#'.
     *                     <li>{@link Options#TEXT_DELIMITER TEXT_DELIMITER}:
     *                         Specifies the character delimiting field values
     *                         in the source data and field names in the header
     *                         (if present).  For {@link Options#DELIMITED_TEXT
     *                         DELIMITED_TEXT} {@link Options#FILE_TYPE
     *                         FILE_TYPE} only. The default value is ','.
     *                     <li>{@link Options#TEXT_ESCAPE_CHARACTER
     *                         TEXT_ESCAPE_CHARACTER}: Specifies the character
     *                         that is used to escape other characters in the
     *                         source data.  An 'a', 'b', 'f', 'n', 'r', 't',
     *                         or 'v' preceded by an escape character will be
     *                         interpreted as the ASCII bell, backspace, form
     *                         feed, line feed, carriage return, horizontal
     *                         tab, & vertical tab, respectively.  For example,
     *                         the escape character followed by an 'n' will be
     *                         interpreted as a newline within a field value.
     *                         The escape character can also be used to escape
     *                         the quoting character, and will be treated as an
     *                         escape character whether it is within a quoted
     *                         field value or not.  For {@link
     *                         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
     *                         Options#FILE_TYPE FILE_TYPE} only.
     *                     <li>{@link Options#TEXT_HAS_HEADER TEXT_HAS_HEADER}:
     *                         Indicates whether the source data contains a
     *                         header row.  For {@link Options#DELIMITED_TEXT
     *                         DELIMITED_TEXT} {@link Options#FILE_TYPE
     *                         FILE_TYPE} only.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#TRUE TRUE}.
     *                     <li>{@link Options#TEXT_HEADER_PROPERTY_DELIMITER
     *                         TEXT_HEADER_PROPERTY_DELIMITER}: Specifies the
     *                         delimiter for <a
     *                         href="../../../../../../concepts/types/#column-properties"
     *                         target="_top">column properties</a> in the
     *                         header row (if present).  Cannot be set to same
     *                         value as {@link Options#TEXT_DELIMITER
     *                         TEXT_DELIMITER}.  For {@link
     *                         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
     *                         Options#FILE_TYPE FILE_TYPE} only. The default
     *                         value is '|'.
     *                     <li>{@link Options#TEXT_NULL_STRING
     *                         TEXT_NULL_STRING}: Specifies the character
     *                         string that should be interpreted as a null
     *                         value in the source data.  For {@link
     *                         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
     *                         Options#FILE_TYPE FILE_TYPE} only. The default
     *                         value is '\N'.
     *                     <li>{@link Options#TEXT_QUOTE_CHARACTER
     *                         TEXT_QUOTE_CHARACTER}: Specifies the character
     *                         that should be interpreted as a field value
     *                         quoting character in the source data.  The
     *                         character must appear at beginning and end of
     *                         field value to take effect.  Delimiters within
     *                         quoted fields are treated as literals and not
     *                         delimiters.  Within a quoted field, two
     *                         consecutive quote characters will be interpreted
     *                         as a single literal quote character, effectively
     *                         escaping it.  To not have a quote character,
     *                         specify an empty string.  For {@link
     *                         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
     *                         Options#FILE_TYPE FILE_TYPE} only. The default
     *                         value is '"'.
     *                     <li>{@link Options#TEXT_SEARCH_COLUMNS
     *                         TEXT_SEARCH_COLUMNS}: Add 'text_search' property
     *                         to internally inferenced string columns. Comma
     *                         seperated list of column names or '*' for all
     *                         columns. To add text_search property only to
     *                         string columns of minimum size, set also the
     *                         option 'text_search_min_column_length'
     *                     <li>{@link Options#TEXT_SEARCH_MIN_COLUMN_LENGTH
     *                         TEXT_SEARCH_MIN_COLUMN_LENGTH}: Set minimum
     *                         column size. Used only when
     *                         'text_search_columns' has a value.
     *                     <li>{@link Options#TRUNCATE_STRINGS
     *                         TRUNCATE_STRINGS}: If set to {@link Options#TRUE
     *                         TRUE}, truncate string values that are longer
     *                         than the column's type size.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#TRUNCATE_TABLE TRUNCATE_TABLE}:
     *                         If set to {@link Options#TRUE TRUE}, truncates
     *                         the table specified by {@code tableName} prior
     *                         to loading the file(s).
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#TYPE_INFERENCE_MODE
     *                         TYPE_INFERENCE_MODE}: optimize type inference
     *                         for:
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#ACCURACY ACCURACY}: Scans
     *                                 data to get exactly-typed & sized
     *                                 columns for all data scanned.
     *                             <li>{@link Options#SPEED SPEED}: Scans data
     *                                 and picks the widest possible column
     *                                 types so that 'all' values will fit with
     *                                 minimum data scanned
     *                         </ul>
     *                         The default value is {@link Options#ACCURACY
     *                         ACCURACY}.
     *                     <li>{@link Options#UPDATE_ON_EXISTING_PK
     *                         UPDATE_ON_EXISTING_PK}: Specifies the record
     *                         collision policy for inserting into a table with
     *                         a <a
     *                         href="../../../../../../concepts/tables/#primary-keys"
     *                         target="_top">primary key</a>. If set to {@link
     *                         Options#TRUE TRUE}, any existing table record
     *                         with primary key values that match those of a
     *                         record being inserted will be replaced by that
     *                         new record (the new data will be "upserted"). If
     *                         set to {@link Options#FALSE FALSE}, any existing
     *                         table record with primary key values that match
     *                         those of a record being inserted will remain
     *                         unchanged, while the new record will be rejected
     *                         and the error handled as determined by {@link
     *                         Options#IGNORE_EXISTING_PK IGNORE_EXISTING_PK} &
     *                         {@link Options#ERROR_HANDLING ERROR_HANDLING}.
     *                         If the specified table does not have a primary
     *                         key, then this option has no effect.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Upsert new
     *                                 records when primary keys match existing
     *                                 records
     *                             <li>{@link Options#FALSE FALSE}: Reject new
     *                                 records when primary keys match existing
     *                                 records
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                 </ul>
     *                 The default value is an empty {@link Map}.
     */
    public InsertRecordsFromPayloadRequest(String tableName, String dataText, ByteBuffer dataBytes, Map<String, Map<String, String>> modifyColumns, Map<String, String> createTableOptions, Map<String, String> options) {
        this.tableName = (tableName == null) ? "" : tableName;
        this.dataText = (dataText == null) ? "" : dataText;
        this.dataBytes = (dataBytes == null) ? ByteBuffer.wrap( new byte[0] ) : dataBytes;
        this.modifyColumns = (modifyColumns == null) ? new LinkedHashMap<String, Map<String, String>>() : modifyColumns;
        this.createTableOptions = (createTableOptions == null) ? new LinkedHashMap<String, String>() : createTableOptions;
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
    }

    /**
     * Name of the table into which the data will be inserted, in
     * [schema_name.]table_name format, using standard <a
     * href="../../../../../../concepts/tables/#table-name-resolution"
     * target="_top">name resolution rules</a>. If the table does not exist,
     * the table will be created using either an existing {@link
     * CreateTableOptions#TYPE_ID TYPE_ID} or the type inferred from the
     * payload, and the new table name will have to meet standard <a
     * href="../../../../../../concepts/tables/#table-naming-criteria"
     * target="_top">table naming criteria</a>.
     *
     * @return The current value of {@code tableName}.
     */
    public String getTableName() {
        return tableName;
    }

    /**
     * Name of the table into which the data will be inserted, in
     * [schema_name.]table_name format, using standard <a
     * href="../../../../../../concepts/tables/#table-name-resolution"
     * target="_top">name resolution rules</a>. If the table does not exist,
     * the table will be created using either an existing {@link
     * CreateTableOptions#TYPE_ID TYPE_ID} or the type inferred from the
     * payload, and the new table name will have to meet standard <a
     * href="../../../../../../concepts/tables/#table-naming-criteria"
     * target="_top">table naming criteria</a>.
     *
     * @param tableName  The new value for {@code tableName}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public InsertRecordsFromPayloadRequest setTableName(String tableName) {
        this.tableName = (tableName == null) ? "" : tableName;
        return this;
    }

    /**
     * Records formatted as delimited text
     *
     * @return The current value of {@code dataText}.
     */
    public String getDataText() {
        return dataText;
    }

    /**
     * Records formatted as delimited text
     *
     * @param dataText  The new value for {@code dataText}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public InsertRecordsFromPayloadRequest setDataText(String dataText) {
        this.dataText = (dataText == null) ? "" : dataText;
        return this;
    }

    /**
     * Records formatted as binary data
     *
     * @return The current value of {@code dataBytes}.
     */
    public ByteBuffer getDataBytes() {
        return dataBytes;
    }

    /**
     * Records formatted as binary data
     *
     * @param dataBytes  The new value for {@code dataBytes}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public InsertRecordsFromPayloadRequest setDataBytes(ByteBuffer dataBytes) {
        this.dataBytes = (dataBytes == null) ? ByteBuffer.wrap( new byte[0] ) : dataBytes;
        return this;
    }

    /**
     * Not implemented yet. The default value is an empty {@link Map}.
     *
     * @return The current value of {@code modifyColumns}.
     */
    public Map<String, Map<String, String>> getModifyColumns() {
        return modifyColumns;
    }

    /**
     * Not implemented yet. The default value is an empty {@link Map}.
     *
     * @param modifyColumns  The new value for {@code modifyColumns}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public InsertRecordsFromPayloadRequest setModifyColumns(Map<String, Map<String, String>> modifyColumns) {
        this.modifyColumns = (modifyColumns == null) ? new LinkedHashMap<String, Map<String, String>>() : modifyColumns;
        return this;
    }

    /**
     * Options used when creating the target table. Includes type to use. The
     * other options match those in {@link
     * com.gpudb.GPUdb#createTable(CreateTableRequest) GPUdb.createTable}.
     * <ul>
     *     <li>{@link CreateTableOptions#TYPE_ID TYPE_ID}: ID of a currently
     *         registered <a href="../../../../../../concepts/types/"
     *         target="_top">type</a>. The default value is ''.
     *     <li>{@link CreateTableOptions#NO_ERROR_IF_EXISTS
     *         NO_ERROR_IF_EXISTS}: If {@link CreateTableOptions#TRUE TRUE},
     *         prevents an error from occurring if the table already exists and
     *         is of the given type.  If a table with the same ID but a
     *         different type exists, it is still an error.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#IS_REPLICATED IS_REPLICATED}: Affects
     *         the <a href="../../../../../../concepts/tables/#distribution"
     *         target="_top">distribution scheme</a> for the table's data.  If
     *         {@link CreateTableOptions#TRUE TRUE} and the given type has no
     *         explicit <a href="../../../../../../concepts/tables/#shard-key"
     *         target="_top">shard key</a> defined, the table will be <a
     *         href="../../../../../../concepts/tables/#replication"
     *         target="_top">replicated</a>.  If {@link
     *         CreateTableOptions#FALSE FALSE}, the table will be <a
     *         href="../../../../../../concepts/tables/#sharding"
     *         target="_top">sharded</a> according to the shard key specified
     *         in the given {@link CreateTableOptions#TYPE_ID TYPE_ID}, or <a
     *         href="../../../../../../concepts/tables/#random-sharding"
     *         target="_top">randomly sharded</a>, if no shard key is
     *         specified.  Note that a type containing a shard key cannot be
     *         used to create a replicated table.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#FOREIGN_KEYS FOREIGN_KEYS}:
     *         Semicolon-separated list of <a
     *         href="../../../../../../concepts/tables/#foreign-keys"
     *         target="_top">foreign keys</a>, of the format
     *         '(source_column_name [, ...]) references
     *         target_table_name(primary_key_column_name [, ...]) [as
     *         foreign_key_name]'.
     *     <li>{@link CreateTableOptions#FOREIGN_SHARD_KEY FOREIGN_SHARD_KEY}:
     *         Foreign shard key of the format 'source_column references
     *         shard_by_column from target_table(primary_key_column)'.
     *     <li>{@link CreateTableOptions#PARTITION_TYPE PARTITION_TYPE}: <a
     *         href="../../../../../../concepts/tables/#partitioning"
     *         target="_top">Partitioning</a> scheme to use.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#RANGE RANGE}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-range"
     *                 target="_top">range partitioning</a>.
     *             <li>{@link CreateTableOptions#INTERVAL INTERVAL}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-interval"
     *                 target="_top">interval partitioning</a>.
     *             <li>{@link CreateTableOptions#LIST LIST}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-list"
     *                 target="_top">list partitioning</a>.
     *             <li>{@link CreateTableOptions#HASH HASH}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-hash"
     *                 target="_top">hash partitioning</a>.
     *             <li>{@link CreateTableOptions#SERIES SERIES}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-series"
     *                 target="_top">series partitioning</a>.
     *         </ul>
     *     <li>{@link CreateTableOptions#PARTITION_KEYS PARTITION_KEYS}:
     *         Comma-separated list of partition keys, which are the columns or
     *         column expressions by which records will be assigned to
     *         partitions defined by {@link
     *         CreateTableOptions#PARTITION_DEFINITIONS PARTITION_DEFINITIONS}.
     *     <li>{@link CreateTableOptions#PARTITION_DEFINITIONS
     *         PARTITION_DEFINITIONS}: Comma-separated list of partition
     *         definitions, whose format depends on the choice of {@link
     *         CreateTableOptions#PARTITION_TYPE PARTITION_TYPE}.  See <a
     *         href="../../../../../../concepts/tables/#partitioning-by-range"
     *         target="_top">range partitioning</a>, <a
     *         href="../../../../../../concepts/tables/#partitioning-by-interval"
     *         target="_top">interval partitioning</a>, <a
     *         href="../../../../../../concepts/tables/#partitioning-by-list"
     *         target="_top">list partitioning</a>, <a
     *         href="../../../../../../concepts/tables/#partitioning-by-hash"
     *         target="_top">hash partitioning</a>, or <a
     *         href="../../../../../../concepts/tables/#partitioning-by-series"
     *         target="_top">series partitioning</a> for example formats.
     *     <li>{@link CreateTableOptions#IS_AUTOMATIC_PARTITION
     *         IS_AUTOMATIC_PARTITION}: If {@link CreateTableOptions#TRUE
     *         TRUE}, a new partition will be created for values which don't
     *         fall into an existing partition.  Currently only supported for
     *         <a
     *         href="../../../../../../concepts/tables/#partitioning-by-list"
     *         target="_top">list partitions</a>.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#TTL TTL}: Sets the <a
     *         href="../../../../../../concepts/ttl/" target="_top">TTL</a> of
     *         the table specified in {@link #getTableName() tableName}.
     *     <li>{@link CreateTableOptions#CHUNK_SIZE CHUNK_SIZE}: Indicates the
     *         number of records per chunk to be used for this table.
     *     <li>{@link CreateTableOptions#CHUNK_COLUMN_MAX_MEMORY
     *         CHUNK_COLUMN_MAX_MEMORY}: Indicates the target maximum data size
     *         for each column in a chunk to be used for this table.
     *     <li>{@link CreateTableOptions#CHUNK_MAX_MEMORY CHUNK_MAX_MEMORY}:
     *         Indicates the target maximum data size for all columns in a
     *         chunk to be used for this table.
     *     <li>{@link CreateTableOptions#IS_RESULT_TABLE IS_RESULT_TABLE}:
     *         Indicates whether the table is a <a
     *         href="../../../../../../concepts/tables_memory_only/"
     *         target="_top">memory-only table</a>. A result table cannot
     *         contain columns with text_search <a
     *         href="../../../../../../concepts/types/#data-handling"
     *         target="_top">data-handling</a>, and it will not be retained if
     *         the server is restarted.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#STRATEGY_DEFINITION
     *         STRATEGY_DEFINITION}: The <a
     *         href="../../../../../../rm/concepts/#tier-strategies"
     *         target="_top">tier strategy</a> for the table and its columns.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @return The current value of {@code createTableOptions}.
     */
    public Map<String, String> getCreateTableOptions() {
        return createTableOptions;
    }

    /**
     * Options used when creating the target table. Includes type to use. The
     * other options match those in {@link
     * com.gpudb.GPUdb#createTable(CreateTableRequest) GPUdb.createTable}.
     * <ul>
     *     <li>{@link CreateTableOptions#TYPE_ID TYPE_ID}: ID of a currently
     *         registered <a href="../../../../../../concepts/types/"
     *         target="_top">type</a>. The default value is ''.
     *     <li>{@link CreateTableOptions#NO_ERROR_IF_EXISTS
     *         NO_ERROR_IF_EXISTS}: If {@link CreateTableOptions#TRUE TRUE},
     *         prevents an error from occurring if the table already exists and
     *         is of the given type.  If a table with the same ID but a
     *         different type exists, it is still an error.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#IS_REPLICATED IS_REPLICATED}: Affects
     *         the <a href="../../../../../../concepts/tables/#distribution"
     *         target="_top">distribution scheme</a> for the table's data.  If
     *         {@link CreateTableOptions#TRUE TRUE} and the given type has no
     *         explicit <a href="../../../../../../concepts/tables/#shard-key"
     *         target="_top">shard key</a> defined, the table will be <a
     *         href="../../../../../../concepts/tables/#replication"
     *         target="_top">replicated</a>.  If {@link
     *         CreateTableOptions#FALSE FALSE}, the table will be <a
     *         href="../../../../../../concepts/tables/#sharding"
     *         target="_top">sharded</a> according to the shard key specified
     *         in the given {@link CreateTableOptions#TYPE_ID TYPE_ID}, or <a
     *         href="../../../../../../concepts/tables/#random-sharding"
     *         target="_top">randomly sharded</a>, if no shard key is
     *         specified.  Note that a type containing a shard key cannot be
     *         used to create a replicated table.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#FOREIGN_KEYS FOREIGN_KEYS}:
     *         Semicolon-separated list of <a
     *         href="../../../../../../concepts/tables/#foreign-keys"
     *         target="_top">foreign keys</a>, of the format
     *         '(source_column_name [, ...]) references
     *         target_table_name(primary_key_column_name [, ...]) [as
     *         foreign_key_name]'.
     *     <li>{@link CreateTableOptions#FOREIGN_SHARD_KEY FOREIGN_SHARD_KEY}:
     *         Foreign shard key of the format 'source_column references
     *         shard_by_column from target_table(primary_key_column)'.
     *     <li>{@link CreateTableOptions#PARTITION_TYPE PARTITION_TYPE}: <a
     *         href="../../../../../../concepts/tables/#partitioning"
     *         target="_top">Partitioning</a> scheme to use.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#RANGE RANGE}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-range"
     *                 target="_top">range partitioning</a>.
     *             <li>{@link CreateTableOptions#INTERVAL INTERVAL}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-interval"
     *                 target="_top">interval partitioning</a>.
     *             <li>{@link CreateTableOptions#LIST LIST}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-list"
     *                 target="_top">list partitioning</a>.
     *             <li>{@link CreateTableOptions#HASH HASH}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-hash"
     *                 target="_top">hash partitioning</a>.
     *             <li>{@link CreateTableOptions#SERIES SERIES}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-series"
     *                 target="_top">series partitioning</a>.
     *         </ul>
     *     <li>{@link CreateTableOptions#PARTITION_KEYS PARTITION_KEYS}:
     *         Comma-separated list of partition keys, which are the columns or
     *         column expressions by which records will be assigned to
     *         partitions defined by {@link
     *         CreateTableOptions#PARTITION_DEFINITIONS PARTITION_DEFINITIONS}.
     *     <li>{@link CreateTableOptions#PARTITION_DEFINITIONS
     *         PARTITION_DEFINITIONS}: Comma-separated list of partition
     *         definitions, whose format depends on the choice of {@link
     *         CreateTableOptions#PARTITION_TYPE PARTITION_TYPE}.  See <a
     *         href="../../../../../../concepts/tables/#partitioning-by-range"
     *         target="_top">range partitioning</a>, <a
     *         href="../../../../../../concepts/tables/#partitioning-by-interval"
     *         target="_top">interval partitioning</a>, <a
     *         href="../../../../../../concepts/tables/#partitioning-by-list"
     *         target="_top">list partitioning</a>, <a
     *         href="../../../../../../concepts/tables/#partitioning-by-hash"
     *         target="_top">hash partitioning</a>, or <a
     *         href="../../../../../../concepts/tables/#partitioning-by-series"
     *         target="_top">series partitioning</a> for example formats.
     *     <li>{@link CreateTableOptions#IS_AUTOMATIC_PARTITION
     *         IS_AUTOMATIC_PARTITION}: If {@link CreateTableOptions#TRUE
     *         TRUE}, a new partition will be created for values which don't
     *         fall into an existing partition.  Currently only supported for
     *         <a
     *         href="../../../../../../concepts/tables/#partitioning-by-list"
     *         target="_top">list partitions</a>.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#TTL TTL}: Sets the <a
     *         href="../../../../../../concepts/ttl/" target="_top">TTL</a> of
     *         the table specified in {@link #getTableName() tableName}.
     *     <li>{@link CreateTableOptions#CHUNK_SIZE CHUNK_SIZE}: Indicates the
     *         number of records per chunk to be used for this table.
     *     <li>{@link CreateTableOptions#CHUNK_COLUMN_MAX_MEMORY
     *         CHUNK_COLUMN_MAX_MEMORY}: Indicates the target maximum data size
     *         for each column in a chunk to be used for this table.
     *     <li>{@link CreateTableOptions#CHUNK_MAX_MEMORY CHUNK_MAX_MEMORY}:
     *         Indicates the target maximum data size for all columns in a
     *         chunk to be used for this table.
     *     <li>{@link CreateTableOptions#IS_RESULT_TABLE IS_RESULT_TABLE}:
     *         Indicates whether the table is a <a
     *         href="../../../../../../concepts/tables_memory_only/"
     *         target="_top">memory-only table</a>. A result table cannot
     *         contain columns with text_search <a
     *         href="../../../../../../concepts/types/#data-handling"
     *         target="_top">data-handling</a>, and it will not be retained if
     *         the server is restarted.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#STRATEGY_DEFINITION
     *         STRATEGY_DEFINITION}: The <a
     *         href="../../../../../../rm/concepts/#tier-strategies"
     *         target="_top">tier strategy</a> for the table and its columns.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @param createTableOptions  The new value for {@code createTableOptions}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public InsertRecordsFromPayloadRequest setCreateTableOptions(Map<String, String> createTableOptions) {
        this.createTableOptions = (createTableOptions == null) ? new LinkedHashMap<String, String>() : createTableOptions;
        return this;
    }

    /**
     * Optional parameters.
     * <ul>
     *     <li>{@link Options#AVRO_HEADER_BYTES AVRO_HEADER_BYTES}: Optional
     *         number of bytes to skip when reading an avro record.
     *     <li>{@link Options#AVRO_NUM_RECORDS AVRO_NUM_RECORDS}: Optional
     *         number of avro records, if data includes only records.
     *     <li>{@link Options#AVRO_SCHEMA AVRO_SCHEMA}: Optional string
     *         representing avro schema, for insert records in avro format,
     *         that does not include is schema.
     *     <li>{@link Options#AVRO_SCHEMALESS AVRO_SCHEMALESS}: When user
     *         provides 'avro_schema', avro data is assumed to be schemaless,
     *         unless specified. Default is 'true' when given avro_schema.
     *         Igonred when avro_schema is not given.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *     <li>{@link Options#BAD_RECORD_TABLE_NAME BAD_RECORD_TABLE_NAME}:
     *         Optional name of a table to which records that were rejected are
     *         written.  The bad-record-table has the following columns:
     *         line_number (long), line_rejected (string), error_message
     *         (string).
     *     <li>{@link Options#BAD_RECORD_TABLE_LIMIT BAD_RECORD_TABLE_LIMIT}: A
     *         positive integer indicating the maximum number of records that
     *         can be  written to the bad-record-table.   Default value is
     *         10000
     *     <li>{@link Options#BAD_RECORD_TABLE_LIMIT_PER_INPUT
     *         BAD_RECORD_TABLE_LIMIT_PER_INPUT}: For subscriptions: A positive
     *         integer indicating the maximum number of records that can be
     *         written to the bad-record-table per file/payload. Default value
     *         will be 'bad_record_table_limit' and total size of the table per
     *         rank is limited to 'bad_record_table_limit'
     *     <li>{@link Options#BATCH_SIZE BATCH_SIZE}: Internal tuning
     *         parameter--number of records per batch when inserting data.
     *     <li>{@link Options#COLUMN_FORMATS COLUMN_FORMATS}: For each target
     *         column specified, applies the column-property-bound format to
     *         the source data loaded into that column.  Each column format
     *         will contain a mapping of one or more of its column properties
     *         to an appropriate format for each property.  Currently supported
     *         column properties include date, time, & datetime. The parameter
     *         value must be formatted as a JSON string of maps of column names
     *         to maps of column properties to their corresponding column
     *         formats, e.g., '{ "order_date" : { "date" : "%Y.%m.%d" },
     *         "order_time" : { "time" : "%H:%M:%S" } }'.  See {@link
     *         Options#DEFAULT_COLUMN_FORMATS DEFAULT_COLUMN_FORMATS} for valid
     *         format syntax.
     *     <li>{@link Options#COLUMNS_TO_LOAD COLUMNS_TO_LOAD}: Specifies a
     *         comma-delimited list of columns from the source data to load.
     *         If more than one file is being loaded, this list applies to all
     *         files.  Column numbers can be specified discretely or as a
     *         range.  For example, a value of '5,7,1..3' will insert values
     *         from the fifth column in the source data into the first column
     *         in the target table, from the seventh column in the source data
     *         into the second column in the target table, and from the first
     *         through third columns in the source data into the third through
     *         fifth columns in the target table.  If the source data contains
     *         a header, column names matching the file header names may be
     *         provided instead of column numbers.  If the target table doesn't
     *         exist, the table will be created with the columns in this order.
     *         If the target table does exist with columns in a different order
     *         than the source data, this list can be used to match the order
     *         of the target table.  For example, a value of 'C, B, A' will
     *         create a three column table with column C, followed by column B,
     *         followed by column A; or will insert those fields in that order
     *         into a table created with columns in that order.  If the target
     *         table exists, the column names must match the source data field
     *         names for a name-mapping to be successful.  Mutually exclusive
     *         with {@link Options#COLUMNS_TO_SKIP COLUMNS_TO_SKIP}.
     *     <li>{@link Options#COLUMNS_TO_SKIP COLUMNS_TO_SKIP}: Specifies a
     *         comma-delimited list of columns from the source data to skip.
     *         Mutually exclusive with {@link Options#COLUMNS_TO_LOAD
     *         COLUMNS_TO_LOAD}.
     *     <li>{@link Options#COMPRESSION_TYPE COMPRESSION_TYPE}: Optional:
     *         payload compression type.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#NONE NONE}: Uncompressed
     *             <li>{@link Options#AUTO AUTO}: Default. Auto detect
     *                 compression type
     *             <li>{@link Options#GZIP GZIP}: gzip file compression.
     *             <li>{@link Options#BZIP2 BZIP2}: bzip2 file compression.
     *         </ul>
     *         The default value is {@link Options#AUTO AUTO}.
     *     <li>{@link Options#DEFAULT_COLUMN_FORMATS DEFAULT_COLUMN_FORMATS}:
     *         Specifies the default format to be applied to source data loaded
     *         into columns with the corresponding column property.  Currently
     *         supported column properties include date, time, & datetime.
     *         This default column-property-bound format can be overridden by
     *         specifying a column property & format for a given target column
     *         in {@link Options#COLUMN_FORMATS COLUMN_FORMATS}. For each
     *         specified annotation, the format will apply to all columns with
     *         that annotation unless a custom {@link Options#COLUMN_FORMATS
     *         COLUMN_FORMATS} for that annotation is specified.  The parameter
     *         value must be formatted as a JSON string that is a map of column
     *         properties to their respective column formats, e.g., '{ "date" :
     *         "%Y.%m.%d", "time" : "%H:%M:%S" }'.  Column formats are
     *         specified as a string of control characters and plain text. The
     *         supported control characters are 'Y', 'm', 'd', 'H', 'M', 'S',
     *         and 's', which follow the Linux 'strptime()' specification, as
     *         well as 's', which specifies seconds and fractional seconds
     *         (though the fractional component will be truncated past
     *         milliseconds).  Formats for the 'date' annotation must include
     *         the 'Y', 'm', and 'd' control characters. Formats for the 'time'
     *         annotation must include the 'H', 'M', and either 'S' or 's' (but
     *         not both) control characters. Formats for the 'datetime'
     *         annotation meet both the 'date' and 'time' control character
     *         requirements. For example, '{"datetime" : "%m/%d/%Y %H:%M:%S" }'
     *         would be used to interpret text as "05/04/2000 12:12:11"
     *     <li>{@link Options#ERROR_HANDLING ERROR_HANDLING}: Specifies how
     *         errors should be handled upon insertion.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#PERMISSIVE PERMISSIVE}: Records with
     *                 missing columns are populated with nulls if possible;
     *                 otherwise, the malformed records are skipped.
     *             <li>{@link Options#IGNORE_BAD_RECORDS IGNORE_BAD_RECORDS}:
     *                 Malformed records are skipped.
     *             <li>{@link Options#ABORT ABORT}: Stops current insertion and
     *                 aborts entire operation when an error is encountered.
     *                 Primary key collisions are considered abortable errors
     *                 in this mode.
     *         </ul>
     *         The default value is {@link Options#ABORT ABORT}.
     *     <li>{@link Options#FILE_TYPE FILE_TYPE}: Specifies the type of the
     *         file(s) whose records will be inserted.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#AVRO AVRO}: Avro file format
     *             <li>{@link Options#DELIMITED_TEXT DELIMITED_TEXT}: Delimited
     *                 text file format; e.g., CSV, TSV, PSV, etc.
     *             <li>{@link Options#GDB GDB}: Esri/GDB file format
     *             <li>{@link Options#JSON JSON}: Json file format
     *             <li>{@link Options#PARQUET PARQUET}: Apache Parquet file
     *                 format
     *             <li>{@link Options#SHAPEFILE SHAPEFILE}: ShapeFile file
     *                 format
     *         </ul>
     *         The default value is {@link Options#DELIMITED_TEXT
     *         DELIMITED_TEXT}.
     *     <li>{@link Options#FLATTEN_COLUMNS FLATTEN_COLUMNS}: Specifies how
     *         to handle nested columns.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Break up nested columns to
     *                 multiple columns
     *             <li>{@link Options#FALSE FALSE}: Treat nested columns as
     *                 json columns instead of flattening
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#GDAL_CONFIGURATION_OPTIONS
     *         GDAL_CONFIGURATION_OPTIONS}: Comma separated list of gdal conf
     *         options, for the specific requets: key=value. The default value
     *         is ''.
     *     <li>{@link Options#IGNORE_EXISTING_PK IGNORE_EXISTING_PK}: Specifies
     *         the record collision error-suppression policy for inserting into
     *         a table with a <a
     *         href="../../../../../../concepts/tables/#primary-keys"
     *         target="_top">primary key</a>, only used when not in upsert mode
     *         (upsert mode is disabled when {@link
     *         Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK} is {@link
     *         Options#FALSE FALSE}).  If set to {@link Options#TRUE TRUE}, any
     *         record being inserted that is rejected for having primary key
     *         values that match those of an existing table record will be
     *         ignored with no error generated.  If {@link Options#FALSE
     *         FALSE}, the rejection of any record for having primary key
     *         values matching an existing record will result in an error being
     *         reported, as determined by {@link Options#ERROR_HANDLING
     *         ERROR_HANDLING}.  If the specified table does not have a primary
     *         key or if upsert mode is in effect ({@link
     *         Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK} is {@link
     *         Options#TRUE TRUE}), then this option has no effect.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Ignore new records whose
     *                 primary key values collide with those of existing
     *                 records
     *             <li>{@link Options#FALSE FALSE}: Treat as errors any new
     *                 records whose primary key values collide with those of
     *                 existing records
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#INGESTION_MODE INGESTION_MODE}: Whether to do a
     *         full load, dry run, or perform a type inference on the source
     *         data.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#FULL FULL}: Run a type inference on the
     *                 source data (if needed) and ingest
     *             <li>{@link Options#DRY_RUN DRY_RUN}: Does not load data, but
     *                 walks through the source data and determines the number
     *                 of valid records, taking into account the current mode
     *                 of {@link Options#ERROR_HANDLING ERROR_HANDLING}.
     *             <li>{@link Options#TYPE_INFERENCE_ONLY TYPE_INFERENCE_ONLY}:
     *                 Infer the type of the source data and return, without
     *                 ingesting any data.  The inferred type is returned in
     *                 the response.
     *         </ul>
     *         The default value is {@link Options#FULL FULL}.
     *     <li>{@link Options#LAYER LAYER}: Optional: geo files layer(s)
     *         name(s): comma separated. The default value is ''.
     *     <li>{@link Options#LOADING_MODE LOADING_MODE}: Scheme for
     *         distributing the extraction and loading of data from the source
     *         data file(s). This option applies only when loading files that
     *         are local to the database.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#HEAD HEAD}: The head node loads all data.
     *                 All files must be available to the head node.
     *             <li>{@link Options#DISTRIBUTED_SHARED DISTRIBUTED_SHARED}:
     *                 The head node coordinates loading data by worker
     *                 processes across all nodes from shared files available
     *                 to all workers.  NOTE:  Instead of existing on a shared
     *                 source, the files can be duplicated on a source local to
     *                 each host to improve performance, though the files must
     *                 appear as the same data set from the perspective of all
     *                 hosts performing the load.
     *             <li>{@link Options#DISTRIBUTED_LOCAL DISTRIBUTED_LOCAL}: A
     *                 single worker process on each node loads all files that
     *                 are available to it. This option works best when each
     *                 worker loads files from its own file system, to maximize
     *                 performance. In order to avoid data duplication, either
     *                 each worker performing the load needs to have visibility
     *                 to a set of files unique to it (no file is visible to
     *                 more than one node) or the target table needs to have a
     *                 primary key (which will allow the worker to
     *                 automatically deduplicate data).  NOTE:  If the target
     *                 table doesn't exist, the table structure will be
     *                 determined by the head node. If the head node has no
     *                 files local to it, it will be unable to determine the
     *                 structure and the request will fail.  If the head node
     *                 is configured to have no worker processes, no data
     *                 strictly accessible to the head node will be loaded.
     *         </ul>
     *         The default value is {@link Options#HEAD HEAD}.
     *     <li>{@link Options#LOCAL_TIME_OFFSET LOCAL_TIME_OFFSET}: For Avro
     *         local timestamp columns
     *     <li>{@link Options#MAX_RECORDS_TO_LOAD MAX_RECORDS_TO_LOAD}: Limit
     *         the number of records to load in this request: If this number is
     *         larger than a batch_size, then the number of records loaded will
     *         be limited to the next whole number of batch_size (per working
     *         thread). The default value is ''.
     *     <li>{@link Options#NUM_TASKS_PER_RANK NUM_TASKS_PER_RANK}: Optional:
     *         number of tasks for reading file per rank. Default will be
     *         external_file_reader_num_tasks
     *     <li>{@link Options#POLL_INTERVAL POLL_INTERVAL}: If {@link
     *         Options#TRUE TRUE}, the number of seconds between attempts to
     *         load external files into the table.  If zero, polling will be
     *         continuous as long as data is found.  If no data is found, the
     *         interval will steadily increase to a maximum of 60 seconds.
     *     <li>{@link Options#PRIMARY_KEYS PRIMARY_KEYS}: Optional: comma
     *         separated list of column names, to set as primary keys, when not
     *         specified in the type. The default value is ''.
     *     <li>{@link Options#SCHEMA_REGISTRY_SCHEMA_ID
     *         SCHEMA_REGISTRY_SCHEMA_ID}
     *     <li>{@link Options#SCHEMA_REGISTRY_SCHEMA_NAME
     *         SCHEMA_REGISTRY_SCHEMA_NAME}
     *     <li>{@link Options#SCHEMA_REGISTRY_SCHEMA_VERSION
     *         SCHEMA_REGISTRY_SCHEMA_VERSION}
     *     <li>{@link Options#SHARD_KEYS SHARD_KEYS}: Optional: comma separated
     *         list of column names, to set as primary keys, when not specified
     *         in the type. The default value is ''.
     *     <li>{@link Options#SKIP_LINES SKIP_LINES}: Skip number of lines from
     *         begining of file.
     *     <li>{@link Options#SUBSCRIBE SUBSCRIBE}: Continuously poll the data
     *         source to check for new data and load it into the table.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TABLE_INSERT_MODE TABLE_INSERT_MODE}: Optional:
     *         table_insert_mode. When inserting records from multiple files:
     *         if table_per_file then insert from each file into a new table.
     *         Currently supported only for shapefiles.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#SINGLE SINGLE}
     *             <li>{@link Options#TABLE_PER_FILE TABLE_PER_FILE}
     *         </ul>
     *         The default value is {@link Options#SINGLE SINGLE}.
     *     <li>{@link Options#TEXT_COMMENT_STRING TEXT_COMMENT_STRING}:
     *         Specifies the character string that should be interpreted as a
     *         comment line prefix in the source data.  All lines in the data
     *         starting with the provided string are ignored.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is '#'.
     *     <li>{@link Options#TEXT_DELIMITER TEXT_DELIMITER}: Specifies the
     *         character delimiting field values in the source data and field
     *         names in the header (if present).  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is ','.
     *     <li>{@link Options#TEXT_ESCAPE_CHARACTER TEXT_ESCAPE_CHARACTER}:
     *         Specifies the character that is used to escape other characters
     *         in the source data.  An 'a', 'b', 'f', 'n', 'r', 't', or 'v'
     *         preceded by an escape character will be interpreted as the ASCII
     *         bell, backspace, form feed, line feed, carriage return,
     *         horizontal tab, & vertical tab, respectively.  For example, the
     *         escape character followed by an 'n' will be interpreted as a
     *         newline within a field value.  The escape character can also be
     *         used to escape the quoting character, and will be treated as an
     *         escape character whether it is within a quoted field value or
     *         not.  For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
     *         Options#FILE_TYPE FILE_TYPE} only.
     *     <li>{@link Options#TEXT_HAS_HEADER TEXT_HAS_HEADER}: Indicates
     *         whether the source data contains a header row.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#TEXT_HEADER_PROPERTY_DELIMITER
     *         TEXT_HEADER_PROPERTY_DELIMITER}: Specifies the delimiter for <a
     *         href="../../../../../../concepts/types/#column-properties"
     *         target="_top">column properties</a> in the header row (if
     *         present).  Cannot be set to same value as {@link
     *         Options#TEXT_DELIMITER TEXT_DELIMITER}.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is '|'.
     *     <li>{@link Options#TEXT_NULL_STRING TEXT_NULL_STRING}: Specifies the
     *         character string that should be interpreted as a null value in
     *         the source data.  For {@link Options#DELIMITED_TEXT
     *         DELIMITED_TEXT} {@link Options#FILE_TYPE FILE_TYPE} only. The
     *         default value is '\N'.
     *     <li>{@link Options#TEXT_QUOTE_CHARACTER TEXT_QUOTE_CHARACTER}:
     *         Specifies the character that should be interpreted as a field
     *         value quoting character in the source data.  The character must
     *         appear at beginning and end of field value to take effect.
     *         Delimiters within quoted fields are treated as literals and not
     *         delimiters.  Within a quoted field, two consecutive quote
     *         characters will be interpreted as a single literal quote
     *         character, effectively escaping it.  To not have a quote
     *         character, specify an empty string.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is '"'.
     *     <li>{@link Options#TEXT_SEARCH_COLUMNS TEXT_SEARCH_COLUMNS}: Add
     *         'text_search' property to internally inferenced string columns.
     *         Comma seperated list of column names or '*' for all columns. To
     *         add text_search property only to string columns of minimum size,
     *         set also the option 'text_search_min_column_length'
     *     <li>{@link Options#TEXT_SEARCH_MIN_COLUMN_LENGTH
     *         TEXT_SEARCH_MIN_COLUMN_LENGTH}: Set minimum column size. Used
     *         only when 'text_search_columns' has a value.
     *     <li>{@link Options#TRUNCATE_STRINGS TRUNCATE_STRINGS}: If set to
     *         {@link Options#TRUE TRUE}, truncate string values that are
     *         longer than the column's type size.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TRUNCATE_TABLE TRUNCATE_TABLE}: If set to {@link
     *         Options#TRUE TRUE}, truncates the table specified by {@link
     *         #getTableName() tableName} prior to loading the file(s).
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TYPE_INFERENCE_MODE TYPE_INFERENCE_MODE}:
     *         optimize type inference for:
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#ACCURACY ACCURACY}: Scans data to get
     *                 exactly-typed & sized columns for all data scanned.
     *             <li>{@link Options#SPEED SPEED}: Scans data and picks the
     *                 widest possible column types so that 'all' values will
     *                 fit with minimum data scanned
     *         </ul>
     *         The default value is {@link Options#ACCURACY ACCURACY}.
     *     <li>{@link Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK}:
     *         Specifies the record collision policy for inserting into a table
     *         with a <a href="../../../../../../concepts/tables/#primary-keys"
     *         target="_top">primary key</a>. If set to {@link Options#TRUE
     *         TRUE}, any existing table record with primary key values that
     *         match those of a record being inserted will be replaced by that
     *         new record (the new data will be "upserted"). If set to {@link
     *         Options#FALSE FALSE}, any existing table record with primary key
     *         values that match those of a record being inserted will remain
     *         unchanged, while the new record will be rejected and the error
     *         handled as determined by {@link Options#IGNORE_EXISTING_PK
     *         IGNORE_EXISTING_PK} & {@link Options#ERROR_HANDLING
     *         ERROR_HANDLING}.  If the specified table does not have a primary
     *         key, then this option has no effect.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Upsert new records when
     *                 primary keys match existing records
     *             <li>{@link Options#FALSE FALSE}: Reject new records when
     *                 primary keys match existing records
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @return The current value of {@code options}.
     */
    public Map<String, String> getOptions() {
        return options;
    }

    /**
     * Optional parameters.
     * <ul>
     *     <li>{@link Options#AVRO_HEADER_BYTES AVRO_HEADER_BYTES}: Optional
     *         number of bytes to skip when reading an avro record.
     *     <li>{@link Options#AVRO_NUM_RECORDS AVRO_NUM_RECORDS}: Optional
     *         number of avro records, if data includes only records.
     *     <li>{@link Options#AVRO_SCHEMA AVRO_SCHEMA}: Optional string
     *         representing avro schema, for insert records in avro format,
     *         that does not include is schema.
     *     <li>{@link Options#AVRO_SCHEMALESS AVRO_SCHEMALESS}: When user
     *         provides 'avro_schema', avro data is assumed to be schemaless,
     *         unless specified. Default is 'true' when given avro_schema.
     *         Igonred when avro_schema is not given.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *     <li>{@link Options#BAD_RECORD_TABLE_NAME BAD_RECORD_TABLE_NAME}:
     *         Optional name of a table to which records that were rejected are
     *         written.  The bad-record-table has the following columns:
     *         line_number (long), line_rejected (string), error_message
     *         (string).
     *     <li>{@link Options#BAD_RECORD_TABLE_LIMIT BAD_RECORD_TABLE_LIMIT}: A
     *         positive integer indicating the maximum number of records that
     *         can be  written to the bad-record-table.   Default value is
     *         10000
     *     <li>{@link Options#BAD_RECORD_TABLE_LIMIT_PER_INPUT
     *         BAD_RECORD_TABLE_LIMIT_PER_INPUT}: For subscriptions: A positive
     *         integer indicating the maximum number of records that can be
     *         written to the bad-record-table per file/payload. Default value
     *         will be 'bad_record_table_limit' and total size of the table per
     *         rank is limited to 'bad_record_table_limit'
     *     <li>{@link Options#BATCH_SIZE BATCH_SIZE}: Internal tuning
     *         parameter--number of records per batch when inserting data.
     *     <li>{@link Options#COLUMN_FORMATS COLUMN_FORMATS}: For each target
     *         column specified, applies the column-property-bound format to
     *         the source data loaded into that column.  Each column format
     *         will contain a mapping of one or more of its column properties
     *         to an appropriate format for each property.  Currently supported
     *         column properties include date, time, & datetime. The parameter
     *         value must be formatted as a JSON string of maps of column names
     *         to maps of column properties to their corresponding column
     *         formats, e.g., '{ "order_date" : { "date" : "%Y.%m.%d" },
     *         "order_time" : { "time" : "%H:%M:%S" } }'.  See {@link
     *         Options#DEFAULT_COLUMN_FORMATS DEFAULT_COLUMN_FORMATS} for valid
     *         format syntax.
     *     <li>{@link Options#COLUMNS_TO_LOAD COLUMNS_TO_LOAD}: Specifies a
     *         comma-delimited list of columns from the source data to load.
     *         If more than one file is being loaded, this list applies to all
     *         files.  Column numbers can be specified discretely or as a
     *         range.  For example, a value of '5,7,1..3' will insert values
     *         from the fifth column in the source data into the first column
     *         in the target table, from the seventh column in the source data
     *         into the second column in the target table, and from the first
     *         through third columns in the source data into the third through
     *         fifth columns in the target table.  If the source data contains
     *         a header, column names matching the file header names may be
     *         provided instead of column numbers.  If the target table doesn't
     *         exist, the table will be created with the columns in this order.
     *         If the target table does exist with columns in a different order
     *         than the source data, this list can be used to match the order
     *         of the target table.  For example, a value of 'C, B, A' will
     *         create a three column table with column C, followed by column B,
     *         followed by column A; or will insert those fields in that order
     *         into a table created with columns in that order.  If the target
     *         table exists, the column names must match the source data field
     *         names for a name-mapping to be successful.  Mutually exclusive
     *         with {@link Options#COLUMNS_TO_SKIP COLUMNS_TO_SKIP}.
     *     <li>{@link Options#COLUMNS_TO_SKIP COLUMNS_TO_SKIP}: Specifies a
     *         comma-delimited list of columns from the source data to skip.
     *         Mutually exclusive with {@link Options#COLUMNS_TO_LOAD
     *         COLUMNS_TO_LOAD}.
     *     <li>{@link Options#COMPRESSION_TYPE COMPRESSION_TYPE}: Optional:
     *         payload compression type.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#NONE NONE}: Uncompressed
     *             <li>{@link Options#AUTO AUTO}: Default. Auto detect
     *                 compression type
     *             <li>{@link Options#GZIP GZIP}: gzip file compression.
     *             <li>{@link Options#BZIP2 BZIP2}: bzip2 file compression.
     *         </ul>
     *         The default value is {@link Options#AUTO AUTO}.
     *     <li>{@link Options#DEFAULT_COLUMN_FORMATS DEFAULT_COLUMN_FORMATS}:
     *         Specifies the default format to be applied to source data loaded
     *         into columns with the corresponding column property.  Currently
     *         supported column properties include date, time, & datetime.
     *         This default column-property-bound format can be overridden by
     *         specifying a column property & format for a given target column
     *         in {@link Options#COLUMN_FORMATS COLUMN_FORMATS}. For each
     *         specified annotation, the format will apply to all columns with
     *         that annotation unless a custom {@link Options#COLUMN_FORMATS
     *         COLUMN_FORMATS} for that annotation is specified.  The parameter
     *         value must be formatted as a JSON string that is a map of column
     *         properties to their respective column formats, e.g., '{ "date" :
     *         "%Y.%m.%d", "time" : "%H:%M:%S" }'.  Column formats are
     *         specified as a string of control characters and plain text. The
     *         supported control characters are 'Y', 'm', 'd', 'H', 'M', 'S',
     *         and 's', which follow the Linux 'strptime()' specification, as
     *         well as 's', which specifies seconds and fractional seconds
     *         (though the fractional component will be truncated past
     *         milliseconds).  Formats for the 'date' annotation must include
     *         the 'Y', 'm', and 'd' control characters. Formats for the 'time'
     *         annotation must include the 'H', 'M', and either 'S' or 's' (but
     *         not both) control characters. Formats for the 'datetime'
     *         annotation meet both the 'date' and 'time' control character
     *         requirements. For example, '{"datetime" : "%m/%d/%Y %H:%M:%S" }'
     *         would be used to interpret text as "05/04/2000 12:12:11"
     *     <li>{@link Options#ERROR_HANDLING ERROR_HANDLING}: Specifies how
     *         errors should be handled upon insertion.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#PERMISSIVE PERMISSIVE}: Records with
     *                 missing columns are populated with nulls if possible;
     *                 otherwise, the malformed records are skipped.
     *             <li>{@link Options#IGNORE_BAD_RECORDS IGNORE_BAD_RECORDS}:
     *                 Malformed records are skipped.
     *             <li>{@link Options#ABORT ABORT}: Stops current insertion and
     *                 aborts entire operation when an error is encountered.
     *                 Primary key collisions are considered abortable errors
     *                 in this mode.
     *         </ul>
     *         The default value is {@link Options#ABORT ABORT}.
     *     <li>{@link Options#FILE_TYPE FILE_TYPE}: Specifies the type of the
     *         file(s) whose records will be inserted.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#AVRO AVRO}: Avro file format
     *             <li>{@link Options#DELIMITED_TEXT DELIMITED_TEXT}: Delimited
     *                 text file format; e.g., CSV, TSV, PSV, etc.
     *             <li>{@link Options#GDB GDB}: Esri/GDB file format
     *             <li>{@link Options#JSON JSON}: Json file format
     *             <li>{@link Options#PARQUET PARQUET}: Apache Parquet file
     *                 format
     *             <li>{@link Options#SHAPEFILE SHAPEFILE}: ShapeFile file
     *                 format
     *         </ul>
     *         The default value is {@link Options#DELIMITED_TEXT
     *         DELIMITED_TEXT}.
     *     <li>{@link Options#FLATTEN_COLUMNS FLATTEN_COLUMNS}: Specifies how
     *         to handle nested columns.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Break up nested columns to
     *                 multiple columns
     *             <li>{@link Options#FALSE FALSE}: Treat nested columns as
     *                 json columns instead of flattening
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#GDAL_CONFIGURATION_OPTIONS
     *         GDAL_CONFIGURATION_OPTIONS}: Comma separated list of gdal conf
     *         options, for the specific requets: key=value. The default value
     *         is ''.
     *     <li>{@link Options#IGNORE_EXISTING_PK IGNORE_EXISTING_PK}: Specifies
     *         the record collision error-suppression policy for inserting into
     *         a table with a <a
     *         href="../../../../../../concepts/tables/#primary-keys"
     *         target="_top">primary key</a>, only used when not in upsert mode
     *         (upsert mode is disabled when {@link
     *         Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK} is {@link
     *         Options#FALSE FALSE}).  If set to {@link Options#TRUE TRUE}, any
     *         record being inserted that is rejected for having primary key
     *         values that match those of an existing table record will be
     *         ignored with no error generated.  If {@link Options#FALSE
     *         FALSE}, the rejection of any record for having primary key
     *         values matching an existing record will result in an error being
     *         reported, as determined by {@link Options#ERROR_HANDLING
     *         ERROR_HANDLING}.  If the specified table does not have a primary
     *         key or if upsert mode is in effect ({@link
     *         Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK} is {@link
     *         Options#TRUE TRUE}), then this option has no effect.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Ignore new records whose
     *                 primary key values collide with those of existing
     *                 records
     *             <li>{@link Options#FALSE FALSE}: Treat as errors any new
     *                 records whose primary key values collide with those of
     *                 existing records
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#INGESTION_MODE INGESTION_MODE}: Whether to do a
     *         full load, dry run, or perform a type inference on the source
     *         data.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#FULL FULL}: Run a type inference on the
     *                 source data (if needed) and ingest
     *             <li>{@link Options#DRY_RUN DRY_RUN}: Does not load data, but
     *                 walks through the source data and determines the number
     *                 of valid records, taking into account the current mode
     *                 of {@link Options#ERROR_HANDLING ERROR_HANDLING}.
     *             <li>{@link Options#TYPE_INFERENCE_ONLY TYPE_INFERENCE_ONLY}:
     *                 Infer the type of the source data and return, without
     *                 ingesting any data.  The inferred type is returned in
     *                 the response.
     *         </ul>
     *         The default value is {@link Options#FULL FULL}.
     *     <li>{@link Options#LAYER LAYER}: Optional: geo files layer(s)
     *         name(s): comma separated. The default value is ''.
     *     <li>{@link Options#LOADING_MODE LOADING_MODE}: Scheme for
     *         distributing the extraction and loading of data from the source
     *         data file(s). This option applies only when loading files that
     *         are local to the database.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#HEAD HEAD}: The head node loads all data.
     *                 All files must be available to the head node.
     *             <li>{@link Options#DISTRIBUTED_SHARED DISTRIBUTED_SHARED}:
     *                 The head node coordinates loading data by worker
     *                 processes across all nodes from shared files available
     *                 to all workers.  NOTE:  Instead of existing on a shared
     *                 source, the files can be duplicated on a source local to
     *                 each host to improve performance, though the files must
     *                 appear as the same data set from the perspective of all
     *                 hosts performing the load.
     *             <li>{@link Options#DISTRIBUTED_LOCAL DISTRIBUTED_LOCAL}: A
     *                 single worker process on each node loads all files that
     *                 are available to it. This option works best when each
     *                 worker loads files from its own file system, to maximize
     *                 performance. In order to avoid data duplication, either
     *                 each worker performing the load needs to have visibility
     *                 to a set of files unique to it (no file is visible to
     *                 more than one node) or the target table needs to have a
     *                 primary key (which will allow the worker to
     *                 automatically deduplicate data).  NOTE:  If the target
     *                 table doesn't exist, the table structure will be
     *                 determined by the head node. If the head node has no
     *                 files local to it, it will be unable to determine the
     *                 structure and the request will fail.  If the head node
     *                 is configured to have no worker processes, no data
     *                 strictly accessible to the head node will be loaded.
     *         </ul>
     *         The default value is {@link Options#HEAD HEAD}.
     *     <li>{@link Options#LOCAL_TIME_OFFSET LOCAL_TIME_OFFSET}: For Avro
     *         local timestamp columns
     *     <li>{@link Options#MAX_RECORDS_TO_LOAD MAX_RECORDS_TO_LOAD}: Limit
     *         the number of records to load in this request: If this number is
     *         larger than a batch_size, then the number of records loaded will
     *         be limited to the next whole number of batch_size (per working
     *         thread). The default value is ''.
     *     <li>{@link Options#NUM_TASKS_PER_RANK NUM_TASKS_PER_RANK}: Optional:
     *         number of tasks for reading file per rank. Default will be
     *         external_file_reader_num_tasks
     *     <li>{@link Options#POLL_INTERVAL POLL_INTERVAL}: If {@link
     *         Options#TRUE TRUE}, the number of seconds between attempts to
     *         load external files into the table.  If zero, polling will be
     *         continuous as long as data is found.  If no data is found, the
     *         interval will steadily increase to a maximum of 60 seconds.
     *     <li>{@link Options#PRIMARY_KEYS PRIMARY_KEYS}: Optional: comma
     *         separated list of column names, to set as primary keys, when not
     *         specified in the type. The default value is ''.
     *     <li>{@link Options#SCHEMA_REGISTRY_SCHEMA_ID
     *         SCHEMA_REGISTRY_SCHEMA_ID}
     *     <li>{@link Options#SCHEMA_REGISTRY_SCHEMA_NAME
     *         SCHEMA_REGISTRY_SCHEMA_NAME}
     *     <li>{@link Options#SCHEMA_REGISTRY_SCHEMA_VERSION
     *         SCHEMA_REGISTRY_SCHEMA_VERSION}
     *     <li>{@link Options#SHARD_KEYS SHARD_KEYS}: Optional: comma separated
     *         list of column names, to set as primary keys, when not specified
     *         in the type. The default value is ''.
     *     <li>{@link Options#SKIP_LINES SKIP_LINES}: Skip number of lines from
     *         begining of file.
     *     <li>{@link Options#SUBSCRIBE SUBSCRIBE}: Continuously poll the data
     *         source to check for new data and load it into the table.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TABLE_INSERT_MODE TABLE_INSERT_MODE}: Optional:
     *         table_insert_mode. When inserting records from multiple files:
     *         if table_per_file then insert from each file into a new table.
     *         Currently supported only for shapefiles.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#SINGLE SINGLE}
     *             <li>{@link Options#TABLE_PER_FILE TABLE_PER_FILE}
     *         </ul>
     *         The default value is {@link Options#SINGLE SINGLE}.
     *     <li>{@link Options#TEXT_COMMENT_STRING TEXT_COMMENT_STRING}:
     *         Specifies the character string that should be interpreted as a
     *         comment line prefix in the source data.  All lines in the data
     *         starting with the provided string are ignored.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is '#'.
     *     <li>{@link Options#TEXT_DELIMITER TEXT_DELIMITER}: Specifies the
     *         character delimiting field values in the source data and field
     *         names in the header (if present).  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is ','.
     *     <li>{@link Options#TEXT_ESCAPE_CHARACTER TEXT_ESCAPE_CHARACTER}:
     *         Specifies the character that is used to escape other characters
     *         in the source data.  An 'a', 'b', 'f', 'n', 'r', 't', or 'v'
     *         preceded by an escape character will be interpreted as the ASCII
     *         bell, backspace, form feed, line feed, carriage return,
     *         horizontal tab, & vertical tab, respectively.  For example, the
     *         escape character followed by an 'n' will be interpreted as a
     *         newline within a field value.  The escape character can also be
     *         used to escape the quoting character, and will be treated as an
     *         escape character whether it is within a quoted field value or
     *         not.  For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
     *         Options#FILE_TYPE FILE_TYPE} only.
     *     <li>{@link Options#TEXT_HAS_HEADER TEXT_HAS_HEADER}: Indicates
     *         whether the source data contains a header row.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#TEXT_HEADER_PROPERTY_DELIMITER
     *         TEXT_HEADER_PROPERTY_DELIMITER}: Specifies the delimiter for <a
     *         href="../../../../../../concepts/types/#column-properties"
     *         target="_top">column properties</a> in the header row (if
     *         present).  Cannot be set to same value as {@link
     *         Options#TEXT_DELIMITER TEXT_DELIMITER}.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is '|'.
     *     <li>{@link Options#TEXT_NULL_STRING TEXT_NULL_STRING}: Specifies the
     *         character string that should be interpreted as a null value in
     *         the source data.  For {@link Options#DELIMITED_TEXT
     *         DELIMITED_TEXT} {@link Options#FILE_TYPE FILE_TYPE} only. The
     *         default value is '\N'.
     *     <li>{@link Options#TEXT_QUOTE_CHARACTER TEXT_QUOTE_CHARACTER}:
     *         Specifies the character that should be interpreted as a field
     *         value quoting character in the source data.  The character must
     *         appear at beginning and end of field value to take effect.
     *         Delimiters within quoted fields are treated as literals and not
     *         delimiters.  Within a quoted field, two consecutive quote
     *         characters will be interpreted as a single literal quote
     *         character, effectively escaping it.  To not have a quote
     *         character, specify an empty string.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is '"'.
     *     <li>{@link Options#TEXT_SEARCH_COLUMNS TEXT_SEARCH_COLUMNS}: Add
     *         'text_search' property to internally inferenced string columns.
     *         Comma seperated list of column names or '*' for all columns. To
     *         add text_search property only to string columns of minimum size,
     *         set also the option 'text_search_min_column_length'
     *     <li>{@link Options#TEXT_SEARCH_MIN_COLUMN_LENGTH
     *         TEXT_SEARCH_MIN_COLUMN_LENGTH}: Set minimum column size. Used
     *         only when 'text_search_columns' has a value.
     *     <li>{@link Options#TRUNCATE_STRINGS TRUNCATE_STRINGS}: If set to
     *         {@link Options#TRUE TRUE}, truncate string values that are
     *         longer than the column's type size.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TRUNCATE_TABLE TRUNCATE_TABLE}: If set to {@link
     *         Options#TRUE TRUE}, truncates the table specified by {@link
     *         #getTableName() tableName} prior to loading the file(s).
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TYPE_INFERENCE_MODE TYPE_INFERENCE_MODE}:
     *         optimize type inference for:
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#ACCURACY ACCURACY}: Scans data to get
     *                 exactly-typed & sized columns for all data scanned.
     *             <li>{@link Options#SPEED SPEED}: Scans data and picks the
     *                 widest possible column types so that 'all' values will
     *                 fit with minimum data scanned
     *         </ul>
     *         The default value is {@link Options#ACCURACY ACCURACY}.
     *     <li>{@link Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK}:
     *         Specifies the record collision policy for inserting into a table
     *         with a <a href="../../../../../../concepts/tables/#primary-keys"
     *         target="_top">primary key</a>. If set to {@link Options#TRUE
     *         TRUE}, any existing table record with primary key values that
     *         match those of a record being inserted will be replaced by that
     *         new record (the new data will be "upserted"). If set to {@link
     *         Options#FALSE FALSE}, any existing table record with primary key
     *         values that match those of a record being inserted will remain
     *         unchanged, while the new record will be rejected and the error
     *         handled as determined by {@link Options#IGNORE_EXISTING_PK
     *         IGNORE_EXISTING_PK} & {@link Options#ERROR_HANDLING
     *         ERROR_HANDLING}.  If the specified table does not have a primary
     *         key, then this option has no effect.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Upsert new records when
     *                 primary keys match existing records
     *             <li>{@link Options#FALSE FALSE}: Reject new records when
     *                 primary keys match existing records
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @param options  The new value for {@code options}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public InsertRecordsFromPayloadRequest setOptions(Map<String, String> options) {
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
        return this;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @return The schema object describing this class.
     */
    @Override
    public Schema getSchema() {
        return schema$;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @param index  the position of the field to get
     *
     * @return value of the field with the given index.
     *
     * @throws IndexOutOfBoundsException
     */
    @Override
    public Object get(int index) {
        switch (index) {
            case 0:
                return this.tableName;

            case 1:
                return this.dataText;

            case 2:
                return this.dataBytes;

            case 3:
                return this.modifyColumns;

            case 4:
                return this.createTableOptions;

            case 5:
                return this.options;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @param index  the position of the field to set
     * @param value  the value to set
     *
     * @throws IndexOutOfBoundsException
     */
    @Override
    @SuppressWarnings("unchecked")
    public void put(int index, Object value) {
        switch (index) {
            case 0:
                this.tableName = (String)value;
                break;

            case 1:
                this.dataText = (String)value;
                break;

            case 2:
                this.dataBytes = (ByteBuffer)value;
                break;

            case 3:
                this.modifyColumns = (Map<String, Map<String, String>>)value;
                break;

            case 4:
                this.createTableOptions = (Map<String, String>)value;
                break;

            case 5:
                this.options = (Map<String, String>)value;
                break;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if( obj == this ) {
            return true;
        }

        if( (obj == null) || (obj.getClass() != this.getClass()) ) {
            return false;
        }

        InsertRecordsFromPayloadRequest that = (InsertRecordsFromPayloadRequest)obj;

        return ( this.tableName.equals( that.tableName )
                 && this.dataText.equals( that.dataText )
                 && this.dataBytes.equals( that.dataBytes )
                 && this.modifyColumns.equals( that.modifyColumns )
                 && this.createTableOptions.equals( that.createTableOptions )
                 && this.options.equals( that.options ) );
    }

    @Override
    public String toString() {
        GenericData gd = GenericData.get();
        StringBuilder builder = new StringBuilder();
        builder.append( "{" );
        builder.append( gd.toString( "tableName" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.tableName ) );
        builder.append( ", " );
        builder.append( gd.toString( "dataText" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.dataText ) );
        builder.append( ", " );
        builder.append( gd.toString( "dataBytes" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.dataBytes ) );
        builder.append( ", " );
        builder.append( gd.toString( "modifyColumns" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.modifyColumns ) );
        builder.append( ", " );
        builder.append( gd.toString( "createTableOptions" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.createTableOptions ) );
        builder.append( ", " );
        builder.append( gd.toString( "options" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.options ) );
        builder.append( "}" );

        return builder.toString();
    }

    @Override
    public int hashCode() {
        int hashCode = 1;
        hashCode = (31 * hashCode) + this.tableName.hashCode();
        hashCode = (31 * hashCode) + this.dataText.hashCode();
        hashCode = (31 * hashCode) + this.dataBytes.hashCode();
        hashCode = (31 * hashCode) + this.modifyColumns.hashCode();
        hashCode = (31 * hashCode) + this.createTableOptions.hashCode();
        hashCode = (31 * hashCode) + this.options.hashCode();
        return hashCode;
    }
}
