/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
package com.gpudb.protocol;

import java.util.LinkedHashMap;
import java.util.Map;
import org.apache.avro.Schema;
import org.apache.avro.SchemaBuilder;
import org.apache.avro.generic.GenericData;
import org.apache.avro.generic.IndexedRecord;

/**
 * A set of parameters for {@link
 * com.gpudb.GPUdb#createTableMonitor(CreateTableMonitorRequest)
 * GPUdb.createTableMonitor}.
 * <p>
 * Creates a monitor that watches for a single table modification event type
 * (insert, update, or delete) on a particular table (identified by {@link
 * #getTableName() tableName}) and forwards event notifications to subscribers
 * via ZMQ. After this call completes, subscribe to the returned {@link
 * com.gpudb.protocol.CreateTableMonitorResponse#getTopicId() topicId} on the
 * ZMQ table monitor port (default 9002). Each time an operation of the given
 * type on the table completes, a multipart message is published for that
 * topic; the first part contains only the topic ID, and each subsequent part
 * contains one binary-encoded Avro object that corresponds to the event and
 * can be decoded using {@link
 * com.gpudb.protocol.CreateTableMonitorResponse#getTypeSchema() typeSchema}.
 * The monitor will continue to run (regardless of whether or not there are any
 * subscribers) until deactivated with {@link
 * com.gpudb.GPUdb#clearTableMonitor(ClearTableMonitorRequest)
 * GPUdb.clearTableMonitor}.
 * <p>
 * For more information on table monitors, see <a
 * href="../../../../../../concepts/table_monitors/" target="_top">Table
 * Monitors</a>.
 */
public class CreateTableMonitorRequest implements IndexedRecord {
    private static final Schema schema$ = SchemaBuilder
            .record("CreateTableMonitorRequest")
            .namespace("com.gpudb")
            .fields()
                .name("tableName").type().stringType().noDefault()
                .name("options").type().map().values().stringType().noDefault()
            .endRecord();

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @return The schema for the class.
     */
    public static Schema getClassSchema() {
        return schema$;
    }

    /**
     * A set of string constants for the {@link CreateTableMonitorRequest}
     * parameter {@link #getOptions() options}.
     * <p>
     * Optional parameters.
     */
    public static final class Options {
        /**
         * Type of modification event on the target table to be monitored by
         * this table monitor.
         * Supported values:
         * <ul>
         *     <li>{@link Options#INSERT INSERT}: Get notifications of new
         *         record insertions. The new row images are forwarded to the
         *         subscribers.
         *     <li>{@link Options#UPDATE UPDATE}: Get notifications of update
         *         operations. The modified row count information is forwarded
         *         to the subscribers.
         *     <li>{@link Options#DELETE DELETE}: Get notifications of delete
         *         operations. The deleted row count information is forwarded
         *         to the subscribers.
         * </ul>
         * The default value is {@link Options#INSERT INSERT}.
         */
        public static final String EVENT = "event";

        /**
         * Get notifications of new record insertions. The new row images are
         * forwarded to the subscribers.
         */
        public static final String INSERT = "insert";

        /**
         * Get notifications of update operations. The modified row count
         * information is forwarded to the subscribers.
         */
        public static final String UPDATE = "update";

        /**
         * Get notifications of delete operations. The deleted row count
         * information is forwarded to the subscribers.
         */
        public static final String DELETE = "delete";

        /**
         * ID to use for this monitor instead of a randomly generated one
         */
        public static final String MONITOR_ID = "monitor_id";

        /**
         * Name of an existing <a href="../../../../../../concepts/data_sinks/"
         * target="_top">data sink</a> to send change data notifications to
         */
        public static final String DATASINK_NAME = "datasink_name";

        /**
         * Destination for the output data in format
         * 'destination_type://path[:port]'. Supported destination types are
         * 'http', 'https' and 'kafka'.
         */
        public static final String DESTINATION = "destination";

        /**
         * Name of the Kafka topic to publish to if {@link Options#DESTINATION
         * DESTINATION} in {@link #getOptions() options} is specified and is a
         * Kafka broker
         */
        public static final String KAFKA_TOPIC_NAME = "kafka_topic_name";

        /**
         * Column on subscribed table that will increase for new records (e.g.,
         * TIMESTAMP).
         */
        public static final String INCREASING_COLUMN = "increasing_column";

        /**
         * Filter expression to limit records for notification
         */
        public static final String EXPRESSION = "expression";

        /**
         * A comma-separated list of tables (optionally with aliases) to
         * include in the join. The monitored table {@link #getTableName()
         * tableName} must be included, representing only the newly inserted
         * rows (deltas) since the last notification. Other tables can be any
         * existing tables or views. Aliases can be used with the 'table_name
         * as alias' syntax.
         */
        public static final String JOIN_TABLE_NAMES = "join_table_names";

        /**
         * A comma-separated list of columns or expressions to include from the
         * joined tables. Column references can use table names or aliases
         * defined in 'join_table_names'. Each column can optionally be aliased
         * using 'as'. The selected columns will also appear in the
         * notification output.
         */
        public static final String JOIN_COLUMN_NAMES = "join_column_names";

        /**
         * Optional filter or join expressions to apply when combining the
         * tables. Expressions are standard SQL-style conditions and can
         * reference any table or alias listed in 'join_table_names'. This
         * corresponds to the WHERE clause of the underlying join, and can
         * include conditions to filter the delta rows.
         */
        public static final String JOIN_EXPRESSIONS = "join_expressions";

        /**
         * Method controlling when the table monitor reports changes to the
         * {@link #getTableName() tableName}.
         * Supported values:
         * <ul>
         *     <li>{@link Options#ON_CHANGE ON_CHANGE}: Report changes as they
         *         occur.
         *     <li>{@link Options#PERIODIC PERIODIC}: Report changes
         *         periodically at rate specified by {@link
         *         Options#REFRESH_PERIOD REFRESH_PERIOD}.
         * </ul>
         * The default value is {@link Options#ON_CHANGE ON_CHANGE}.
         */
        public static final String REFRESH_METHOD = "refresh_method";

        /**
         * Report changes as they occur.
         */
        public static final String ON_CHANGE = "on_change";

        /**
         * Report changes periodically at rate specified by {@link
         * Options#REFRESH_PERIOD REFRESH_PERIOD}.
         */
        public static final String PERIODIC = "periodic";

        /**
         * When {@link Options#REFRESH_METHOD REFRESH_METHOD} is {@link
         * Options#PERIODIC PERIODIC}, specifies the period in seconds at which
         * changes are reported.
         */
        public static final String REFRESH_PERIOD = "refresh_period";

        /**
         * When {@link Options#REFRESH_METHOD REFRESH_METHOD} is {@link
         * Options#PERIODIC PERIODIC}, specifies the first time at which
         * changes are reported.  Value is a datetime string with format
         * 'YYYY-MM-DD HH:MM:SS'.
         */
        public static final String REFRESH_START_TIME = "refresh_start_time";

        private Options() {  }
    }

    private String tableName;
    private Map<String, String> options;

    /**
     * Constructs a CreateTableMonitorRequest object with default parameters.
     */
    public CreateTableMonitorRequest() {
        tableName = "";
        options = new LinkedHashMap<>();
    }

    /**
     * Constructs a CreateTableMonitorRequest object with the specified
     * parameters.
     *
     * @param tableName  Name of the table to monitor, in
     *                   [schema_name.]table_name format, using standard <a
     *                   href="../../../../../../concepts/tables/#table-name-resolution"
     *                   target="_top">name resolution rules</a>.
     * @param options  Optional parameters.
     *                 <ul>
     *                     <li>{@link Options#EVENT EVENT}: Type of
     *                         modification event on the target table to be
     *                         monitored by this table monitor.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#INSERT INSERT}: Get
     *                                 notifications of new record insertions.
     *                                 The new row images are forwarded to the
     *                                 subscribers.
     *                             <li>{@link Options#UPDATE UPDATE}: Get
     *                                 notifications of update operations. The
     *                                 modified row count information is
     *                                 forwarded to the subscribers.
     *                             <li>{@link Options#DELETE DELETE}: Get
     *                                 notifications of delete operations. The
     *                                 deleted row count information is
     *                                 forwarded to the subscribers.
     *                         </ul>
     *                         The default value is {@link Options#INSERT
     *                         INSERT}.
     *                     <li>{@link Options#MONITOR_ID MONITOR_ID}: ID to use
     *                         for this monitor instead of a randomly generated
     *                         one
     *                     <li>{@link Options#DATASINK_NAME DATASINK_NAME}:
     *                         Name of an existing <a
     *                         href="../../../../../../concepts/data_sinks/"
     *                         target="_top">data sink</a> to send change data
     *                         notifications to
     *                     <li>{@link Options#DESTINATION DESTINATION}:
     *                         Destination for the output data in format
     *                         'destination_type://path[:port]'. Supported
     *                         destination types are 'http', 'https' and
     *                         'kafka'.
     *                     <li>{@link Options#KAFKA_TOPIC_NAME
     *                         KAFKA_TOPIC_NAME}: Name of the Kafka topic to
     *                         publish to if {@link Options#DESTINATION
     *                         DESTINATION} in {@code options} is specified and
     *                         is a Kafka broker
     *                     <li>{@link Options#INCREASING_COLUMN
     *                         INCREASING_COLUMN}: Column on subscribed table
     *                         that will increase for new records (e.g.,
     *                         TIMESTAMP).
     *                     <li>{@link Options#EXPRESSION EXPRESSION}: Filter
     *                         expression to limit records for notification
     *                     <li>{@link Options#JOIN_TABLE_NAMES
     *                         JOIN_TABLE_NAMES}: A comma-separated list of
     *                         tables (optionally with aliases) to include in
     *                         the join. The monitored table {@code tableName}
     *                         must be included, representing only the newly
     *                         inserted rows (deltas) since the last
     *                         notification. Other tables can be any existing
     *                         tables or views. Aliases can be used with the
     *                         'table_name as alias' syntax.
     *                     <li>{@link Options#JOIN_COLUMN_NAMES
     *                         JOIN_COLUMN_NAMES}: A comma-separated list of
     *                         columns or expressions to include from the
     *                         joined tables. Column references can use table
     *                         names or aliases defined in 'join_table_names'.
     *                         Each column can optionally be aliased using
     *                         'as'. The selected columns will also appear in
     *                         the notification output.
     *                     <li>{@link Options#JOIN_EXPRESSIONS
     *                         JOIN_EXPRESSIONS}: Optional filter or join
     *                         expressions to apply when combining the tables.
     *                         Expressions are standard SQL-style conditions
     *                         and can reference any table or alias listed in
     *                         'join_table_names'. This corresponds to the
     *                         WHERE clause of the underlying join, and can
     *                         include conditions to filter the delta rows.
     *                     <li>{@link Options#REFRESH_METHOD REFRESH_METHOD}:
     *                         Method controlling when the table monitor
     *                         reports changes to the {@code tableName}.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#ON_CHANGE ON_CHANGE}:
     *                                 Report changes as they occur.
     *                             <li>{@link Options#PERIODIC PERIODIC}:
     *                                 Report changes periodically at rate
     *                                 specified by {@link
     *                                 Options#REFRESH_PERIOD REFRESH_PERIOD}.
     *                         </ul>
     *                         The default value is {@link Options#ON_CHANGE
     *                         ON_CHANGE}.
     *                     <li>{@link Options#REFRESH_PERIOD REFRESH_PERIOD}:
     *                         When {@link Options#REFRESH_METHOD
     *                         REFRESH_METHOD} is {@link Options#PERIODIC
     *                         PERIODIC}, specifies the period in seconds at
     *                         which changes are reported.
     *                     <li>{@link Options#REFRESH_START_TIME
     *                         REFRESH_START_TIME}: When {@link
     *                         Options#REFRESH_METHOD REFRESH_METHOD} is {@link
     *                         Options#PERIODIC PERIODIC}, specifies the first
     *                         time at which changes are reported.  Value is a
     *                         datetime string with format 'YYYY-MM-DD
     *                         HH:MM:SS'.
     *                 </ul>
     *                 The default value is an empty {@link Map}.
     */
    public CreateTableMonitorRequest(String tableName, Map<String, String> options) {
        this.tableName = (tableName == null) ? "" : tableName;
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
    }

    /**
     * Name of the table to monitor, in [schema_name.]table_name format, using
     * standard <a
     * href="../../../../../../concepts/tables/#table-name-resolution"
     * target="_top">name resolution rules</a>.
     *
     * @return The current value of {@code tableName}.
     */
    public String getTableName() {
        return tableName;
    }

    /**
     * Name of the table to monitor, in [schema_name.]table_name format, using
     * standard <a
     * href="../../../../../../concepts/tables/#table-name-resolution"
     * target="_top">name resolution rules</a>.
     *
     * @param tableName  The new value for {@code tableName}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public CreateTableMonitorRequest setTableName(String tableName) {
        this.tableName = (tableName == null) ? "" : tableName;
        return this;
    }

    /**
     * Optional parameters.
     * <ul>
     *     <li>{@link Options#EVENT EVENT}: Type of modification event on the
     *         target table to be monitored by this table monitor.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#INSERT INSERT}: Get notifications of new
     *                 record insertions. The new row images are forwarded to
     *                 the subscribers.
     *             <li>{@link Options#UPDATE UPDATE}: Get notifications of
     *                 update operations. The modified row count information is
     *                 forwarded to the subscribers.
     *             <li>{@link Options#DELETE DELETE}: Get notifications of
     *                 delete operations. The deleted row count information is
     *                 forwarded to the subscribers.
     *         </ul>
     *         The default value is {@link Options#INSERT INSERT}.
     *     <li>{@link Options#MONITOR_ID MONITOR_ID}: ID to use for this
     *         monitor instead of a randomly generated one
     *     <li>{@link Options#DATASINK_NAME DATASINK_NAME}: Name of an existing
     *         <a href="../../../../../../concepts/data_sinks/"
     *         target="_top">data sink</a> to send change data notifications to
     *     <li>{@link Options#DESTINATION DESTINATION}: Destination for the
     *         output data in format 'destination_type://path[:port]'.
     *         Supported destination types are 'http', 'https' and 'kafka'.
     *     <li>{@link Options#KAFKA_TOPIC_NAME KAFKA_TOPIC_NAME}: Name of the
     *         Kafka topic to publish to if {@link Options#DESTINATION
     *         DESTINATION} in {@link #getOptions() options} is specified and
     *         is a Kafka broker
     *     <li>{@link Options#INCREASING_COLUMN INCREASING_COLUMN}: Column on
     *         subscribed table that will increase for new records (e.g.,
     *         TIMESTAMP).
     *     <li>{@link Options#EXPRESSION EXPRESSION}: Filter expression to
     *         limit records for notification
     *     <li>{@link Options#JOIN_TABLE_NAMES JOIN_TABLE_NAMES}: A
     *         comma-separated list of tables (optionally with aliases) to
     *         include in the join. The monitored table {@link #getTableName()
     *         tableName} must be included, representing only the newly
     *         inserted rows (deltas) since the last notification. Other tables
     *         can be any existing tables or views. Aliases can be used with
     *         the 'table_name as alias' syntax.
     *     <li>{@link Options#JOIN_COLUMN_NAMES JOIN_COLUMN_NAMES}: A
     *         comma-separated list of columns or expressions to include from
     *         the joined tables. Column references can use table names or
     *         aliases defined in 'join_table_names'. Each column can
     *         optionally be aliased using 'as'. The selected columns will also
     *         appear in the notification output.
     *     <li>{@link Options#JOIN_EXPRESSIONS JOIN_EXPRESSIONS}: Optional
     *         filter or join expressions to apply when combining the tables.
     *         Expressions are standard SQL-style conditions and can reference
     *         any table or alias listed in 'join_table_names'. This
     *         corresponds to the WHERE clause of the underlying join, and can
     *         include conditions to filter the delta rows.
     *     <li>{@link Options#REFRESH_METHOD REFRESH_METHOD}: Method
     *         controlling when the table monitor reports changes to the {@link
     *         #getTableName() tableName}.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#ON_CHANGE ON_CHANGE}: Report changes as
     *                 they occur.
     *             <li>{@link Options#PERIODIC PERIODIC}: Report changes
     *                 periodically at rate specified by {@link
     *                 Options#REFRESH_PERIOD REFRESH_PERIOD}.
     *         </ul>
     *         The default value is {@link Options#ON_CHANGE ON_CHANGE}.
     *     <li>{@link Options#REFRESH_PERIOD REFRESH_PERIOD}: When {@link
     *         Options#REFRESH_METHOD REFRESH_METHOD} is {@link
     *         Options#PERIODIC PERIODIC}, specifies the period in seconds at
     *         which changes are reported.
     *     <li>{@link Options#REFRESH_START_TIME REFRESH_START_TIME}: When
     *         {@link Options#REFRESH_METHOD REFRESH_METHOD} is {@link
     *         Options#PERIODIC PERIODIC}, specifies the first time at which
     *         changes are reported.  Value is a datetime string with format
     *         'YYYY-MM-DD HH:MM:SS'.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @return The current value of {@code options}.
     */
    public Map<String, String> getOptions() {
        return options;
    }

    /**
     * Optional parameters.
     * <ul>
     *     <li>{@link Options#EVENT EVENT}: Type of modification event on the
     *         target table to be monitored by this table monitor.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#INSERT INSERT}: Get notifications of new
     *                 record insertions. The new row images are forwarded to
     *                 the subscribers.
     *             <li>{@link Options#UPDATE UPDATE}: Get notifications of
     *                 update operations. The modified row count information is
     *                 forwarded to the subscribers.
     *             <li>{@link Options#DELETE DELETE}: Get notifications of
     *                 delete operations. The deleted row count information is
     *                 forwarded to the subscribers.
     *         </ul>
     *         The default value is {@link Options#INSERT INSERT}.
     *     <li>{@link Options#MONITOR_ID MONITOR_ID}: ID to use for this
     *         monitor instead of a randomly generated one
     *     <li>{@link Options#DATASINK_NAME DATASINK_NAME}: Name of an existing
     *         <a href="../../../../../../concepts/data_sinks/"
     *         target="_top">data sink</a> to send change data notifications to
     *     <li>{@link Options#DESTINATION DESTINATION}: Destination for the
     *         output data in format 'destination_type://path[:port]'.
     *         Supported destination types are 'http', 'https' and 'kafka'.
     *     <li>{@link Options#KAFKA_TOPIC_NAME KAFKA_TOPIC_NAME}: Name of the
     *         Kafka topic to publish to if {@link Options#DESTINATION
     *         DESTINATION} in {@link #getOptions() options} is specified and
     *         is a Kafka broker
     *     <li>{@link Options#INCREASING_COLUMN INCREASING_COLUMN}: Column on
     *         subscribed table that will increase for new records (e.g.,
     *         TIMESTAMP).
     *     <li>{@link Options#EXPRESSION EXPRESSION}: Filter expression to
     *         limit records for notification
     *     <li>{@link Options#JOIN_TABLE_NAMES JOIN_TABLE_NAMES}: A
     *         comma-separated list of tables (optionally with aliases) to
     *         include in the join. The monitored table {@link #getTableName()
     *         tableName} must be included, representing only the newly
     *         inserted rows (deltas) since the last notification. Other tables
     *         can be any existing tables or views. Aliases can be used with
     *         the 'table_name as alias' syntax.
     *     <li>{@link Options#JOIN_COLUMN_NAMES JOIN_COLUMN_NAMES}: A
     *         comma-separated list of columns or expressions to include from
     *         the joined tables. Column references can use table names or
     *         aliases defined in 'join_table_names'. Each column can
     *         optionally be aliased using 'as'. The selected columns will also
     *         appear in the notification output.
     *     <li>{@link Options#JOIN_EXPRESSIONS JOIN_EXPRESSIONS}: Optional
     *         filter or join expressions to apply when combining the tables.
     *         Expressions are standard SQL-style conditions and can reference
     *         any table or alias listed in 'join_table_names'. This
     *         corresponds to the WHERE clause of the underlying join, and can
     *         include conditions to filter the delta rows.
     *     <li>{@link Options#REFRESH_METHOD REFRESH_METHOD}: Method
     *         controlling when the table monitor reports changes to the {@link
     *         #getTableName() tableName}.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#ON_CHANGE ON_CHANGE}: Report changes as
     *                 they occur.
     *             <li>{@link Options#PERIODIC PERIODIC}: Report changes
     *                 periodically at rate specified by {@link
     *                 Options#REFRESH_PERIOD REFRESH_PERIOD}.
     *         </ul>
     *         The default value is {@link Options#ON_CHANGE ON_CHANGE}.
     *     <li>{@link Options#REFRESH_PERIOD REFRESH_PERIOD}: When {@link
     *         Options#REFRESH_METHOD REFRESH_METHOD} is {@link
     *         Options#PERIODIC PERIODIC}, specifies the period in seconds at
     *         which changes are reported.
     *     <li>{@link Options#REFRESH_START_TIME REFRESH_START_TIME}: When
     *         {@link Options#REFRESH_METHOD REFRESH_METHOD} is {@link
     *         Options#PERIODIC PERIODIC}, specifies the first time at which
     *         changes are reported.  Value is a datetime string with format
     *         'YYYY-MM-DD HH:MM:SS'.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @param options  The new value for {@code options}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public CreateTableMonitorRequest setOptions(Map<String, String> options) {
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
        return this;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @return The schema object describing this class.
     */
    @Override
    public Schema getSchema() {
        return schema$;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @param index  the position of the field to get
     *
     * @return value of the field with the given index.
     *
     * @throws IndexOutOfBoundsException
     */
    @Override
    public Object get(int index) {
        switch (index) {
            case 0:
                return this.tableName;

            case 1:
                return this.options;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @param index  the position of the field to set
     * @param value  the value to set
     *
     * @throws IndexOutOfBoundsException
     */
    @Override
    @SuppressWarnings("unchecked")
    public void put(int index, Object value) {
        switch (index) {
            case 0:
                this.tableName = (String)value;
                break;

            case 1:
                this.options = (Map<String, String>)value;
                break;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if( obj == this ) {
            return true;
        }

        if( (obj == null) || (obj.getClass() != this.getClass()) ) {
            return false;
        }

        CreateTableMonitorRequest that = (CreateTableMonitorRequest)obj;

        return ( this.tableName.equals( that.tableName )
                 && this.options.equals( that.options ) );
    }

    @Override
    public String toString() {
        GenericData gd = GenericData.get();
        StringBuilder builder = new StringBuilder();
        builder.append( "{" );
        builder.append( gd.toString( "tableName" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.tableName ) );
        builder.append( ", " );
        builder.append( gd.toString( "options" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.options ) );
        builder.append( "}" );

        return builder.toString();
    }

    @Override
    public int hashCode() {
        int hashCode = 1;
        hashCode = (31 * hashCode) + this.tableName.hashCode();
        hashCode = (31 * hashCode) + this.options.hashCode();
        return hashCode;
    }
}
