/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
package com.gpudb.protocol;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.apache.avro.Schema;
import org.apache.avro.SchemaBuilder;
import org.apache.avro.generic.GenericData;
import org.apache.avro.generic.IndexedRecord;

/**
 * A set of parameters for {@link com.gpudb.GPUdb#matchGraph(MatchGraphRequest)
 * GPUdb.matchGraph}.
 * <p>
 * Matches a directed route implied by a given set of latitude/longitude points
 * to an existing underlying road network graph using a given solution type.
 * <p>
 * IMPORTANT: It's highly recommended that you review the <a
 * href="../../../../../../graph_solver/network_graph_solver/"
 * target="_top">Graphs & Solvers</a> concepts documentation, the <a
 * href="../../../../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>, and/or some <a
 * href="../../../../../../guide-tags/graph---match/"
 * target="_top">/match/graph examples</a> before using this endpoint.
 */
public class MatchGraphRequest implements IndexedRecord {
    private static final Schema schema$ = SchemaBuilder
            .record("MatchGraphRequest")
            .namespace("com.gpudb")
            .fields()
                .name("graphName").type().stringType().noDefault()
                .name("samplePoints").type().array().items().stringType().noDefault()
                .name("solveMethod").type().stringType().noDefault()
                .name("solutionTable").type().stringType().noDefault()
                .name("options").type().map().values().stringType().noDefault()
            .endRecord();

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @return The schema for the class.
     */
    public static Schema getClassSchema() {
        return schema$;
    }

    /**
     * A set of string constants for the {@link MatchGraphRequest} parameter
     * {@link #getSolveMethod() solveMethod}.
     * <p>
     * The type of solver to use for graph matching.
     */
    public static final class SolveMethod {
        /**
         * Matches {@link #getSamplePoints() samplePoints} to the graph using
         * the Hidden Markov Model (HMM)-based method, which conducts a
         * range-tree closest-edge search to find the best combinations of
         * possible road segments ({@link Options#NUM_SEGMENTS NUM_SEGMENTS})
         * for each sample point to create the best route. The route is secured
         * one point at a time while looking ahead {@link Options#CHAIN_WIDTH
         * CHAIN_WIDTH} number of points, so the prediction is corrected after
         * each point. This solution type is the most accurate but also the
         * most computationally intensive. Related options: {@link
         * Options#NUM_SEGMENTS NUM_SEGMENTS} and {@link Options#CHAIN_WIDTH
         * CHAIN_WIDTH}.
         */
        public static final String MARKOV_CHAIN = "markov_chain";

        /**
         * Matches {@link #getSamplePoints() samplePoints} to find the most
         * probable path between origin and destination pairs with cost
         * constraints.
         */
        public static final String MATCH_OD_PAIRS = "match_od_pairs";

        /**
         * Matches {@link #getSamplePoints() samplePoints} to optimize
         * scheduling multiple supplies (trucks) with varying sizes to varying
         * demand sites with varying capacities per depot. Related options:
         * {@link Options#PARTIAL_LOADING PARTIAL_LOADING} and {@link
         * Options#MAX_COMBINATIONS MAX_COMBINATIONS}.
         */
        public static final String MATCH_SUPPLY_DEMAND = "match_supply_demand";

        /**
         * Matches {@link #getSamplePoints() samplePoints} source and
         * destination pairs for the shortest path solves in batch mode.
         */
        public static final String MATCH_BATCH_SOLVES = "match_batch_solves";

        /**
         * Matches closed loops (Eulerian paths) originating and ending at each
         * graph node within min and max hops (levels).
         */
        public static final String MATCH_LOOPS = "match_loops";

        /**
         * Matches an optimal path across a number of ev-charging stations
         * between source and target locations.
         */
        public static final String MATCH_CHARGING_STATIONS = "match_charging_stations";

        /**
         * Matches the intersection set(s) by computing the Jaccard similarity
         * score between node pairs.
         */
        public static final String MATCH_SIMILARITY = "match_similarity";

        /**
         * Matches the pickups and dropoffs by optimizing the total trip costs
         */
        public static final String MATCH_PICKUP_DROPOFF = "match_pickup_dropoff";

        /**
         * Matches the graph nodes with a cluster index using Louvain
         * clustering algorithm
         */
        public static final String MATCH_CLUSTERS = "match_clusters";

        /**
         * Matches a pattern in the graph
         */
        public static final String MATCH_PATTERN = "match_pattern";

        /**
         * Creates vector node embeddings
         */
        public static final String MATCH_EMBEDDING = "match_embedding";

        /**
         * Solves for isochrones for a set of input sources
         */
        public static final String MATCH_ISOCHRONE = "match_isochrone";

        private SolveMethod() {  }
    }

    /**
     * A set of string constants for the {@link MatchGraphRequest} parameter
     * {@link #getOptions() options}.
     * <p>
     * Additional parameters
     */
    public static final class Options {
        /**
         * GPS noise value (in meters) to remove redundant sample points. Use
         * -1 to disable noise reduction. The default value accounts for 95% of
         * point variation (+ or -5 meters). The default value is '5.0'.
         */
        public static final String GPS_NOISE = "gps_noise";

        /**
         * Maximum number of potentially matching road segments for each sample
         * point. For the {@link SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver,
         * the default is 3. The default value is '3'.
         */
        public static final String NUM_SEGMENTS = "num_segments";

        /**
         * Maximum search radius used when snapping sample points onto
         * potentially matching surrounding segments. The default value
         * corresponds to approximately 100 meters. The default value is
         * '0.001'.
         */
        public static final String SEARCH_RADIUS = "search_radius";

        /**
         * For the {@link SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver only.
         * Length of the sample points lookahead window within the Markov
         * kernel; the larger the number, the more accurate the solution. The
         * default value is '9'.
         */
        public static final String CHAIN_WIDTH = "chain_width";

        /**
         * Optional WKT starting point from {@link #getSamplePoints()
         * samplePoints} for the solver. The default behavior for the endpoint
         * is to use time to determine the starting point. The default value is
         * 'POINT NULL'.
         */
        public static final String SOURCE = "source";

        /**
         * Optional WKT ending point from {@link #getSamplePoints()
         * samplePoints} for the solver. The default behavior for the endpoint
         * is to use time to determine the destination point. The default value
         * is 'POINT NULL'.
         */
        public static final String DESTINATION = "destination";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * solver only. When false (non-default), trucks do not off-load at the
         * demand (store) side if the remainder is less than the store's need.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Partial off-loading at multiple
         *         store (demand) locations
         *     <li>{@link Options#FALSE FALSE}: No partial off-loading allowed
         *         if supply is less than the store's demand.
         * </ul>
         * The default value is {@link Options#TRUE TRUE}.
         */
        public static final String PARTIAL_LOADING = "partial_loading";

        public static final String TRUE = "true";
        public static final String FALSE = "false";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * solver only. This is the cutoff for the number of generated
         * combinations for sequencing the demand locations - can increase this
         * up to 2M. The default value is '10000'.
         */
        public static final String MAX_COMBINATIONS = "max_combinations";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * solver only. This is the cutoff for the number of generated
         * combinations for sequencing the supply locations if/when
         * 'permute_supplies' is true. The default value is '10000'.
         */
        public static final String MAX_SUPPLY_COMBINATIONS = "max_supply_combinations";

        /**
         * This will add an additional weight over the edges labeled as 'left
         * turn' if the 'add_turn' option parameter of the {@link
         * com.gpudb.GPUdb#createGraph(CreateGraphRequest) GPUdb.createGraph}
         * was invoked at graph creation. The default value is '0.0'.
         */
        public static final String LEFT_TURN_PENALTY = "left_turn_penalty";

        /**
         * This will add an additional weight over the edges labeled as' right
         * turn' if the 'add_turn' option parameter of the {@link
         * com.gpudb.GPUdb#createGraph(CreateGraphRequest) GPUdb.createGraph}
         * was invoked at graph creation. The default value is '0.0'.
         */
        public static final String RIGHT_TURN_PENALTY = "right_turn_penalty";

        /**
         * This will add an additional weight over the edges labeled as
         * 'intersection' if the 'add_turn' option parameter of the {@link
         * com.gpudb.GPUdb#createGraph(CreateGraphRequest) GPUdb.createGraph}
         * was invoked at graph creation. The default value is '0.0'.
         */
        public static final String INTERSECTION_PENALTY = "intersection_penalty";

        /**
         * This will add an additional weight over the edges labeled as 'sharp
         * turn' or 'u-turn' if the 'add_turn' option parameter of the {@link
         * com.gpudb.GPUdb#createGraph(CreateGraphRequest) GPUdb.createGraph}
         * was invoked at graph creation. The default value is '0.0'.
         */
        public static final String SHARP_TURN_PENALTY = "sharp_turn_penalty";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * solver only. When it is true (default), each record in the output
         * table shows a particular truck's scheduled cumulative round trip
         * path (MULTILINESTRING) and the corresponding aggregated cost.
         * Otherwise, each record shows a single scheduled truck route
         * (LINESTRING) towards a particular demand location (store id) with
         * its corresponding cost. The default value is 'true'.
         */
        public static final String AGGREGATED_OUTPUT = "aggregated_output";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * solver only. When it is true (non-default), the output will be in
         * tracks format for all the round trips of each truck in which the
         * timestamps are populated directly from the edge weights starting
         * from their originating depots. The default value is 'false'.
         */
        public static final String OUTPUT_TRACKS = "output_tracks";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * and {@link SolveMethod#MATCH_PICKUP_DROPOFF MATCH_PICKUP_DROPOFF}
         * solvers only. If this constraint is greater than zero (default) then
         * the trucks/rides will skip traveling from one demand/pick location
         * to another if the cost between them is greater than this number
         * (distance or time). Zero (default) value means no check is
         * performed. The default value is '0.0'.
         */
        public static final String MAX_TRIP_COST = "max_trip_cost";

        /**
         * For the {@link SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver only.
         * When true (non-default), the paths per sequence combination is
         * checked for folding over patterns and can significantly increase the
         * execution time depending on the chain width and the number of GPS
         * samples.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Filter out the folded paths.
         *     <li>{@link Options#FALSE FALSE}: Do not filter out the folded
         *         paths
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String FILTER_FOLDING_PATHS = "filter_folding_paths";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * solver only. The unit cost per load amount to be delivered. If this
         * value is greater than zero (default) then the additional cost of
         * this unit load multiplied by the total dropped load will be added
         * over to the trip cost to the demand location. The default value is
         * '0.0'.
         */
        public static final String UNIT_UNLOADING_COST = "unit_unloading_cost";

        /**
         * For the {@link SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver only.
         * If specified (greater than zero), the maximum number of threads will
         * not be greater than the specified value. It can be lower due to the
         * memory and the number cores available. Default value of zero allows
         * the algorithm to set the maximal number of threads within these
         * constraints. The default value is '0'.
         */
        public static final String MAX_NUM_THREADS = "max_num_threads";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * solver only. If specified (greater than zero), any supply actor's
         * total service cost (distance or time) will be limited by the
         * specified value including multiple rounds (if set). The default
         * value is '0.0'.
         */
        public static final String SERVICE_LIMIT = "service_limit";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * solver only. If specified (true), all supply actors can be scheduled
         * for second rounds from their originating depots.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Allows reusing supply actors
         *         (trucks, e.g.) for scheduling again.
         *     <li>{@link Options#FALSE FALSE}: Supply actors are scheduled
         *         only once from their depots.
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String ENABLE_REUSE = "enable_reuse";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * solver only. If specified (greater than zero), a supply actor
         * (truck) can at most have this many stops (demand locations) in one
         * round trip. Otherwise, it is unlimited. If 'enable_truck_reuse' is
         * on, this condition will be applied separately at each round trip use
         * of the same truck. The default value is '0'.
         */
        public static final String MAX_STOPS = "max_stops";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * and {@link SolveMethod#MATCH_PICKUP_DROPOFF MATCH_PICKUP_DROPOFF}
         * solvers only. If specified (greater than zero), it filters the
         * demands/picks outside this radius centered around the supply
         * actor/ride's originating location (distance or time). The default
         * value is '0.0'.
         */
        public static final String SERVICE_RADIUS = "service_radius";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * solver only. If specified (true), supply side actors are permuted
         * for the demand combinations during MSDO optimization - note that
         * this option increases optimization time significantly - use of
         * 'max_combinations' option is recommended to prevent prohibitively
         * long runs.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Generates sequences over supply
         *         side permutations if total supply is less than twice the
         *         total demand
         *     <li>{@link Options#FALSE FALSE}: Permutations are not performed,
         *         rather a specific order of supplies based on capacity is
         *         computed
         * </ul>
         * The default value is {@link Options#TRUE TRUE}.
         */
        public static final String PERMUTE_SUPPLIES = "permute_supplies";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * solver only. When enabled, it sets the number of visits on each
         * demand location by a single salesman at each trip is considered to
         * be (one) 1, otherwise there is no bound.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Sets only one visit per demand
         *         location by a salesman (TSM mode)
         *     <li>{@link Options#FALSE FALSE}: No preset limit (usual MSDO
         *         mode)
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String BATCH_TSM_MODE = "batch_tsm_mode";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * solver only. When enabled, the supply will have to return back to
         * the origination location.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: The optimization is done for
         *         trips in round trip manner always returning to originating
         *         locations
         *     <li>{@link Options#FALSE FALSE}: Supplies do not have to come
         *         back to their originating locations in their routes. The
         *         routes are considered finished at the final dropoff.
         * </ul>
         * The default value is {@link Options#TRUE TRUE}.
         */
        public static final String ROUND_TRIP = "round_trip";

        /**
         * For the {@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} solver
         * only. Terminates the cluster exchange iterations across
         * 2-step-cycles (outer loop) when quality does not improve during
         * iterations. The default value is '10'.
         */
        public static final String NUM_CYCLES = "num_cycles";

        /**
         * For the {@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} and {@link
         * SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only.
         * Terminates the cluster exchanges within the first step iterations of
         * a cycle (inner loop) unless convergence is reached. The default
         * value is '10'.
         */
        public static final String NUM_LOOPS_PER_CYCLE = "num_loops_per_cycle";

        /**
         * For the {@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} solver
         * only.  Limits the output to the top 'num_output_clusters' clusters
         * based on density. Default value of zero outputs all clusters. The
         * default value is '0'.
         */
        public static final String NUM_OUTPUT_CLUSTERS = "num_output_clusters";

        /**
         * For the {@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} and {@link
         * SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only. If set
         * (value greater than zero), it terminates when the number of clusters
         * goes below than this number. For embedding solver the default is 8.
         * The default value is '0'.
         */
        public static final String MAX_NUM_CLUSTERS = "max_num_clusters";

        /**
         * For the {@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} solver
         * only. The quality metric for Louvain modularity optimization solver.
         * Supported values:
         * <ul>
         *     <li>{@link Options#GIRVAN GIRVAN}: Uses the Newman Girvan
         *         quality metric for cluster solver
         *     <li>{@link Options#SPECTRAL SPECTRAL}: Applies recursive
         *         spectral bisection (RSB) partitioning solver
         * </ul>
         * The default value is {@link Options#GIRVAN GIRVAN}.
         */
        public static final String CLUSTER_QUALITY_METRIC = "cluster_quality_metric";

        /**
         * Uses the Newman Girvan quality metric for cluster solver
         */
        public static final String GIRVAN = "girvan";

        /**
         * Applies recursive spectral bisection (RSB) partitioning solver
         */
        public static final String SPECTRAL = "spectral";

        /**
         * For the {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
         * solver only. Optimization is performed by restricting routes labeled
         * by 'MSDO_ODDEVEN_RESTRICTED' only for this supply actor (truck)
         * type.
         * Supported values:
         * <ul>
         *     <li>{@link Options#ODD ODD}: Applies odd/even rule restrictions
         *         to odd tagged vehicles.
         *     <li>{@link Options#EVEN EVEN}: Applies odd/even rule
         *         restrictions to even tagged vehicles.
         *     <li>{@link Options#NONE NONE}: Does not apply odd/even rule
         *         restrictions to any vehicles.
         * </ul>
         * The default value is {@link Options#NONE NONE}.
         */
        public static final String RESTRICTED_TYPE = "restricted_type";

        /**
         * Applies odd/even rule restrictions to odd tagged vehicles.
         */
        public static final String ODD = "odd";

        /**
         * Applies odd/even rule restrictions to even tagged vehicles.
         */
        public static final String EVEN = "even";

        /**
         * Does not apply odd/even rule restrictions to any vehicles.
         */
        public static final String NONE = "none";

        /**
         * Indicates which graph server(s) to send the request to. Default is
         * to send to the server, amongst those containing the corresponding
         * graph, that has the most computational bandwidth. The default value
         * is ''.
         */
        public static final String SERVER_ID = "server_id";

        /**
         * For the {@link SolveMethod#MATCH_BATCH_SOLVES MATCH_BATCH_SOLVES}
         * solver only. Solves source-destination pairs using inverse shortest
         * path solver.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Solves using inverse shortest
         *         path solver.
         *     <li>{@link Options#FALSE FALSE}: Solves using direct shortest
         *         path solver.
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String INVERSE_SOLVE = "inverse_solve";

        /**
         * For the {@link SolveMethod#MATCH_LOOPS MATCH_LOOPS} solver only.
         * Finds closed loops around each node deducible not less than this
         * minimal hop (level) deep. The default value is '0'.
         */
        public static final String MIN_LOOP_LEVEL = "min_loop_level";

        /**
         * For the {@link SolveMethod#MATCH_LOOPS MATCH_LOOPS} solver only.
         * Finds closed loops around each node deducible not more than this
         * maximal hop (level) deep. The default value is '5'.
         */
        public static final String MAX_LOOP_LEVEL = "max_loop_level";

        /**
         * For the {@link SolveMethod#MATCH_LOOPS MATCH_LOOPS} solver only.
         * Searches within this limit of nodes per vertex to detect loops. The
         * value zero means there is no limit. The default value is '10000'.
         */
        public static final String SEARCH_LIMIT = "search_limit";

        /**
         * For the {@link SolveMethod#MATCH_LOOPS MATCH_LOOPS} solver only.
         * Uses this value as the batch size of the number of loops in
         * flushing(inserting) to the output table. The default value is
         * '1000'.
         */
        public static final String OUTPUT_BATCH_SIZE = "output_batch_size";

        /**
         * For the {@link SolveMethod#MATCH_CHARGING_STATIONS
         * MATCH_CHARGING_STATIONS} solver only. This is the maximum
         * ev-charging capacity of a vehicle (distance in meters or time in
         * seconds depending on the unit of the graph weights). The default
         * value is '300000.0'.
         */
        public static final String CHARGING_CAPACITY = "charging_capacity";

        /**
         * For the {@link SolveMethod#MATCH_CHARGING_STATIONS
         * MATCH_CHARGING_STATIONS} solver only. Solver searches for this many
         * number of stations closest around each base charging location found
         * by capacity. The default value is '10'.
         */
        public static final String CHARGING_CANDIDATES = "charging_candidates";

        /**
         * For the {@link SolveMethod#MATCH_CHARGING_STATIONS
         * MATCH_CHARGING_STATIONS} solver only. This is the penalty for full
         * charging. The default value is '30000.0'.
         */
        public static final String CHARGING_PENALTY = "charging_penalty";

        /**
         * For the {@link SolveMethod#MATCH_SIMILARITY MATCH_SIMILARITY} and
         * {@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only.
         * Searches within this maximum hops for source and target node pairs
         * to compute the Jaccard scores. The default value is '3'.
         */
        public static final String MAX_HOPS = "max_hops";

        /**
         * For the {@link SolveMethod#MATCH_SIMILARITY MATCH_SIMILARITY} solver
         * only. Limits the traversal depth if it reaches this many number of
         * nodes. The default value is '1000'.
         */
        public static final String TRAVERSAL_NODE_LIMIT = "traversal_node_limit";

        /**
         * For the {@link SolveMethod#MATCH_SIMILARITY MATCH_SIMILARITY} solver
         * only. If true, it computes Jaccard score between each pair,
         * otherwise it will compute Jaccard from the intersection set between
         * the source and target nodes.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#TRUE TRUE}.
         */
        public static final String PAIRED_SIMILARITY = "paired_similarity";

        /**
         * For the {@link SolveMethod#MATCH_PATTERN MATCH_PATTERN} and {@link
         * SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only. Pattern
         * matching will be using both pattern and graph as undirected if set
         * to true.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String FORCE_UNDIRECTED = "force_undirected";

        /**
         * For the {@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver
         * only. Limits the number of dimensions in node vector embeddings. The
         * default value is '1000'.
         */
        public static final String MAX_VECTOR_DIMENSION = "max_vector_dimension";

        /**
         * For the {@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers
         * only. Solves to find the optimal weights per sub feature in vector
         * embeddings.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String OPTIMIZE_EMBEDDING_WEIGHTS = "optimize_embedding_weights";

        /**
         * For the {@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver
         * only. User specified weights per sub feature in vector embeddings.
         * The string contains the comma separated float values for each
         * sub-feature in the vector space. These values will ONLY be used if
         * 'optimize_embedding_weights' is false. The default value is
         * '1.0,1.0,1.0,1.0'.
         */
        public static final String EMBEDDING_WEIGHTS = "embedding_weights";

        /**
         * For the {@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver
         * only. Sets the number of random nodes from the graph for solving the
         * weights using stochastic gradient descent. The default value is
         * '1000'.
         */
        public static final String OPTIMIZATION_SAMPLING_SIZE = "optimization_sampling_size";

        /**
         * For the {@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver
         * only. When the iterations (epochs) for the convergence of the
         * stochastic gradient descent algorithm reaches this number it bails
         * out unless relative error between consecutive iterations is below
         * the 'optimization_error_tolerance' option. The default value is
         * '1000'.
         */
        public static final String OPTIMIZATION_MAX_ITERATIONS = "optimization_max_iterations";

        /**
         * For the {@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver
         * only. When the relative error between all of the weights'
         * consecutive iterations falls below this threshold the optimization
         * cycle is interrupted unless the number of iterations reaches the
         * limit set by the option 'max_optimization_iterations'. The default
         * value is '0.001'.
         */
        public static final String OPTIMIZATION_ERROR_TOLERANCE = "optimization_error_tolerance";

        /**
         * For the {@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver
         * only. It is otherwise known as the learning rate, which is the
         * proportionality constant in front of the gradient term in successive
         * iterations. The default value is '0.3'.
         */
        public static final String OPTIMIZATION_ITERATION_RATE = "optimization_iteration_rate";

        /**
         * For the {@link SolveMethod#MATCH_ISOCHRONE MATCH_ISOCHRONE} solver
         * only. Sets the maximal reachability limit for computing isochrones.
         * Zero means no limit. The default value is '0.0'.
         */
        public static final String MAX_RADIUS = "max_radius";

        private Options() {  }
    }

    private String graphName;
    private List<String> samplePoints;
    private String solveMethod;
    private String solutionTable;
    private Map<String, String> options;

    /**
     * Constructs a MatchGraphRequest object with default parameters.
     */
    public MatchGraphRequest() {
        graphName = "";
        samplePoints = new ArrayList<>();
        solveMethod = "";
        solutionTable = "";
        options = new LinkedHashMap<>();
    }

    /**
     * Constructs a MatchGraphRequest object with the specified parameters.
     *
     * @param graphName  Name of the underlying geospatial graph resource to
     *                   match to using {@code samplePoints}.
     * @param samplePoints  Sample points used to match to an underlying
     *                      geospatial graph. Sample points must be specified
     *                      using <a
     *                      href="../../../../../../graph_solver/network_graph_solver/#match-identifiers"
     *                      target="_top">identifiers</a>; identifiers are
     *                      grouped as <a
     *                      href="../../../../../../graph_solver/network_graph_solver/#match-combinations"
     *                      target="_top">combinations</a>. Identifiers can be
     *                      used with: existing column names, e.g.,
     *                      'table.column AS SAMPLE_X'; expressions, e.g.,
     *                      'ST_MAKEPOINT(table.x, table.y) AS
     *                      SAMPLE_WKTPOINT'; or constant values, e.g., '{1, 2,
     *                      10} AS SAMPLE_TRIPID'.
     * @param solveMethod  The type of solver to use for graph matching.
     *                     Supported values:
     *                     <ul>
     *                         <li>{@link SolveMethod#MARKOV_CHAIN
     *                             MARKOV_CHAIN}: Matches {@code samplePoints}
     *                             to the graph using the Hidden Markov Model
     *                             (HMM)-based method, which conducts a
     *                             range-tree closest-edge search to find the
     *                             best combinations of possible road segments
     *                             ({@link Options#NUM_SEGMENTS NUM_SEGMENTS})
     *                             for each sample point to create the best
     *                             route. The route is secured one point at a
     *                             time while looking ahead {@link
     *                             Options#CHAIN_WIDTH CHAIN_WIDTH} number of
     *                             points, so the prediction is corrected after
     *                             each point. This solution type is the most
     *                             accurate but also the most computationally
     *                             intensive. Related options: {@link
     *                             Options#NUM_SEGMENTS NUM_SEGMENTS} and
     *                             {@link Options#CHAIN_WIDTH CHAIN_WIDTH}.
     *                         <li>{@link SolveMethod#MATCH_OD_PAIRS
     *                             MATCH_OD_PAIRS}: Matches {@code
     *                             samplePoints} to find the most probable path
     *                             between origin and destination pairs with
     *                             cost constraints.
     *                         <li>{@link SolveMethod#MATCH_SUPPLY_DEMAND
     *                             MATCH_SUPPLY_DEMAND}: Matches {@code
     *                             samplePoints} to optimize scheduling
     *                             multiple supplies (trucks) with varying
     *                             sizes to varying demand sites with varying
     *                             capacities per depot. Related options:
     *                             {@link Options#PARTIAL_LOADING
     *                             PARTIAL_LOADING} and {@link
     *                             Options#MAX_COMBINATIONS MAX_COMBINATIONS}.
     *                         <li>{@link SolveMethod#MATCH_BATCH_SOLVES
     *                             MATCH_BATCH_SOLVES}: Matches {@code
     *                             samplePoints} source and destination pairs
     *                             for the shortest path solves in batch mode.
     *                         <li>{@link SolveMethod#MATCH_LOOPS MATCH_LOOPS}:
     *                             Matches closed loops (Eulerian paths)
     *                             originating and ending at each graph node
     *                             within min and max hops (levels).
     *                         <li>{@link SolveMethod#MATCH_CHARGING_STATIONS
     *                             MATCH_CHARGING_STATIONS}: Matches an optimal
     *                             path across a number of ev-charging stations
     *                             between source and target locations.
     *                         <li>{@link SolveMethod#MATCH_SIMILARITY
     *                             MATCH_SIMILARITY}: Matches the intersection
     *                             set(s) by computing the Jaccard similarity
     *                             score between node pairs.
     *                         <li>{@link SolveMethod#MATCH_PICKUP_DROPOFF
     *                             MATCH_PICKUP_DROPOFF}: Matches the pickups
     *                             and dropoffs by optimizing the total trip
     *                             costs
     *                         <li>{@link SolveMethod#MATCH_CLUSTERS
     *                             MATCH_CLUSTERS}: Matches the graph nodes
     *                             with a cluster index using Louvain
     *                             clustering algorithm
     *                         <li>{@link SolveMethod#MATCH_PATTERN
     *                             MATCH_PATTERN}: Matches a pattern in the
     *                             graph
     *                         <li>{@link SolveMethod#MATCH_EMBEDDING
     *                             MATCH_EMBEDDING}: Creates vector node
     *                             embeddings
     *                         <li>{@link SolveMethod#MATCH_ISOCHRONE
     *                             MATCH_ISOCHRONE}: Solves for isochrones for
     *                             a set of input sources
     *                     </ul>
     *                     The default value is {@link SolveMethod#MARKOV_CHAIN
     *                     MARKOV_CHAIN}.
     * @param solutionTable  The name of the table used to store the results,
     *                       in [schema_name.]table_name format, using standard
     *                       <a
     *                       href="../../../../../../concepts/tables/#table-name-resolution"
     *                       target="_top">name resolution rules</a> and
     *                       meeting <a
     *                       href="../../../../../../concepts/tables/#table-naming-criteria"
     *                       target="_top">table naming criteria</a>.  This
     *                       table contains a <a
     *                       href="../../../../../../location_intelligence/geo_objects/#geospatial-tracks"
     *                       target="_top">track</a> of geospatial points for
     *                       the matched portion of the graph, a track ID, and
     *                       a score value. Also outputs a details table
     *                       containing a trip ID (that matches the track ID),
     *                       the latitude/longitude pair, the timestamp the
     *                       point was recorded at, and an edge ID
     *                       corresponding to the matched road segment. Must
     *                       not be an existing table of the same name. The
     *                       default value is ''.
     * @param options  Additional parameters.
     *                 <ul>
     *                     <li>{@link Options#GPS_NOISE GPS_NOISE}: GPS noise
     *                         value (in meters) to remove redundant sample
     *                         points. Use -1 to disable noise reduction. The
     *                         default value accounts for 95% of point
     *                         variation (+ or -5 meters). The default value is
     *                         '5.0'.
     *                     <li>{@link Options#NUM_SEGMENTS NUM_SEGMENTS}:
     *                         Maximum number of potentially matching road
     *                         segments for each sample point. For the {@link
     *                         SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver,
     *                         the default is 3. The default value is '3'.
     *                     <li>{@link Options#SEARCH_RADIUS SEARCH_RADIUS}:
     *                         Maximum search radius used when snapping sample
     *                         points onto potentially matching surrounding
     *                         segments. The default value corresponds to
     *                         approximately 100 meters. The default value is
     *                         '0.001'.
     *                     <li>{@link Options#CHAIN_WIDTH CHAIN_WIDTH}: For the
     *                         {@link SolveMethod#MARKOV_CHAIN MARKOV_CHAIN}
     *                         solver only. Length of the sample points
     *                         lookahead window within the Markov kernel; the
     *                         larger the number, the more accurate the
     *                         solution. The default value is '9'.
     *                     <li>{@link Options#SOURCE SOURCE}: Optional WKT
     *                         starting point from {@code samplePoints} for the
     *                         solver. The default behavior for the endpoint is
     *                         to use time to determine the starting point. The
     *                         default value is 'POINT NULL'.
     *                     <li>{@link Options#DESTINATION DESTINATION}:
     *                         Optional WKT ending point from {@code
     *                         samplePoints} for the solver. The default
     *                         behavior for the endpoint is to use time to
     *                         determine the destination point. The default
     *                         value is 'POINT NULL'.
     *                     <li>{@link Options#PARTIAL_LOADING PARTIAL_LOADING}:
     *                         For the {@link SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} solver only. When false
     *                         (non-default), trucks do not off-load at the
     *                         demand (store) side if the remainder is less
     *                         than the store's need.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Partial
     *                                 off-loading at multiple store (demand)
     *                                 locations
     *                             <li>{@link Options#FALSE FALSE}: No partial
     *                                 off-loading allowed if supply is less
     *                                 than the store's demand.
     *                         </ul>
     *                         The default value is {@link Options#TRUE TRUE}.
     *                     <li>{@link Options#MAX_COMBINATIONS
     *                         MAX_COMBINATIONS}: For the {@link
     *                         SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} solver only. This is the
     *                         cutoff for the number of generated combinations
     *                         for sequencing the demand locations - can
     *                         increase this up to 2M. The default value is
     *                         '10000'.
     *                     <li>{@link Options#MAX_SUPPLY_COMBINATIONS
     *                         MAX_SUPPLY_COMBINATIONS}: For the {@link
     *                         SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} solver only. This is the
     *                         cutoff for the number of generated combinations
     *                         for sequencing the supply locations if/when
     *                         'permute_supplies' is true. The default value is
     *                         '10000'.
     *                     <li>{@link Options#LEFT_TURN_PENALTY
     *                         LEFT_TURN_PENALTY}: This will add an additional
     *                         weight over the edges labeled as 'left turn' if
     *                         the 'add_turn' option parameter of the {@link
     *                         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *                         GPUdb.createGraph} was invoked at graph
     *                         creation. The default value is '0.0'.
     *                     <li>{@link Options#RIGHT_TURN_PENALTY
     *                         RIGHT_TURN_PENALTY}: This will add an additional
     *                         weight over the edges labeled as' right turn' if
     *                         the 'add_turn' option parameter of the {@link
     *                         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *                         GPUdb.createGraph} was invoked at graph
     *                         creation. The default value is '0.0'.
     *                     <li>{@link Options#INTERSECTION_PENALTY
     *                         INTERSECTION_PENALTY}: This will add an
     *                         additional weight over the edges labeled as
     *                         'intersection' if the 'add_turn' option
     *                         parameter of the {@link
     *                         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *                         GPUdb.createGraph} was invoked at graph
     *                         creation. The default value is '0.0'.
     *                     <li>{@link Options#SHARP_TURN_PENALTY
     *                         SHARP_TURN_PENALTY}: This will add an additional
     *                         weight over the edges labeled as 'sharp turn' or
     *                         'u-turn' if the 'add_turn' option parameter of
     *                         the {@link
     *                         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *                         GPUdb.createGraph} was invoked at graph
     *                         creation. The default value is '0.0'.
     *                     <li>{@link Options#AGGREGATED_OUTPUT
     *                         AGGREGATED_OUTPUT}: For the {@link
     *                         SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} solver only. When it is
     *                         true (default), each record in the output table
     *                         shows a particular truck's scheduled cumulative
     *                         round trip path (MULTILINESTRING) and the
     *                         corresponding aggregated cost. Otherwise, each
     *                         record shows a single scheduled truck route
     *                         (LINESTRING) towards a particular demand
     *                         location (store id) with its corresponding cost.
     *                         The default value is 'true'.
     *                     <li>{@link Options#OUTPUT_TRACKS OUTPUT_TRACKS}: For
     *                         the {@link SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} solver only. When it is
     *                         true (non-default), the output will be in tracks
     *                         format for all the round trips of each truck in
     *                         which the timestamps are populated directly from
     *                         the edge weights starting from their originating
     *                         depots. The default value is 'false'.
     *                     <li>{@link Options#MAX_TRIP_COST MAX_TRIP_COST}: For
     *                         the {@link SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} and {@link
     *                         SolveMethod#MATCH_PICKUP_DROPOFF
     *                         MATCH_PICKUP_DROPOFF} solvers only. If this
     *                         constraint is greater than zero (default) then
     *                         the trucks/rides will skip traveling from one
     *                         demand/pick location to another if the cost
     *                         between them is greater than this number
     *                         (distance or time). Zero (default) value means
     *                         no check is performed. The default value is
     *                         '0.0'.
     *                     <li>{@link Options#FILTER_FOLDING_PATHS
     *                         FILTER_FOLDING_PATHS}: For the {@link
     *                         SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver
     *                         only. When true (non-default), the paths per
     *                         sequence combination is checked for folding over
     *                         patterns and can significantly increase the
     *                         execution time depending on the chain width and
     *                         the number of GPS samples.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Filter out
     *                                 the folded paths.
     *                             <li>{@link Options#FALSE FALSE}: Do not
     *                                 filter out the folded paths
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#UNIT_UNLOADING_COST
     *                         UNIT_UNLOADING_COST}: For the {@link
     *                         SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} solver only. The unit cost
     *                         per load amount to be delivered. If this value
     *                         is greater than zero (default) then the
     *                         additional cost of this unit load multiplied by
     *                         the total dropped load will be added over to the
     *                         trip cost to the demand location. The default
     *                         value is '0.0'.
     *                     <li>{@link Options#MAX_NUM_THREADS MAX_NUM_THREADS}:
     *                         For the {@link SolveMethod#MARKOV_CHAIN
     *                         MARKOV_CHAIN} solver only. If specified (greater
     *                         than zero), the maximum number of threads will
     *                         not be greater than the specified value. It can
     *                         be lower due to the memory and the number cores
     *                         available. Default value of zero allows the
     *                         algorithm to set the maximal number of threads
     *                         within these constraints. The default value is
     *                         '0'.
     *                     <li>{@link Options#SERVICE_LIMIT SERVICE_LIMIT}: For
     *                         the {@link SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} solver only. If specified
     *                         (greater than zero), any supply actor's total
     *                         service cost (distance or time) will be limited
     *                         by the specified value including multiple rounds
     *                         (if set). The default value is '0.0'.
     *                     <li>{@link Options#ENABLE_REUSE ENABLE_REUSE}: For
     *                         the {@link SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} solver only. If specified
     *                         (true), all supply actors can be scheduled for
     *                         second rounds from their originating depots.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Allows
     *                                 reusing supply actors (trucks, e.g.) for
     *                                 scheduling again.
     *                             <li>{@link Options#FALSE FALSE}: Supply
     *                                 actors are scheduled only once from
     *                                 their depots.
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#MAX_STOPS MAX_STOPS}: For the
     *                         {@link SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} solver only. If specified
     *                         (greater than zero), a supply actor (truck) can
     *                         at most have this many stops (demand locations)
     *                         in one round trip. Otherwise, it is unlimited.
     *                         If 'enable_truck_reuse' is on, this condition
     *                         will be applied separately at each round trip
     *                         use of the same truck. The default value is '0'.
     *                     <li>{@link Options#SERVICE_RADIUS SERVICE_RADIUS}:
     *                         For the {@link SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} and {@link
     *                         SolveMethod#MATCH_PICKUP_DROPOFF
     *                         MATCH_PICKUP_DROPOFF} solvers only. If specified
     *                         (greater than zero), it filters the
     *                         demands/picks outside this radius centered
     *                         around the supply actor/ride's originating
     *                         location (distance or time). The default value
     *                         is '0.0'.
     *                     <li>{@link Options#PERMUTE_SUPPLIES
     *                         PERMUTE_SUPPLIES}: For the {@link
     *                         SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} solver only. If specified
     *                         (true), supply side actors are permuted for the
     *                         demand combinations during MSDO optimization -
     *                         note that this option increases optimization
     *                         time significantly - use of 'max_combinations'
     *                         option is recommended to prevent prohibitively
     *                         long runs.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Generates
     *                                 sequences over supply side permutations
     *                                 if total supply is less than twice the
     *                                 total demand
     *                             <li>{@link Options#FALSE FALSE}:
     *                                 Permutations are not performed, rather a
     *                                 specific order of supplies based on
     *                                 capacity is computed
     *                         </ul>
     *                         The default value is {@link Options#TRUE TRUE}.
     *                     <li>{@link Options#BATCH_TSM_MODE BATCH_TSM_MODE}:
     *                         For the {@link SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} solver only. When enabled,
     *                         it sets the number of visits on each demand
     *                         location by a single salesman at each trip is
     *                         considered to be (one) 1, otherwise there is no
     *                         bound.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Sets only one
     *                                 visit per demand location by a salesman
     *                                 (TSM mode)
     *                             <li>{@link Options#FALSE FALSE}: No preset
     *                                 limit (usual MSDO mode)
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#ROUND_TRIP ROUND_TRIP}: For the
     *                         {@link SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} solver only. When enabled,
     *                         the supply will have to return back to the
     *                         origination location.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: The
     *                                 optimization is done for trips in round
     *                                 trip manner always returning to
     *                                 originating locations
     *                             <li>{@link Options#FALSE FALSE}: Supplies do
     *                                 not have to come back to their
     *                                 originating locations in their routes.
     *                                 The routes are considered finished at
     *                                 the final dropoff.
     *                         </ul>
     *                         The default value is {@link Options#TRUE TRUE}.
     *                     <li>{@link Options#NUM_CYCLES NUM_CYCLES}: For the
     *                         {@link SolveMethod#MATCH_CLUSTERS
     *                         MATCH_CLUSTERS} solver only. Terminates the
     *                         cluster exchange iterations across 2-step-cycles
     *                         (outer loop) when quality does not improve
     *                         during iterations. The default value is '10'.
     *                     <li>{@link Options#NUM_LOOPS_PER_CYCLE
     *                         NUM_LOOPS_PER_CYCLE}: For the {@link
     *                         SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} and
     *                         {@link SolveMethod#MATCH_EMBEDDING
     *                         MATCH_EMBEDDING} solvers only. Terminates the
     *                         cluster exchanges within the first step
     *                         iterations of a cycle (inner loop) unless
     *                         convergence is reached. The default value is
     *                         '10'.
     *                     <li>{@link Options#NUM_OUTPUT_CLUSTERS
     *                         NUM_OUTPUT_CLUSTERS}: For the {@link
     *                         SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS}
     *                         solver only.  Limits the output to the top
     *                         'num_output_clusters' clusters based on density.
     *                         Default value of zero outputs all clusters. The
     *                         default value is '0'.
     *                     <li>{@link Options#MAX_NUM_CLUSTERS
     *                         MAX_NUM_CLUSTERS}: For the {@link
     *                         SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} and
     *                         {@link SolveMethod#MATCH_EMBEDDING
     *                         MATCH_EMBEDDING} solvers only. If set (value
     *                         greater than zero), it terminates when the
     *                         number of clusters goes below than this number.
     *                         For embedding solver the default is 8. The
     *                         default value is '0'.
     *                     <li>{@link Options#CLUSTER_QUALITY_METRIC
     *                         CLUSTER_QUALITY_METRIC}: For the {@link
     *                         SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS}
     *                         solver only. The quality metric for Louvain
     *                         modularity optimization solver.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#GIRVAN GIRVAN}: Uses the
     *                                 Newman Girvan quality metric for cluster
     *                                 solver
     *                             <li>{@link Options#SPECTRAL SPECTRAL}:
     *                                 Applies recursive spectral bisection
     *                                 (RSB) partitioning solver
     *                         </ul>
     *                         The default value is {@link Options#GIRVAN
     *                         GIRVAN}.
     *                     <li>{@link Options#RESTRICTED_TYPE RESTRICTED_TYPE}:
     *                         For the {@link SolveMethod#MATCH_SUPPLY_DEMAND
     *                         MATCH_SUPPLY_DEMAND} solver only. Optimization
     *                         is performed by restricting routes labeled by
     *                         'MSDO_ODDEVEN_RESTRICTED' only for this supply
     *                         actor (truck) type.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#ODD ODD}: Applies
     *                                 odd/even rule restrictions to odd tagged
     *                                 vehicles.
     *                             <li>{@link Options#EVEN EVEN}: Applies
     *                                 odd/even rule restrictions to even
     *                                 tagged vehicles.
     *                             <li>{@link Options#NONE NONE}: Does not
     *                                 apply odd/even rule restrictions to any
     *                                 vehicles.
     *                         </ul>
     *                         The default value is {@link Options#NONE NONE}.
     *                     <li>{@link Options#SERVER_ID SERVER_ID}: Indicates
     *                         which graph server(s) to send the request to.
     *                         Default is to send to the server, amongst those
     *                         containing the corresponding graph, that has the
     *                         most computational bandwidth. The default value
     *                         is ''.
     *                     <li>{@link Options#INVERSE_SOLVE INVERSE_SOLVE}: For
     *                         the {@link SolveMethod#MATCH_BATCH_SOLVES
     *                         MATCH_BATCH_SOLVES} solver only. Solves
     *                         source-destination pairs using inverse shortest
     *                         path solver.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Solves using
     *                                 inverse shortest path solver.
     *                             <li>{@link Options#FALSE FALSE}: Solves
     *                                 using direct shortest path solver.
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#MIN_LOOP_LEVEL MIN_LOOP_LEVEL}:
     *                         For the {@link SolveMethod#MATCH_LOOPS
     *                         MATCH_LOOPS} solver only. Finds closed loops
     *                         around each node deducible not less than this
     *                         minimal hop (level) deep. The default value is
     *                         '0'.
     *                     <li>{@link Options#MAX_LOOP_LEVEL MAX_LOOP_LEVEL}:
     *                         For the {@link SolveMethod#MATCH_LOOPS
     *                         MATCH_LOOPS} solver only. Finds closed loops
     *                         around each node deducible not more than this
     *                         maximal hop (level) deep. The default value is
     *                         '5'.
     *                     <li>{@link Options#SEARCH_LIMIT SEARCH_LIMIT}: For
     *                         the {@link SolveMethod#MATCH_LOOPS MATCH_LOOPS}
     *                         solver only. Searches within this limit of nodes
     *                         per vertex to detect loops. The value zero means
     *                         there is no limit. The default value is '10000'.
     *                     <li>{@link Options#OUTPUT_BATCH_SIZE
     *                         OUTPUT_BATCH_SIZE}: For the {@link
     *                         SolveMethod#MATCH_LOOPS MATCH_LOOPS} solver
     *                         only. Uses this value as the batch size of the
     *                         number of loops in flushing(inserting) to the
     *                         output table. The default value is '1000'.
     *                     <li>{@link Options#CHARGING_CAPACITY
     *                         CHARGING_CAPACITY}: For the {@link
     *                         SolveMethod#MATCH_CHARGING_STATIONS
     *                         MATCH_CHARGING_STATIONS} solver only. This is
     *                         the maximum ev-charging capacity of a vehicle
     *                         (distance in meters or time in seconds depending
     *                         on the unit of the graph weights). The default
     *                         value is '300000.0'.
     *                     <li>{@link Options#CHARGING_CANDIDATES
     *                         CHARGING_CANDIDATES}: For the {@link
     *                         SolveMethod#MATCH_CHARGING_STATIONS
     *                         MATCH_CHARGING_STATIONS} solver only. Solver
     *                         searches for this many number of stations
     *                         closest around each base charging location found
     *                         by capacity. The default value is '10'.
     *                     <li>{@link Options#CHARGING_PENALTY
     *                         CHARGING_PENALTY}: For the {@link
     *                         SolveMethod#MATCH_CHARGING_STATIONS
     *                         MATCH_CHARGING_STATIONS} solver only. This is
     *                         the penalty for full charging. The default value
     *                         is '30000.0'.
     *                     <li>{@link Options#MAX_HOPS MAX_HOPS}: For the
     *                         {@link SolveMethod#MATCH_SIMILARITY
     *                         MATCH_SIMILARITY} and {@link
     *                         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING}
     *                         solvers only. Searches within this maximum hops
     *                         for source and target node pairs to compute the
     *                         Jaccard scores. The default value is '3'.
     *                     <li>{@link Options#TRAVERSAL_NODE_LIMIT
     *                         TRAVERSAL_NODE_LIMIT}: For the {@link
     *                         SolveMethod#MATCH_SIMILARITY MATCH_SIMILARITY}
     *                         solver only. Limits the traversal depth if it
     *                         reaches this many number of nodes. The default
     *                         value is '1000'.
     *                     <li>{@link Options#PAIRED_SIMILARITY
     *                         PAIRED_SIMILARITY}: For the {@link
     *                         SolveMethod#MATCH_SIMILARITY MATCH_SIMILARITY}
     *                         solver only. If true, it computes Jaccard score
     *                         between each pair, otherwise it will compute
     *                         Jaccard from the intersection set between the
     *                         source and target nodes.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#TRUE TRUE}.
     *                     <li>{@link Options#FORCE_UNDIRECTED
     *                         FORCE_UNDIRECTED}: For the {@link
     *                         SolveMethod#MATCH_PATTERN MATCH_PATTERN} and
     *                         {@link SolveMethod#MATCH_EMBEDDING
     *                         MATCH_EMBEDDING} solvers only. Pattern matching
     *                         will be using both pattern and graph as
     *                         undirected if set to true.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#MAX_VECTOR_DIMENSION
     *                         MAX_VECTOR_DIMENSION}: For the {@link
     *                         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING}
     *                         solver only. Limits the number of dimensions in
     *                         node vector embeddings. The default value is
     *                         '1000'.
     *                     <li>{@link Options#OPTIMIZE_EMBEDDING_WEIGHTS
     *                         OPTIMIZE_EMBEDDING_WEIGHTS}: For the {@link
     *                         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING}
     *                         solvers only. Solves to find the optimal weights
     *                         per sub feature in vector embeddings.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#EMBEDDING_WEIGHTS
     *                         EMBEDDING_WEIGHTS}: For the {@link
     *                         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING}
     *                         solver only. User specified weights per sub
     *                         feature in vector embeddings.  The string
     *                         contains the comma separated float values for
     *                         each sub-feature in the vector space. These
     *                         values will ONLY be used if
     *                         'optimize_embedding_weights' is false. The
     *                         default value is '1.0,1.0,1.0,1.0'.
     *                     <li>{@link Options#OPTIMIZATION_SAMPLING_SIZE
     *                         OPTIMIZATION_SAMPLING_SIZE}: For the {@link
     *                         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING}
     *                         solver only. Sets the number of random nodes
     *                         from the graph for solving the weights using
     *                         stochastic gradient descent. The default value
     *                         is '1000'.
     *                     <li>{@link Options#OPTIMIZATION_MAX_ITERATIONS
     *                         OPTIMIZATION_MAX_ITERATIONS}: For the {@link
     *                         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING}
     *                         solver only. When the iterations (epochs) for
     *                         the convergence of the stochastic gradient
     *                         descent algorithm  reaches this number it bails
     *                         out unless relative error between consecutive
     *                         iterations is below the
     *                         'optimization_error_tolerance' option. The
     *                         default value is '1000'.
     *                     <li>{@link Options#OPTIMIZATION_ERROR_TOLERANCE
     *                         OPTIMIZATION_ERROR_TOLERANCE}: For the {@link
     *                         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING}
     *                         solver only. When the relative error between all
     *                         of the weights' consecutive iterations falls
     *                         below this threshold  the optimization cycle is
     *                         interrupted unless the number of iterations
     *                         reaches the limit set by the option
     *                         'max_optimization_iterations'. The default value
     *                         is '0.001'.
     *                     <li>{@link Options#OPTIMIZATION_ITERATION_RATE
     *                         OPTIMIZATION_ITERATION_RATE}: For the {@link
     *                         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING}
     *                         solver only. It is otherwise known as the
     *                         learning rate, which is the proportionality
     *                         constant in front of the gradient term in
     *                         successive iterations. The default value is
     *                         '0.3'.
     *                     <li>{@link Options#MAX_RADIUS MAX_RADIUS}: For the
     *                         {@link SolveMethod#MATCH_ISOCHRONE
     *                         MATCH_ISOCHRONE} solver only. Sets the maximal
     *                         reachability limit for computing isochrones.
     *                         Zero means no limit. The default value is '0.0'.
     *                 </ul>
     *                 The default value is an empty {@link Map}.
     */
    public MatchGraphRequest(String graphName, List<String> samplePoints, String solveMethod, String solutionTable, Map<String, String> options) {
        this.graphName = (graphName == null) ? "" : graphName;
        this.samplePoints = (samplePoints == null) ? new ArrayList<String>() : samplePoints;
        this.solveMethod = (solveMethod == null) ? "" : solveMethod;
        this.solutionTable = (solutionTable == null) ? "" : solutionTable;
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
    }

    /**
     * Name of the underlying geospatial graph resource to match to using
     * {@link #getSamplePoints() samplePoints}.
     *
     * @return The current value of {@code graphName}.
     */
    public String getGraphName() {
        return graphName;
    }

    /**
     * Name of the underlying geospatial graph resource to match to using
     * {@link #getSamplePoints() samplePoints}.
     *
     * @param graphName  The new value for {@code graphName}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public MatchGraphRequest setGraphName(String graphName) {
        this.graphName = (graphName == null) ? "" : graphName;
        return this;
    }

    /**
     * Sample points used to match to an underlying geospatial graph. Sample
     * points must be specified using <a
     * href="../../../../../../graph_solver/network_graph_solver/#match-identifiers"
     * target="_top">identifiers</a>; identifiers are grouped as <a
     * href="../../../../../../graph_solver/network_graph_solver/#match-combinations"
     * target="_top">combinations</a>. Identifiers can be used with: existing
     * column names, e.g., 'table.column AS SAMPLE_X'; expressions, e.g.,
     * 'ST_MAKEPOINT(table.x, table.y) AS SAMPLE_WKTPOINT'; or constant values,
     * e.g., '{1, 2, 10} AS SAMPLE_TRIPID'.
     *
     * @return The current value of {@code samplePoints}.
     */
    public List<String> getSamplePoints() {
        return samplePoints;
    }

    /**
     * Sample points used to match to an underlying geospatial graph. Sample
     * points must be specified using <a
     * href="../../../../../../graph_solver/network_graph_solver/#match-identifiers"
     * target="_top">identifiers</a>; identifiers are grouped as <a
     * href="../../../../../../graph_solver/network_graph_solver/#match-combinations"
     * target="_top">combinations</a>. Identifiers can be used with: existing
     * column names, e.g., 'table.column AS SAMPLE_X'; expressions, e.g.,
     * 'ST_MAKEPOINT(table.x, table.y) AS SAMPLE_WKTPOINT'; or constant values,
     * e.g., '{1, 2, 10} AS SAMPLE_TRIPID'.
     *
     * @param samplePoints  The new value for {@code samplePoints}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public MatchGraphRequest setSamplePoints(List<String> samplePoints) {
        this.samplePoints = (samplePoints == null) ? new ArrayList<String>() : samplePoints;
        return this;
    }

    /**
     * The type of solver to use for graph matching.
     * Supported values:
     * <ul>
     *     <li>{@link SolveMethod#MARKOV_CHAIN MARKOV_CHAIN}: Matches {@link
     *         #getSamplePoints() samplePoints} to the graph using the Hidden
     *         Markov Model (HMM)-based method, which conducts a range-tree
     *         closest-edge search to find the best combinations of possible
     *         road segments ({@link Options#NUM_SEGMENTS NUM_SEGMENTS}) for
     *         each sample point to create the best route. The route is secured
     *         one point at a time while looking ahead {@link
     *         Options#CHAIN_WIDTH CHAIN_WIDTH} number of points, so the
     *         prediction is corrected after each point. This solution type is
     *         the most accurate but also the most computationally intensive.
     *         Related options: {@link Options#NUM_SEGMENTS NUM_SEGMENTS} and
     *         {@link Options#CHAIN_WIDTH CHAIN_WIDTH}.
     *     <li>{@link SolveMethod#MATCH_OD_PAIRS MATCH_OD_PAIRS}: Matches
     *         {@link #getSamplePoints() samplePoints} to find the most
     *         probable path between origin and destination pairs with cost
     *         constraints.
     *     <li>{@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}:
     *         Matches {@link #getSamplePoints() samplePoints} to optimize
     *         scheduling multiple supplies (trucks) with varying sizes to
     *         varying demand sites with varying capacities per depot. Related
     *         options: {@link Options#PARTIAL_LOADING PARTIAL_LOADING} and
     *         {@link Options#MAX_COMBINATIONS MAX_COMBINATIONS}.
     *     <li>{@link SolveMethod#MATCH_BATCH_SOLVES MATCH_BATCH_SOLVES}:
     *         Matches {@link #getSamplePoints() samplePoints} source and
     *         destination pairs for the shortest path solves in batch mode.
     *     <li>{@link SolveMethod#MATCH_LOOPS MATCH_LOOPS}: Matches closed
     *         loops (Eulerian paths) originating and ending at each graph node
     *         within min and max hops (levels).
     *     <li>{@link SolveMethod#MATCH_CHARGING_STATIONS
     *         MATCH_CHARGING_STATIONS}: Matches an optimal path across a
     *         number of ev-charging stations between source and target
     *         locations.
     *     <li>{@link SolveMethod#MATCH_SIMILARITY MATCH_SIMILARITY}: Matches
     *         the intersection set(s) by computing the Jaccard similarity
     *         score between node pairs.
     *     <li>{@link SolveMethod#MATCH_PICKUP_DROPOFF MATCH_PICKUP_DROPOFF}:
     *         Matches the pickups and dropoffs by optimizing the total trip
     *         costs
     *     <li>{@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS}: Matches the
     *         graph nodes with a cluster index using Louvain clustering
     *         algorithm
     *     <li>{@link SolveMethod#MATCH_PATTERN MATCH_PATTERN}: Matches a
     *         pattern in the graph
     *     <li>{@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING}: Creates
     *         vector node embeddings
     *     <li>{@link SolveMethod#MATCH_ISOCHRONE MATCH_ISOCHRONE}: Solves for
     *         isochrones for a set of input sources
     * </ul>
     * The default value is {@link SolveMethod#MARKOV_CHAIN MARKOV_CHAIN}.
     *
     * @return The current value of {@code solveMethod}.
     */
    public String getSolveMethod() {
        return solveMethod;
    }

    /**
     * The type of solver to use for graph matching.
     * Supported values:
     * <ul>
     *     <li>{@link SolveMethod#MARKOV_CHAIN MARKOV_CHAIN}: Matches {@link
     *         #getSamplePoints() samplePoints} to the graph using the Hidden
     *         Markov Model (HMM)-based method, which conducts a range-tree
     *         closest-edge search to find the best combinations of possible
     *         road segments ({@link Options#NUM_SEGMENTS NUM_SEGMENTS}) for
     *         each sample point to create the best route. The route is secured
     *         one point at a time while looking ahead {@link
     *         Options#CHAIN_WIDTH CHAIN_WIDTH} number of points, so the
     *         prediction is corrected after each point. This solution type is
     *         the most accurate but also the most computationally intensive.
     *         Related options: {@link Options#NUM_SEGMENTS NUM_SEGMENTS} and
     *         {@link Options#CHAIN_WIDTH CHAIN_WIDTH}.
     *     <li>{@link SolveMethod#MATCH_OD_PAIRS MATCH_OD_PAIRS}: Matches
     *         {@link #getSamplePoints() samplePoints} to find the most
     *         probable path between origin and destination pairs with cost
     *         constraints.
     *     <li>{@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}:
     *         Matches {@link #getSamplePoints() samplePoints} to optimize
     *         scheduling multiple supplies (trucks) with varying sizes to
     *         varying demand sites with varying capacities per depot. Related
     *         options: {@link Options#PARTIAL_LOADING PARTIAL_LOADING} and
     *         {@link Options#MAX_COMBINATIONS MAX_COMBINATIONS}.
     *     <li>{@link SolveMethod#MATCH_BATCH_SOLVES MATCH_BATCH_SOLVES}:
     *         Matches {@link #getSamplePoints() samplePoints} source and
     *         destination pairs for the shortest path solves in batch mode.
     *     <li>{@link SolveMethod#MATCH_LOOPS MATCH_LOOPS}: Matches closed
     *         loops (Eulerian paths) originating and ending at each graph node
     *         within min and max hops (levels).
     *     <li>{@link SolveMethod#MATCH_CHARGING_STATIONS
     *         MATCH_CHARGING_STATIONS}: Matches an optimal path across a
     *         number of ev-charging stations between source and target
     *         locations.
     *     <li>{@link SolveMethod#MATCH_SIMILARITY MATCH_SIMILARITY}: Matches
     *         the intersection set(s) by computing the Jaccard similarity
     *         score between node pairs.
     *     <li>{@link SolveMethod#MATCH_PICKUP_DROPOFF MATCH_PICKUP_DROPOFF}:
     *         Matches the pickups and dropoffs by optimizing the total trip
     *         costs
     *     <li>{@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS}: Matches the
     *         graph nodes with a cluster index using Louvain clustering
     *         algorithm
     *     <li>{@link SolveMethod#MATCH_PATTERN MATCH_PATTERN}: Matches a
     *         pattern in the graph
     *     <li>{@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING}: Creates
     *         vector node embeddings
     *     <li>{@link SolveMethod#MATCH_ISOCHRONE MATCH_ISOCHRONE}: Solves for
     *         isochrones for a set of input sources
     * </ul>
     * The default value is {@link SolveMethod#MARKOV_CHAIN MARKOV_CHAIN}.
     *
     * @param solveMethod  The new value for {@code solveMethod}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public MatchGraphRequest setSolveMethod(String solveMethod) {
        this.solveMethod = (solveMethod == null) ? "" : solveMethod;
        return this;
    }

    /**
     * The name of the table used to store the results, in
     * [schema_name.]table_name format, using standard <a
     * href="../../../../../../concepts/tables/#table-name-resolution"
     * target="_top">name resolution rules</a> and meeting <a
     * href="../../../../../../concepts/tables/#table-naming-criteria"
     * target="_top">table naming criteria</a>.  This table contains a <a
     * href="../../../../../../location_intelligence/geo_objects/#geospatial-tracks"
     * target="_top">track</a> of geospatial points for the matched portion of
     * the graph, a track ID, and a score value. Also outputs a details table
     * containing a trip ID (that matches the track ID), the latitude/longitude
     * pair, the timestamp the point was recorded at, and an edge ID
     * corresponding to the matched road segment. Must not be an existing table
     * of the same name. The default value is ''.
     *
     * @return The current value of {@code solutionTable}.
     */
    public String getSolutionTable() {
        return solutionTable;
    }

    /**
     * The name of the table used to store the results, in
     * [schema_name.]table_name format, using standard <a
     * href="../../../../../../concepts/tables/#table-name-resolution"
     * target="_top">name resolution rules</a> and meeting <a
     * href="../../../../../../concepts/tables/#table-naming-criteria"
     * target="_top">table naming criteria</a>.  This table contains a <a
     * href="../../../../../../location_intelligence/geo_objects/#geospatial-tracks"
     * target="_top">track</a> of geospatial points for the matched portion of
     * the graph, a track ID, and a score value. Also outputs a details table
     * containing a trip ID (that matches the track ID), the latitude/longitude
     * pair, the timestamp the point was recorded at, and an edge ID
     * corresponding to the matched road segment. Must not be an existing table
     * of the same name. The default value is ''.
     *
     * @param solutionTable  The new value for {@code solutionTable}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public MatchGraphRequest setSolutionTable(String solutionTable) {
        this.solutionTable = (solutionTable == null) ? "" : solutionTable;
        return this;
    }

    /**
     * Additional parameters.
     * <ul>
     *     <li>{@link Options#GPS_NOISE GPS_NOISE}: GPS noise value (in meters)
     *         to remove redundant sample points. Use -1 to disable noise
     *         reduction. The default value accounts for 95% of point variation
     *         (+ or -5 meters). The default value is '5.0'.
     *     <li>{@link Options#NUM_SEGMENTS NUM_SEGMENTS}: Maximum number of
     *         potentially matching road segments for each sample point. For
     *         the {@link SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver, the
     *         default is 3. The default value is '3'.
     *     <li>{@link Options#SEARCH_RADIUS SEARCH_RADIUS}: Maximum search
     *         radius used when snapping sample points onto potentially
     *         matching surrounding segments. The default value corresponds to
     *         approximately 100 meters. The default value is '0.001'.
     *     <li>{@link Options#CHAIN_WIDTH CHAIN_WIDTH}: For the {@link
     *         SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver only. Length of
     *         the sample points lookahead window within the Markov kernel; the
     *         larger the number, the more accurate the solution. The default
     *         value is '9'.
     *     <li>{@link Options#SOURCE SOURCE}: Optional WKT starting point from
     *         {@link #getSamplePoints() samplePoints} for the solver. The
     *         default behavior for the endpoint is to use time to determine
     *         the starting point. The default value is 'POINT NULL'.
     *     <li>{@link Options#DESTINATION DESTINATION}: Optional WKT ending
     *         point from {@link #getSamplePoints() samplePoints} for the
     *         solver. The default behavior for the endpoint is to use time to
     *         determine the destination point. The default value is 'POINT
     *         NULL'.
     *     <li>{@link Options#PARTIAL_LOADING PARTIAL_LOADING}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. When false (non-default), trucks do not off-load at the
     *         demand (store) side if the remainder is less than the store's
     *         need.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Partial off-loading at
     *                 multiple store (demand) locations
     *             <li>{@link Options#FALSE FALSE}: No partial off-loading
     *                 allowed if supply is less than the store's demand.
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#MAX_COMBINATIONS MAX_COMBINATIONS}: For the
     *         {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
     *         solver only. This is the cutoff for the number of generated
     *         combinations for sequencing the demand locations - can increase
     *         this up to 2M. The default value is '10000'.
     *     <li>{@link Options#MAX_SUPPLY_COMBINATIONS MAX_SUPPLY_COMBINATIONS}:
     *         For the {@link SolveMethod#MATCH_SUPPLY_DEMAND
     *         MATCH_SUPPLY_DEMAND} solver only. This is the cutoff for the
     *         number of generated combinations for sequencing the supply
     *         locations if/when 'permute_supplies' is true. The default value
     *         is '10000'.
     *     <li>{@link Options#LEFT_TURN_PENALTY LEFT_TURN_PENALTY}: This will
     *         add an additional weight over the edges labeled as 'left turn'
     *         if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#RIGHT_TURN_PENALTY RIGHT_TURN_PENALTY}: This will
     *         add an additional weight over the edges labeled as' right turn'
     *         if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#INTERSECTION_PENALTY INTERSECTION_PENALTY}: This
     *         will add an additional weight over the edges labeled as
     *         'intersection' if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#SHARP_TURN_PENALTY SHARP_TURN_PENALTY}: This will
     *         add an additional weight over the edges labeled as 'sharp turn'
     *         or 'u-turn' if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#AGGREGATED_OUTPUT AGGREGATED_OUTPUT}: For the
     *         {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
     *         solver only. When it is true (default), each record in the
     *         output table shows a particular truck's scheduled cumulative
     *         round trip path (MULTILINESTRING) and the corresponding
     *         aggregated cost. Otherwise, each record shows a single scheduled
     *         truck route (LINESTRING) towards a particular demand location
     *         (store id) with its corresponding cost. The default value is
     *         'true'.
     *     <li>{@link Options#OUTPUT_TRACKS OUTPUT_TRACKS}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. When it is true (non-default), the output will be in
     *         tracks format for all the round trips of each truck in which the
     *         timestamps are populated directly from the edge weights starting
     *         from their originating depots. The default value is 'false'.
     *     <li>{@link Options#MAX_TRIP_COST MAX_TRIP_COST}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} and {@link
     *         SolveMethod#MATCH_PICKUP_DROPOFF MATCH_PICKUP_DROPOFF} solvers
     *         only. If this constraint is greater than zero (default) then the
     *         trucks/rides will skip traveling from one demand/pick location
     *         to another if the cost between them is greater than this number
     *         (distance or time). Zero (default) value means no check is
     *         performed. The default value is '0.0'.
     *     <li>{@link Options#FILTER_FOLDING_PATHS FILTER_FOLDING_PATHS}: For
     *         the {@link SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver only.
     *         When true (non-default), the paths per sequence combination is
     *         checked for folding over patterns and can significantly increase
     *         the execution time depending on the chain width and the number
     *         of GPS samples.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Filter out the folded paths.
     *             <li>{@link Options#FALSE FALSE}: Do not filter out the
     *                 folded paths
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#UNIT_UNLOADING_COST UNIT_UNLOADING_COST}: For the
     *         {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
     *         solver only. The unit cost per load amount to be delivered. If
     *         this value is greater than zero (default) then the additional
     *         cost of this unit load multiplied by the total dropped load will
     *         be added over to the trip cost to the demand location. The
     *         default value is '0.0'.
     *     <li>{@link Options#MAX_NUM_THREADS MAX_NUM_THREADS}: For the {@link
     *         SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver only. If specified
     *         (greater than zero), the maximum number of threads will not be
     *         greater than the specified value. It can be lower due to the
     *         memory and the number cores available. Default value of zero
     *         allows the algorithm to set the maximal number of threads within
     *         these constraints. The default value is '0'.
     *     <li>{@link Options#SERVICE_LIMIT SERVICE_LIMIT}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. If specified (greater than zero), any supply actor's total
     *         service cost (distance or time) will be limited by the specified
     *         value including multiple rounds (if set). The default value is
     *         '0.0'.
     *     <li>{@link Options#ENABLE_REUSE ENABLE_REUSE}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. If specified (true), all supply actors can be scheduled
     *         for second rounds from their originating depots.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Allows reusing supply actors
     *                 (trucks, e.g.) for scheduling again.
     *             <li>{@link Options#FALSE FALSE}: Supply actors are scheduled
     *                 only once from their depots.
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#MAX_STOPS MAX_STOPS}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. If specified (greater than zero), a supply actor (truck)
     *         can at most have this many stops (demand locations) in one round
     *         trip. Otherwise, it is unlimited. If 'enable_truck_reuse' is on,
     *         this condition will be applied separately at each round trip use
     *         of the same truck. The default value is '0'.
     *     <li>{@link Options#SERVICE_RADIUS SERVICE_RADIUS}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} and {@link
     *         SolveMethod#MATCH_PICKUP_DROPOFF MATCH_PICKUP_DROPOFF} solvers
     *         only. If specified (greater than zero), it filters the
     *         demands/picks outside this radius centered around the supply
     *         actor/ride's originating location (distance or time). The
     *         default value is '0.0'.
     *     <li>{@link Options#PERMUTE_SUPPLIES PERMUTE_SUPPLIES}: For the
     *         {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
     *         solver only. If specified (true), supply side actors are
     *         permuted for the demand combinations during MSDO optimization -
     *         note that this option increases optimization time significantly
     *         - use of 'max_combinations' option is recommended to prevent
     *         prohibitively long runs.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Generates sequences over
     *                 supply side permutations if total supply is less than
     *                 twice the total demand
     *             <li>{@link Options#FALSE FALSE}: Permutations are not
     *                 performed, rather a specific order of supplies based on
     *                 capacity is computed
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#BATCH_TSM_MODE BATCH_TSM_MODE}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. When enabled, it sets the number of visits on each demand
     *         location by a single salesman at each trip is considered to be
     *         (one) 1, otherwise there is no bound.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Sets only one visit per
     *                 demand location by a salesman (TSM mode)
     *             <li>{@link Options#FALSE FALSE}: No preset limit (usual MSDO
     *                 mode)
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#ROUND_TRIP ROUND_TRIP}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. When enabled, the supply will have to return back to the
     *         origination location.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: The optimization is done for
     *                 trips in round trip manner always returning to
     *                 originating locations
     *             <li>{@link Options#FALSE FALSE}: Supplies do not have to
     *                 come back to their originating locations in their
     *                 routes. The routes are considered finished at the final
     *                 dropoff.
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#NUM_CYCLES NUM_CYCLES}: For the {@link
     *         SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} solver only.
     *         Terminates the cluster exchange iterations across 2-step-cycles
     *         (outer loop) when quality does not improve during iterations.
     *         The default value is '10'.
     *     <li>{@link Options#NUM_LOOPS_PER_CYCLE NUM_LOOPS_PER_CYCLE}: For the
     *         {@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} and {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only.
     *         Terminates the cluster exchanges within the first step
     *         iterations of a cycle (inner loop) unless convergence is
     *         reached. The default value is '10'.
     *     <li>{@link Options#NUM_OUTPUT_CLUSTERS NUM_OUTPUT_CLUSTERS}: For the
     *         {@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} solver only.
     *         Limits the output to the top 'num_output_clusters' clusters
     *         based on density. Default value of zero outputs all clusters.
     *         The default value is '0'.
     *     <li>{@link Options#MAX_NUM_CLUSTERS MAX_NUM_CLUSTERS}: For the
     *         {@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} and {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only. If
     *         set (value greater than zero), it terminates when the number of
     *         clusters goes below than this number. For embedding solver the
     *         default is 8. The default value is '0'.
     *     <li>{@link Options#CLUSTER_QUALITY_METRIC CLUSTER_QUALITY_METRIC}:
     *         For the {@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} solver
     *         only. The quality metric for Louvain modularity optimization
     *         solver.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#GIRVAN GIRVAN}: Uses the Newman Girvan
     *                 quality metric for cluster solver
     *             <li>{@link Options#SPECTRAL SPECTRAL}: Applies recursive
     *                 spectral bisection (RSB) partitioning solver
     *         </ul>
     *         The default value is {@link Options#GIRVAN GIRVAN}.
     *     <li>{@link Options#RESTRICTED_TYPE RESTRICTED_TYPE}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. Optimization is performed by restricting routes labeled by
     *         'MSDO_ODDEVEN_RESTRICTED' only for this supply actor (truck)
     *         type.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#ODD ODD}: Applies odd/even rule
     *                 restrictions to odd tagged vehicles.
     *             <li>{@link Options#EVEN EVEN}: Applies odd/even rule
     *                 restrictions to even tagged vehicles.
     *             <li>{@link Options#NONE NONE}: Does not apply odd/even rule
     *                 restrictions to any vehicles.
     *         </ul>
     *         The default value is {@link Options#NONE NONE}.
     *     <li>{@link Options#SERVER_ID SERVER_ID}: Indicates which graph
     *         server(s) to send the request to. Default is to send to the
     *         server, amongst those containing the corresponding graph, that
     *         has the most computational bandwidth. The default value is ''.
     *     <li>{@link Options#INVERSE_SOLVE INVERSE_SOLVE}: For the {@link
     *         SolveMethod#MATCH_BATCH_SOLVES MATCH_BATCH_SOLVES} solver only.
     *         Solves source-destination pairs using inverse shortest path
     *         solver.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Solves using inverse shortest
     *                 path solver.
     *             <li>{@link Options#FALSE FALSE}: Solves using direct
     *                 shortest path solver.
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#MIN_LOOP_LEVEL MIN_LOOP_LEVEL}: For the {@link
     *         SolveMethod#MATCH_LOOPS MATCH_LOOPS} solver only. Finds closed
     *         loops around each node deducible not less than this minimal hop
     *         (level) deep. The default value is '0'.
     *     <li>{@link Options#MAX_LOOP_LEVEL MAX_LOOP_LEVEL}: For the {@link
     *         SolveMethod#MATCH_LOOPS MATCH_LOOPS} solver only. Finds closed
     *         loops around each node deducible not more than this maximal hop
     *         (level) deep. The default value is '5'.
     *     <li>{@link Options#SEARCH_LIMIT SEARCH_LIMIT}: For the {@link
     *         SolveMethod#MATCH_LOOPS MATCH_LOOPS} solver only. Searches
     *         within this limit of nodes per vertex to detect loops. The value
     *         zero means there is no limit. The default value is '10000'.
     *     <li>{@link Options#OUTPUT_BATCH_SIZE OUTPUT_BATCH_SIZE}: For the
     *         {@link SolveMethod#MATCH_LOOPS MATCH_LOOPS} solver only. Uses
     *         this value as the batch size of the number of loops in
     *         flushing(inserting) to the output table. The default value is
     *         '1000'.
     *     <li>{@link Options#CHARGING_CAPACITY CHARGING_CAPACITY}: For the
     *         {@link SolveMethod#MATCH_CHARGING_STATIONS
     *         MATCH_CHARGING_STATIONS} solver only. This is the maximum
     *         ev-charging capacity of a vehicle (distance in meters or time in
     *         seconds depending on the unit of the graph weights). The default
     *         value is '300000.0'.
     *     <li>{@link Options#CHARGING_CANDIDATES CHARGING_CANDIDATES}: For the
     *         {@link SolveMethod#MATCH_CHARGING_STATIONS
     *         MATCH_CHARGING_STATIONS} solver only. Solver searches for this
     *         many number of stations closest around each base charging
     *         location found by capacity. The default value is '10'.
     *     <li>{@link Options#CHARGING_PENALTY CHARGING_PENALTY}: For the
     *         {@link SolveMethod#MATCH_CHARGING_STATIONS
     *         MATCH_CHARGING_STATIONS} solver only. This is the penalty for
     *         full charging. The default value is '30000.0'.
     *     <li>{@link Options#MAX_HOPS MAX_HOPS}: For the {@link
     *         SolveMethod#MATCH_SIMILARITY MATCH_SIMILARITY} and {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only.
     *         Searches within this maximum hops for source and target node
     *         pairs to compute the Jaccard scores. The default value is '3'.
     *     <li>{@link Options#TRAVERSAL_NODE_LIMIT TRAVERSAL_NODE_LIMIT}: For
     *         the {@link SolveMethod#MATCH_SIMILARITY MATCH_SIMILARITY} solver
     *         only. Limits the traversal depth if it reaches this many number
     *         of nodes. The default value is '1000'.
     *     <li>{@link Options#PAIRED_SIMILARITY PAIRED_SIMILARITY}: For the
     *         {@link SolveMethod#MATCH_SIMILARITY MATCH_SIMILARITY} solver
     *         only. If true, it computes Jaccard score between each pair,
     *         otherwise it will compute Jaccard from the intersection set
     *         between the source and target nodes.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#FORCE_UNDIRECTED FORCE_UNDIRECTED}: For the
     *         {@link SolveMethod#MATCH_PATTERN MATCH_PATTERN} and {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only.
     *         Pattern matching will be using both pattern and graph as
     *         undirected if set to true.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#MAX_VECTOR_DIMENSION MAX_VECTOR_DIMENSION}: For
     *         the {@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver
     *         only. Limits the number of dimensions in node vector embeddings.
     *         The default value is '1000'.
     *     <li>{@link Options#OPTIMIZE_EMBEDDING_WEIGHTS
     *         OPTIMIZE_EMBEDDING_WEIGHTS}: For the {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only.
     *         Solves to find the optimal weights per sub feature in vector
     *         embeddings.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#EMBEDDING_WEIGHTS EMBEDDING_WEIGHTS}: For the
     *         {@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver only.
     *         User specified weights per sub feature in vector embeddings.
     *         The string contains the comma separated float values for each
     *         sub-feature in the vector space. These values will ONLY be used
     *         if 'optimize_embedding_weights' is false. The default value is
     *         '1.0,1.0,1.0,1.0'.
     *     <li>{@link Options#OPTIMIZATION_SAMPLING_SIZE
     *         OPTIMIZATION_SAMPLING_SIZE}: For the {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver only. Sets
     *         the number of random nodes from the graph for solving the
     *         weights using stochastic gradient descent. The default value is
     *         '1000'.
     *     <li>{@link Options#OPTIMIZATION_MAX_ITERATIONS
     *         OPTIMIZATION_MAX_ITERATIONS}: For the {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver only. When
     *         the iterations (epochs) for the convergence of the stochastic
     *         gradient descent algorithm  reaches this number it bails out
     *         unless relative error between consecutive iterations is below
     *         the 'optimization_error_tolerance' option. The default value is
     *         '1000'.
     *     <li>{@link Options#OPTIMIZATION_ERROR_TOLERANCE
     *         OPTIMIZATION_ERROR_TOLERANCE}: For the {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver only. When
     *         the relative error between all of the weights' consecutive
     *         iterations falls below this threshold  the optimization cycle is
     *         interrupted unless the number of iterations reaches the limit
     *         set by the option 'max_optimization_iterations'. The default
     *         value is '0.001'.
     *     <li>{@link Options#OPTIMIZATION_ITERATION_RATE
     *         OPTIMIZATION_ITERATION_RATE}: For the {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver only. It is
     *         otherwise known as the learning rate, which is the
     *         proportionality constant in front of the gradient term in
     *         successive iterations. The default value is '0.3'.
     *     <li>{@link Options#MAX_RADIUS MAX_RADIUS}: For the {@link
     *         SolveMethod#MATCH_ISOCHRONE MATCH_ISOCHRONE} solver only. Sets
     *         the maximal reachability limit for computing isochrones. Zero
     *         means no limit. The default value is '0.0'.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @return The current value of {@code options}.
     */
    public Map<String, String> getOptions() {
        return options;
    }

    /**
     * Additional parameters.
     * <ul>
     *     <li>{@link Options#GPS_NOISE GPS_NOISE}: GPS noise value (in meters)
     *         to remove redundant sample points. Use -1 to disable noise
     *         reduction. The default value accounts for 95% of point variation
     *         (+ or -5 meters). The default value is '5.0'.
     *     <li>{@link Options#NUM_SEGMENTS NUM_SEGMENTS}: Maximum number of
     *         potentially matching road segments for each sample point. For
     *         the {@link SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver, the
     *         default is 3. The default value is '3'.
     *     <li>{@link Options#SEARCH_RADIUS SEARCH_RADIUS}: Maximum search
     *         radius used when snapping sample points onto potentially
     *         matching surrounding segments. The default value corresponds to
     *         approximately 100 meters. The default value is '0.001'.
     *     <li>{@link Options#CHAIN_WIDTH CHAIN_WIDTH}: For the {@link
     *         SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver only. Length of
     *         the sample points lookahead window within the Markov kernel; the
     *         larger the number, the more accurate the solution. The default
     *         value is '9'.
     *     <li>{@link Options#SOURCE SOURCE}: Optional WKT starting point from
     *         {@link #getSamplePoints() samplePoints} for the solver. The
     *         default behavior for the endpoint is to use time to determine
     *         the starting point. The default value is 'POINT NULL'.
     *     <li>{@link Options#DESTINATION DESTINATION}: Optional WKT ending
     *         point from {@link #getSamplePoints() samplePoints} for the
     *         solver. The default behavior for the endpoint is to use time to
     *         determine the destination point. The default value is 'POINT
     *         NULL'.
     *     <li>{@link Options#PARTIAL_LOADING PARTIAL_LOADING}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. When false (non-default), trucks do not off-load at the
     *         demand (store) side if the remainder is less than the store's
     *         need.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Partial off-loading at
     *                 multiple store (demand) locations
     *             <li>{@link Options#FALSE FALSE}: No partial off-loading
     *                 allowed if supply is less than the store's demand.
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#MAX_COMBINATIONS MAX_COMBINATIONS}: For the
     *         {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
     *         solver only. This is the cutoff for the number of generated
     *         combinations for sequencing the demand locations - can increase
     *         this up to 2M. The default value is '10000'.
     *     <li>{@link Options#MAX_SUPPLY_COMBINATIONS MAX_SUPPLY_COMBINATIONS}:
     *         For the {@link SolveMethod#MATCH_SUPPLY_DEMAND
     *         MATCH_SUPPLY_DEMAND} solver only. This is the cutoff for the
     *         number of generated combinations for sequencing the supply
     *         locations if/when 'permute_supplies' is true. The default value
     *         is '10000'.
     *     <li>{@link Options#LEFT_TURN_PENALTY LEFT_TURN_PENALTY}: This will
     *         add an additional weight over the edges labeled as 'left turn'
     *         if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#RIGHT_TURN_PENALTY RIGHT_TURN_PENALTY}: This will
     *         add an additional weight over the edges labeled as' right turn'
     *         if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#INTERSECTION_PENALTY INTERSECTION_PENALTY}: This
     *         will add an additional weight over the edges labeled as
     *         'intersection' if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#SHARP_TURN_PENALTY SHARP_TURN_PENALTY}: This will
     *         add an additional weight over the edges labeled as 'sharp turn'
     *         or 'u-turn' if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#AGGREGATED_OUTPUT AGGREGATED_OUTPUT}: For the
     *         {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
     *         solver only. When it is true (default), each record in the
     *         output table shows a particular truck's scheduled cumulative
     *         round trip path (MULTILINESTRING) and the corresponding
     *         aggregated cost. Otherwise, each record shows a single scheduled
     *         truck route (LINESTRING) towards a particular demand location
     *         (store id) with its corresponding cost. The default value is
     *         'true'.
     *     <li>{@link Options#OUTPUT_TRACKS OUTPUT_TRACKS}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. When it is true (non-default), the output will be in
     *         tracks format for all the round trips of each truck in which the
     *         timestamps are populated directly from the edge weights starting
     *         from their originating depots. The default value is 'false'.
     *     <li>{@link Options#MAX_TRIP_COST MAX_TRIP_COST}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} and {@link
     *         SolveMethod#MATCH_PICKUP_DROPOFF MATCH_PICKUP_DROPOFF} solvers
     *         only. If this constraint is greater than zero (default) then the
     *         trucks/rides will skip traveling from one demand/pick location
     *         to another if the cost between them is greater than this number
     *         (distance or time). Zero (default) value means no check is
     *         performed. The default value is '0.0'.
     *     <li>{@link Options#FILTER_FOLDING_PATHS FILTER_FOLDING_PATHS}: For
     *         the {@link SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver only.
     *         When true (non-default), the paths per sequence combination is
     *         checked for folding over patterns and can significantly increase
     *         the execution time depending on the chain width and the number
     *         of GPS samples.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Filter out the folded paths.
     *             <li>{@link Options#FALSE FALSE}: Do not filter out the
     *                 folded paths
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#UNIT_UNLOADING_COST UNIT_UNLOADING_COST}: For the
     *         {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
     *         solver only. The unit cost per load amount to be delivered. If
     *         this value is greater than zero (default) then the additional
     *         cost of this unit load multiplied by the total dropped load will
     *         be added over to the trip cost to the demand location. The
     *         default value is '0.0'.
     *     <li>{@link Options#MAX_NUM_THREADS MAX_NUM_THREADS}: For the {@link
     *         SolveMethod#MARKOV_CHAIN MARKOV_CHAIN} solver only. If specified
     *         (greater than zero), the maximum number of threads will not be
     *         greater than the specified value. It can be lower due to the
     *         memory and the number cores available. Default value of zero
     *         allows the algorithm to set the maximal number of threads within
     *         these constraints. The default value is '0'.
     *     <li>{@link Options#SERVICE_LIMIT SERVICE_LIMIT}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. If specified (greater than zero), any supply actor's total
     *         service cost (distance or time) will be limited by the specified
     *         value including multiple rounds (if set). The default value is
     *         '0.0'.
     *     <li>{@link Options#ENABLE_REUSE ENABLE_REUSE}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. If specified (true), all supply actors can be scheduled
     *         for second rounds from their originating depots.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Allows reusing supply actors
     *                 (trucks, e.g.) for scheduling again.
     *             <li>{@link Options#FALSE FALSE}: Supply actors are scheduled
     *                 only once from their depots.
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#MAX_STOPS MAX_STOPS}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. If specified (greater than zero), a supply actor (truck)
     *         can at most have this many stops (demand locations) in one round
     *         trip. Otherwise, it is unlimited. If 'enable_truck_reuse' is on,
     *         this condition will be applied separately at each round trip use
     *         of the same truck. The default value is '0'.
     *     <li>{@link Options#SERVICE_RADIUS SERVICE_RADIUS}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} and {@link
     *         SolveMethod#MATCH_PICKUP_DROPOFF MATCH_PICKUP_DROPOFF} solvers
     *         only. If specified (greater than zero), it filters the
     *         demands/picks outside this radius centered around the supply
     *         actor/ride's originating location (distance or time). The
     *         default value is '0.0'.
     *     <li>{@link Options#PERMUTE_SUPPLIES PERMUTE_SUPPLIES}: For the
     *         {@link SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND}
     *         solver only. If specified (true), supply side actors are
     *         permuted for the demand combinations during MSDO optimization -
     *         note that this option increases optimization time significantly
     *         - use of 'max_combinations' option is recommended to prevent
     *         prohibitively long runs.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Generates sequences over
     *                 supply side permutations if total supply is less than
     *                 twice the total demand
     *             <li>{@link Options#FALSE FALSE}: Permutations are not
     *                 performed, rather a specific order of supplies based on
     *                 capacity is computed
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#BATCH_TSM_MODE BATCH_TSM_MODE}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. When enabled, it sets the number of visits on each demand
     *         location by a single salesman at each trip is considered to be
     *         (one) 1, otherwise there is no bound.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Sets only one visit per
     *                 demand location by a salesman (TSM mode)
     *             <li>{@link Options#FALSE FALSE}: No preset limit (usual MSDO
     *                 mode)
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#ROUND_TRIP ROUND_TRIP}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. When enabled, the supply will have to return back to the
     *         origination location.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: The optimization is done for
     *                 trips in round trip manner always returning to
     *                 originating locations
     *             <li>{@link Options#FALSE FALSE}: Supplies do not have to
     *                 come back to their originating locations in their
     *                 routes. The routes are considered finished at the final
     *                 dropoff.
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#NUM_CYCLES NUM_CYCLES}: For the {@link
     *         SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} solver only.
     *         Terminates the cluster exchange iterations across 2-step-cycles
     *         (outer loop) when quality does not improve during iterations.
     *         The default value is '10'.
     *     <li>{@link Options#NUM_LOOPS_PER_CYCLE NUM_LOOPS_PER_CYCLE}: For the
     *         {@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} and {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only.
     *         Terminates the cluster exchanges within the first step
     *         iterations of a cycle (inner loop) unless convergence is
     *         reached. The default value is '10'.
     *     <li>{@link Options#NUM_OUTPUT_CLUSTERS NUM_OUTPUT_CLUSTERS}: For the
     *         {@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} solver only.
     *         Limits the output to the top 'num_output_clusters' clusters
     *         based on density. Default value of zero outputs all clusters.
     *         The default value is '0'.
     *     <li>{@link Options#MAX_NUM_CLUSTERS MAX_NUM_CLUSTERS}: For the
     *         {@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} and {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only. If
     *         set (value greater than zero), it terminates when the number of
     *         clusters goes below than this number. For embedding solver the
     *         default is 8. The default value is '0'.
     *     <li>{@link Options#CLUSTER_QUALITY_METRIC CLUSTER_QUALITY_METRIC}:
     *         For the {@link SolveMethod#MATCH_CLUSTERS MATCH_CLUSTERS} solver
     *         only. The quality metric for Louvain modularity optimization
     *         solver.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#GIRVAN GIRVAN}: Uses the Newman Girvan
     *                 quality metric for cluster solver
     *             <li>{@link Options#SPECTRAL SPECTRAL}: Applies recursive
     *                 spectral bisection (RSB) partitioning solver
     *         </ul>
     *         The default value is {@link Options#GIRVAN GIRVAN}.
     *     <li>{@link Options#RESTRICTED_TYPE RESTRICTED_TYPE}: For the {@link
     *         SolveMethod#MATCH_SUPPLY_DEMAND MATCH_SUPPLY_DEMAND} solver
     *         only. Optimization is performed by restricting routes labeled by
     *         'MSDO_ODDEVEN_RESTRICTED' only for this supply actor (truck)
     *         type.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#ODD ODD}: Applies odd/even rule
     *                 restrictions to odd tagged vehicles.
     *             <li>{@link Options#EVEN EVEN}: Applies odd/even rule
     *                 restrictions to even tagged vehicles.
     *             <li>{@link Options#NONE NONE}: Does not apply odd/even rule
     *                 restrictions to any vehicles.
     *         </ul>
     *         The default value is {@link Options#NONE NONE}.
     *     <li>{@link Options#SERVER_ID SERVER_ID}: Indicates which graph
     *         server(s) to send the request to. Default is to send to the
     *         server, amongst those containing the corresponding graph, that
     *         has the most computational bandwidth. The default value is ''.
     *     <li>{@link Options#INVERSE_SOLVE INVERSE_SOLVE}: For the {@link
     *         SolveMethod#MATCH_BATCH_SOLVES MATCH_BATCH_SOLVES} solver only.
     *         Solves source-destination pairs using inverse shortest path
     *         solver.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Solves using inverse shortest
     *                 path solver.
     *             <li>{@link Options#FALSE FALSE}: Solves using direct
     *                 shortest path solver.
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#MIN_LOOP_LEVEL MIN_LOOP_LEVEL}: For the {@link
     *         SolveMethod#MATCH_LOOPS MATCH_LOOPS} solver only. Finds closed
     *         loops around each node deducible not less than this minimal hop
     *         (level) deep. The default value is '0'.
     *     <li>{@link Options#MAX_LOOP_LEVEL MAX_LOOP_LEVEL}: For the {@link
     *         SolveMethod#MATCH_LOOPS MATCH_LOOPS} solver only. Finds closed
     *         loops around each node deducible not more than this maximal hop
     *         (level) deep. The default value is '5'.
     *     <li>{@link Options#SEARCH_LIMIT SEARCH_LIMIT}: For the {@link
     *         SolveMethod#MATCH_LOOPS MATCH_LOOPS} solver only. Searches
     *         within this limit of nodes per vertex to detect loops. The value
     *         zero means there is no limit. The default value is '10000'.
     *     <li>{@link Options#OUTPUT_BATCH_SIZE OUTPUT_BATCH_SIZE}: For the
     *         {@link SolveMethod#MATCH_LOOPS MATCH_LOOPS} solver only. Uses
     *         this value as the batch size of the number of loops in
     *         flushing(inserting) to the output table. The default value is
     *         '1000'.
     *     <li>{@link Options#CHARGING_CAPACITY CHARGING_CAPACITY}: For the
     *         {@link SolveMethod#MATCH_CHARGING_STATIONS
     *         MATCH_CHARGING_STATIONS} solver only. This is the maximum
     *         ev-charging capacity of a vehicle (distance in meters or time in
     *         seconds depending on the unit of the graph weights). The default
     *         value is '300000.0'.
     *     <li>{@link Options#CHARGING_CANDIDATES CHARGING_CANDIDATES}: For the
     *         {@link SolveMethod#MATCH_CHARGING_STATIONS
     *         MATCH_CHARGING_STATIONS} solver only. Solver searches for this
     *         many number of stations closest around each base charging
     *         location found by capacity. The default value is '10'.
     *     <li>{@link Options#CHARGING_PENALTY CHARGING_PENALTY}: For the
     *         {@link SolveMethod#MATCH_CHARGING_STATIONS
     *         MATCH_CHARGING_STATIONS} solver only. This is the penalty for
     *         full charging. The default value is '30000.0'.
     *     <li>{@link Options#MAX_HOPS MAX_HOPS}: For the {@link
     *         SolveMethod#MATCH_SIMILARITY MATCH_SIMILARITY} and {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only.
     *         Searches within this maximum hops for source and target node
     *         pairs to compute the Jaccard scores. The default value is '3'.
     *     <li>{@link Options#TRAVERSAL_NODE_LIMIT TRAVERSAL_NODE_LIMIT}: For
     *         the {@link SolveMethod#MATCH_SIMILARITY MATCH_SIMILARITY} solver
     *         only. Limits the traversal depth if it reaches this many number
     *         of nodes. The default value is '1000'.
     *     <li>{@link Options#PAIRED_SIMILARITY PAIRED_SIMILARITY}: For the
     *         {@link SolveMethod#MATCH_SIMILARITY MATCH_SIMILARITY} solver
     *         only. If true, it computes Jaccard score between each pair,
     *         otherwise it will compute Jaccard from the intersection set
     *         between the source and target nodes.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#FORCE_UNDIRECTED FORCE_UNDIRECTED}: For the
     *         {@link SolveMethod#MATCH_PATTERN MATCH_PATTERN} and {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only.
     *         Pattern matching will be using both pattern and graph as
     *         undirected if set to true.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#MAX_VECTOR_DIMENSION MAX_VECTOR_DIMENSION}: For
     *         the {@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver
     *         only. Limits the number of dimensions in node vector embeddings.
     *         The default value is '1000'.
     *     <li>{@link Options#OPTIMIZE_EMBEDDING_WEIGHTS
     *         OPTIMIZE_EMBEDDING_WEIGHTS}: For the {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solvers only.
     *         Solves to find the optimal weights per sub feature in vector
     *         embeddings.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#EMBEDDING_WEIGHTS EMBEDDING_WEIGHTS}: For the
     *         {@link SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver only.
     *         User specified weights per sub feature in vector embeddings.
     *         The string contains the comma separated float values for each
     *         sub-feature in the vector space. These values will ONLY be used
     *         if 'optimize_embedding_weights' is false. The default value is
     *         '1.0,1.0,1.0,1.0'.
     *     <li>{@link Options#OPTIMIZATION_SAMPLING_SIZE
     *         OPTIMIZATION_SAMPLING_SIZE}: For the {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver only. Sets
     *         the number of random nodes from the graph for solving the
     *         weights using stochastic gradient descent. The default value is
     *         '1000'.
     *     <li>{@link Options#OPTIMIZATION_MAX_ITERATIONS
     *         OPTIMIZATION_MAX_ITERATIONS}: For the {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver only. When
     *         the iterations (epochs) for the convergence of the stochastic
     *         gradient descent algorithm  reaches this number it bails out
     *         unless relative error between consecutive iterations is below
     *         the 'optimization_error_tolerance' option. The default value is
     *         '1000'.
     *     <li>{@link Options#OPTIMIZATION_ERROR_TOLERANCE
     *         OPTIMIZATION_ERROR_TOLERANCE}: For the {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver only. When
     *         the relative error between all of the weights' consecutive
     *         iterations falls below this threshold  the optimization cycle is
     *         interrupted unless the number of iterations reaches the limit
     *         set by the option 'max_optimization_iterations'. The default
     *         value is '0.001'.
     *     <li>{@link Options#OPTIMIZATION_ITERATION_RATE
     *         OPTIMIZATION_ITERATION_RATE}: For the {@link
     *         SolveMethod#MATCH_EMBEDDING MATCH_EMBEDDING} solver only. It is
     *         otherwise known as the learning rate, which is the
     *         proportionality constant in front of the gradient term in
     *         successive iterations. The default value is '0.3'.
     *     <li>{@link Options#MAX_RADIUS MAX_RADIUS}: For the {@link
     *         SolveMethod#MATCH_ISOCHRONE MATCH_ISOCHRONE} solver only. Sets
     *         the maximal reachability limit for computing isochrones. Zero
     *         means no limit. The default value is '0.0'.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @param options  The new value for {@code options}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public MatchGraphRequest setOptions(Map<String, String> options) {
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
        return this;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @return The schema object describing this class.
     */
    @Override
    public Schema getSchema() {
        return schema$;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @param index  the position of the field to get
     *
     * @return value of the field with the given index.
     *
     * @throws IndexOutOfBoundsException
     */
    @Override
    public Object get(int index) {
        switch (index) {
            case 0:
                return this.graphName;

            case 1:
                return this.samplePoints;

            case 2:
                return this.solveMethod;

            case 3:
                return this.solutionTable;

            case 4:
                return this.options;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @param index  the position of the field to set
     * @param value  the value to set
     *
     * @throws IndexOutOfBoundsException
     */
    @Override
    @SuppressWarnings("unchecked")
    public void put(int index, Object value) {
        switch (index) {
            case 0:
                this.graphName = (String)value;
                break;

            case 1:
                this.samplePoints = (List<String>)value;
                break;

            case 2:
                this.solveMethod = (String)value;
                break;

            case 3:
                this.solutionTable = (String)value;
                break;

            case 4:
                this.options = (Map<String, String>)value;
                break;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if( obj == this ) {
            return true;
        }

        if( (obj == null) || (obj.getClass() != this.getClass()) ) {
            return false;
        }

        MatchGraphRequest that = (MatchGraphRequest)obj;

        return ( this.graphName.equals( that.graphName )
                 && this.samplePoints.equals( that.samplePoints )
                 && this.solveMethod.equals( that.solveMethod )
                 && this.solutionTable.equals( that.solutionTable )
                 && this.options.equals( that.options ) );
    }

    @Override
    public String toString() {
        GenericData gd = GenericData.get();
        StringBuilder builder = new StringBuilder();
        builder.append( "{" );
        builder.append( gd.toString( "graphName" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.graphName ) );
        builder.append( ", " );
        builder.append( gd.toString( "samplePoints" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.samplePoints ) );
        builder.append( ", " );
        builder.append( gd.toString( "solveMethod" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.solveMethod ) );
        builder.append( ", " );
        builder.append( gd.toString( "solutionTable" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.solutionTable ) );
        builder.append( ", " );
        builder.append( gd.toString( "options" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.options ) );
        builder.append( "}" );

        return builder.toString();
    }

    @Override
    public int hashCode() {
        int hashCode = 1;
        hashCode = (31 * hashCode) + this.graphName.hashCode();
        hashCode = (31 * hashCode) + this.samplePoints.hashCode();
        hashCode = (31 * hashCode) + this.solveMethod.hashCode();
        hashCode = (31 * hashCode) + this.solutionTable.hashCode();
        hashCode = (31 * hashCode) + this.options.hashCode();
        return hashCode;
    }
}
