/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
package com.gpudb.protocol;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.apache.avro.Schema;
import org.apache.avro.SchemaBuilder;
import org.apache.avro.generic.GenericData;
import org.apache.avro.generic.IndexedRecord;

/**
 * A set of parameters for {@link
 * com.gpudb.GPUdb#createTableExternal(CreateTableExternalRequest)
 * GPUdb.createTableExternal}.
 * <p>
 * Creates a new <a href="../../../../../../concepts/external_tables/"
 * target="_top">external table</a>, which is a local database object whose
 * source data is located externally to the database.  The source data can be
 * located either in <a href="../../../../../../tools/kifs/"
 * target="_top">KiFS</a>; on the cluster, accessible to the database; or
 * remotely, accessible via a pre-defined external <a
 * href="../../../../../../concepts/data_sources/" target="_top">data
 * source</a>.
 * <p>
 * The external table can have its structure defined explicitly, via {@link
 * #getCreateTableOptions() createTableOptions}, which contains many of the
 * options from {@link com.gpudb.GPUdb#createTable(CreateTableRequest)
 * GPUdb.createTable}; or defined implicitly, inferred from the source data.
 */
public class CreateTableExternalRequest implements IndexedRecord {
    private static final Schema schema$ = SchemaBuilder
            .record("CreateTableExternalRequest")
            .namespace("com.gpudb")
            .fields()
                .name("tableName").type().stringType().noDefault()
                .name("filepaths").type().array().items().stringType().noDefault()
                .name("modifyColumns").type().map().values().map().values().stringType().noDefault()
                .name("createTableOptions").type().map().values().stringType().noDefault()
                .name("options").type().map().values().stringType().noDefault()
            .endRecord();

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @return The schema for the class.
     */
    public static Schema getClassSchema() {
        return schema$;
    }

    /**
     * A set of string constants for the {@link CreateTableExternalRequest}
     * parameter {@link #getCreateTableOptions() createTableOptions}.
     * <p>
     * Options from {@link com.gpudb.GPUdb#createTable(CreateTableRequest)
     * GPUdb.createTable}, allowing the structure of the table to be defined
     * independently of the data source
     */
    public static final class CreateTableOptions {
        /**
         * ID of a currently registered <a
         * href="../../../../../../concepts/types/" target="_top">type</a>.
         */
        public static final String TYPE_ID = "type_id";

        /**
         * If {@link CreateTableOptions#TRUE TRUE}, prevents an error from
         * occurring if the table already exists and is of the given type.  If
         * a table with the same name but a different type exists, it is still
         * an error.
         * Supported values:
         * <ul>
         *     <li>{@link CreateTableOptions#TRUE TRUE}
         *     <li>{@link CreateTableOptions#FALSE FALSE}
         * </ul>
         * The default value is {@link CreateTableOptions#FALSE FALSE}.
         */
        public static final String NO_ERROR_IF_EXISTS = "no_error_if_exists";

        public static final String TRUE = "true";
        public static final String FALSE = "false";

        /**
         * Affects the <a
         * href="../../../../../../concepts/tables/#distribution"
         * target="_top">distribution scheme</a> for the table's data.  If
         * {@link CreateTableOptions#TRUE TRUE} and the given table has no
         * explicit <a href="../../../../../../concepts/tables/#shard-key"
         * target="_top">shard key</a> defined, the table will be <a
         * href="../../../../../../concepts/tables/#replication"
         * target="_top">replicated</a>.  If {@link CreateTableOptions#FALSE
         * FALSE}, the table will be <a
         * href="../../../../../../concepts/tables/#sharding"
         * target="_top">sharded</a> according to the shard key specified in
         * the given {@link CreateTableOptions#TYPE_ID TYPE_ID}, or <a
         * href="../../../../../../concepts/tables/#random-sharding"
         * target="_top">randomly sharded</a>, if no shard key is specified.
         * Note that a type containing a shard key cannot be used to create a
         * replicated table.
         * Supported values:
         * <ul>
         *     <li>{@link CreateTableOptions#TRUE TRUE}
         *     <li>{@link CreateTableOptions#FALSE FALSE}
         * </ul>
         * The default value is {@link CreateTableOptions#FALSE FALSE}.
         */
        public static final String IS_REPLICATED = "is_replicated";

        /**
         * Semicolon-separated list of <a
         * href="../../../../../../concepts/tables/#foreign-keys"
         * target="_top">foreign keys</a>, of the format '(source_column_name
         * [, ...]) references target_table_name(primary_key_column_name [,
         * ...]) [as foreign_key_name]'.
         */
        public static final String FOREIGN_KEYS = "foreign_keys";

        /**
         * Foreign shard key of the format 'source_column references
         * shard_by_column from target_table(primary_key_column)'.
         */
        public static final String FOREIGN_SHARD_KEY = "foreign_shard_key";

        /**
         * <a href="../../../../../../concepts/tables/#partitioning"
         * target="_top">Partitioning</a> scheme to use.
         * Supported values:
         * <ul>
         *     <li>{@link CreateTableOptions#RANGE RANGE}: Use <a
         *         href="../../../../../../concepts/tables/#partitioning-by-range"
         *         target="_top">range partitioning</a>.
         *     <li>{@link CreateTableOptions#INTERVAL INTERVAL}: Use <a
         *         href="../../../../../../concepts/tables/#partitioning-by-interval"
         *         target="_top">interval partitioning</a>.
         *     <li>{@link CreateTableOptions#LIST LIST}: Use <a
         *         href="../../../../../../concepts/tables/#partitioning-by-list"
         *         target="_top">list partitioning</a>.
         *     <li>{@link CreateTableOptions#HASH HASH}: Use <a
         *         href="../../../../../../concepts/tables/#partitioning-by-hash"
         *         target="_top">hash partitioning</a>.
         *     <li>{@link CreateTableOptions#SERIES SERIES}: Use <a
         *         href="../../../../../../concepts/tables/#partitioning-by-series"
         *         target="_top">series partitioning</a>.
         * </ul>
         */
        public static final String PARTITION_TYPE = "partition_type";

        /**
         * Use <a
         * href="../../../../../../concepts/tables/#partitioning-by-range"
         * target="_top">range partitioning</a>.
         */
        public static final String RANGE = "RANGE";

        /**
         * Use <a
         * href="../../../../../../concepts/tables/#partitioning-by-interval"
         * target="_top">interval partitioning</a>.
         */
        public static final String INTERVAL = "INTERVAL";

        /**
         * Use <a
         * href="../../../../../../concepts/tables/#partitioning-by-list"
         * target="_top">list partitioning</a>.
         */
        public static final String LIST = "LIST";

        /**
         * Use <a
         * href="../../../../../../concepts/tables/#partitioning-by-hash"
         * target="_top">hash partitioning</a>.
         */
        public static final String HASH = "HASH";

        /**
         * Use <a
         * href="../../../../../../concepts/tables/#partitioning-by-series"
         * target="_top">series partitioning</a>.
         */
        public static final String SERIES = "SERIES";

        /**
         * Comma-separated list of partition keys, which are the columns or
         * column expressions by which records will be assigned to partitions
         * defined by {@link CreateTableOptions#PARTITION_DEFINITIONS
         * PARTITION_DEFINITIONS}.
         */
        public static final String PARTITION_KEYS = "partition_keys";

        /**
         * Comma-separated list of partition definitions, whose format depends
         * on the choice of {@link CreateTableOptions#PARTITION_TYPE
         * PARTITION_TYPE}.  See <a
         * href="../../../../../../concepts/tables/#partitioning-by-range"
         * target="_top">range partitioning</a>, <a
         * href="../../../../../../concepts/tables/#partitioning-by-interval"
         * target="_top">interval partitioning</a>, <a
         * href="../../../../../../concepts/tables/#partitioning-by-list"
         * target="_top">list partitioning</a>, <a
         * href="../../../../../../concepts/tables/#partitioning-by-hash"
         * target="_top">hash partitioning</a>, or <a
         * href="../../../../../../concepts/tables/#partitioning-by-series"
         * target="_top">series partitioning</a> for example formats.
         */
        public static final String PARTITION_DEFINITIONS = "partition_definitions";

        /**
         * If {@link CreateTableOptions#TRUE TRUE}, a new partition will be
         * created for values which don't fall into an existing partition.
         * Currently, only supported for <a
         * href="../../../../../../concepts/tables/#partitioning-by-list"
         * target="_top">list partitions</a>.
         * Supported values:
         * <ul>
         *     <li>{@link CreateTableOptions#TRUE TRUE}
         *     <li>{@link CreateTableOptions#FALSE FALSE}
         * </ul>
         * The default value is {@link CreateTableOptions#FALSE FALSE}.
         */
        public static final String IS_AUTOMATIC_PARTITION = "is_automatic_partition";

        /**
         * Sets the <a href="../../../../../../concepts/ttl/"
         * target="_top">TTL</a> of the table specified in {@link
         * #getTableName() tableName}.
         */
        public static final String TTL = "ttl";

        /**
         * Indicates the number of records per chunk to be used for this table.
         */
        public static final String CHUNK_SIZE = "chunk_size";

        /**
         * Indicates the target maximum data size for each column in a chunk to
         * be used for this table.
         */
        public static final String CHUNK_COLUMN_MAX_MEMORY = "chunk_column_max_memory";

        /**
         * Indicates the target maximum data size for all columns in a chunk to
         * be used for this table.
         */
        public static final String CHUNK_MAX_MEMORY = "chunk_max_memory";

        /**
         * Indicates whether the table is a <a
         * href="../../../../../../concepts/tables_memory_only/"
         * target="_top">memory-only table</a>. A result table cannot contain
         * columns with text_search <a
         * href="../../../../../../concepts/types/#data-handling"
         * target="_top">data-handling</a>, and it will not be retained if the
         * server is restarted.
         * Supported values:
         * <ul>
         *     <li>{@link CreateTableOptions#TRUE TRUE}
         *     <li>{@link CreateTableOptions#FALSE FALSE}
         * </ul>
         * The default value is {@link CreateTableOptions#FALSE FALSE}.
         */
        public static final String IS_RESULT_TABLE = "is_result_table";

        /**
         * The <a href="../../../../../../rm/concepts/#tier-strategies"
         * target="_top">tier strategy</a> for the table and its columns.
         */
        public static final String STRATEGY_DEFINITION = "strategy_definition";

        /**
         * The default <a href="../../../../../../concepts/column_compression/"
         * target="_top">compression codec</a> for this table's columns.
         */
        public static final String COMPRESSION_CODEC = "compression_codec";

        private CreateTableOptions() {  }
    }

    /**
     * A set of string constants for the {@link CreateTableExternalRequest}
     * parameter {@link #getOptions() options}.
     * <p>
     * Optional parameters.
     */
    public static final class Options {
        /**
         * Name of a table to which records that were rejected are written. The
         * bad-record-table has the following columns: line_number (long),
         * line_rejected (string), error_message (string).  When {@link
         * Options#ERROR_HANDLING ERROR_HANDLING} is {@link Options#ABORT
         * ABORT}, bad records table is not populated.
         */
        public static final String BAD_RECORD_TABLE_NAME = "bad_record_table_name";

        /**
         * A positive integer indicating the maximum number of records that can
         * be written to the bad-record-table. The default value is '10000'.
         */
        public static final String BAD_RECORD_TABLE_LIMIT = "bad_record_table_limit";

        /**
         * For subscriptions, a positive integer indicating the maximum number
         * of records that can be written to the bad-record-table per
         * file/payload. Default value will be {@link
         * Options#BAD_RECORD_TABLE_LIMIT BAD_RECORD_TABLE_LIMIT} and total
         * size of the table per rank is limited to {@link
         * Options#BAD_RECORD_TABLE_LIMIT BAD_RECORD_TABLE_LIMIT}.
         */
        public static final String BAD_RECORD_TABLE_LIMIT_PER_INPUT = "bad_record_table_limit_per_input";

        /**
         * Number of records to insert per batch when inserting data. The
         * default value is '50000'.
         */
        public static final String BATCH_SIZE = "batch_size";

        /**
         * For each target column specified, applies the column-property-bound
         * format to the source data loaded into that column.  Each column
         * format will contain a mapping of one or more of its column
         * properties to an appropriate format for each property.  Currently
         * supported column properties include date, time, & datetime. The
         * parameter value must be formatted as a JSON string of maps of column
         * names to maps of column properties to their corresponding column
         * formats, e.g., '{ "order_date" : { "date" : "%Y.%m.%d" },
         * "order_time" : { "time" : "%H:%M:%S" } }'.
         * <p>
         * See {@link Options#DEFAULT_COLUMN_FORMATS DEFAULT_COLUMN_FORMATS}
         * for valid format syntax.
         */
        public static final String COLUMN_FORMATS = "column_formats";

        /**
         * Specifies a comma-delimited list of columns from the source data to
         * load.  If more than one file is being loaded, this list applies to
         * all files.
         * <p>
         * Column numbers can be specified discretely or as a range.  For
         * example, a value of '5,7,1..3' will insert values from the fifth
         * column in the source data into the first column in the target table,
         * from the seventh column in the source data into the second column in
         * the target table, and from the first through third columns in the
         * source data into the third through fifth columns in the target
         * table.
         * <p>
         * If the source data contains a header, column names matching the file
         * header names may be provided instead of column numbers.  If the
         * target table doesn't exist, the table will be created with the
         * columns in this order.  If the target table does exist with columns
         * in a different order than the source data, this list can be used to
         * match the order of the target table.  For example, a value of 'C, B,
         * A' will create a three column table with column C, followed by
         * column B, followed by column A; or will insert those fields in that
         * order into a table created with columns in that order.  If the
         * target table exists, the column names must match the source data
         * field names for a name-mapping to be successful.
         * <p>
         * Mutually exclusive with {@link Options#COLUMNS_TO_SKIP
         * COLUMNS_TO_SKIP}.
         */
        public static final String COLUMNS_TO_LOAD = "columns_to_load";

        /**
         * Specifies a comma-delimited list of columns from the source data to
         * skip.  Mutually exclusive with {@link Options#COLUMNS_TO_LOAD
         * COLUMNS_TO_LOAD}.
         */
        public static final String COLUMNS_TO_SKIP = "columns_to_skip";

        /**
         * Source data compression type.
         * Supported values:
         * <ul>
         *     <li>{@link Options#NONE NONE}: No compression.
         *     <li>{@link Options#AUTO AUTO}: Auto detect compression type
         *     <li>{@link Options#GZIP GZIP}: gzip file compression.
         *     <li>{@link Options#BZIP2 BZIP2}: bzip2 file compression.
         * </ul>
         * The default value is {@link Options#AUTO AUTO}.
         */
        public static final String COMPRESSION_TYPE = "compression_type";

        /**
         * No compression.
         */
        public static final String NONE = "none";

        /**
         * Auto detect compression type
         */
        public static final String AUTO = "auto";

        /**
         * gzip file compression.
         */
        public static final String GZIP = "gzip";

        /**
         * bzip2 file compression.
         */
        public static final String BZIP2 = "bzip2";

        /**
         * Name of an existing external data source from which data file(s)
         * specified in {@link #getFilepaths() filepaths} will be loaded
         */
        public static final String DATASOURCE_NAME = "datasource_name";

        /**
         * Specifies the default format to be applied to source data loaded
         * into columns with the corresponding column property.  Currently
         * supported column properties include date, time, & datetime.  This
         * default column-property-bound format can be overridden by specifying
         * a column property & format for a given target column in {@link
         * Options#COLUMN_FORMATS COLUMN_FORMATS}. For each specified
         * annotation, the format will apply to all columns with that
         * annotation unless a custom {@link Options#COLUMN_FORMATS
         * COLUMN_FORMATS} for that annotation is specified.
         * <p>
         * The parameter value must be formatted as a JSON string that is a map
         * of column properties to their respective column formats, e.g., '{
         * "date" : "%Y.%m.%d", "time" : "%H:%M:%S" }'.  Column formats are
         * specified as a string of control characters and plain text. The
         * supported control characters are 'Y', 'm', 'd', 'H', 'M', 'S', and
         * 's', which follow the Linux 'strptime()' specification, as well as
         * 's', which specifies seconds and fractional seconds (though the
         * fractional component will be truncated past milliseconds).
         * <p>
         * Formats for the 'date' annotation must include the 'Y', 'm', and 'd'
         * control characters. Formats for the 'time' annotation must include
         * the 'H', 'M', and either 'S' or 's' (but not both) control
         * characters. Formats for the 'datetime' annotation meet both the
         * 'date' and 'time' control character requirements. For example,
         * '{"datetime" : "%m/%d/%Y %H:%M:%S" }' would be used to interpret
         * text as "05/04/2000 12:12:11"
         */
        public static final String DEFAULT_COLUMN_FORMATS = "default_column_formats";

        /**
         * Specifies how errors should be handled upon insertion.
         * Supported values:
         * <ul>
         *     <li>{@link Options#PERMISSIVE PERMISSIVE}: Records with missing
         *         columns are populated with nulls if possible; otherwise, the
         *         malformed records are skipped.
         *     <li>{@link Options#IGNORE_BAD_RECORDS IGNORE_BAD_RECORDS}:
         *         Malformed records are skipped.
         *     <li>{@link Options#ABORT ABORT}: Stops current insertion and
         *         aborts entire operation when an error is encountered.
         *         Primary key collisions are considered abortable errors in
         *         this mode.
         * </ul>
         * The default value is {@link Options#ABORT ABORT}.
         */
        public static final String ERROR_HANDLING = "error_handling";

        /**
         * Records with missing columns are populated with nulls if possible;
         * otherwise, the malformed records are skipped.
         */
        public static final String PERMISSIVE = "permissive";

        /**
         * Malformed records are skipped.
         */
        public static final String IGNORE_BAD_RECORDS = "ignore_bad_records";

        /**
         * Stops current insertion and aborts entire operation when an error is
         * encountered.  Primary key collisions are considered abortable errors
         * in this mode.
         */
        public static final String ABORT = "abort";

        /**
         * Specifies whether the external table holds a local copy of the
         * external data.
         * Supported values:
         * <ul>
         *     <li>{@link Options#MATERIALIZED MATERIALIZED}: Loads a copy of
         *         the external data into the database, refreshed on demand
         *     <li>{@link Options#LOGICAL LOGICAL}: External data will not be
         *         loaded into the database; the data will be retrieved from
         *         the source upon servicing each query against the external
         *         table
         * </ul>
         * The default value is {@link Options#MATERIALIZED MATERIALIZED}.
         */
        public static final String EXTERNAL_TABLE_TYPE = "external_table_type";

        /**
         * Loads a copy of the external data into the database, refreshed on
         * demand
         */
        public static final String MATERIALIZED = "materialized";

        /**
         * External data will not be loaded into the database; the data will be
         * retrieved from the source upon servicing each query against the
         * external table
         */
        public static final String LOGICAL = "logical";

        /**
         * Specifies the type of the file(s) whose records will be inserted.
         * Supported values:
         * <ul>
         *     <li>{@link Options#AVRO AVRO}: Avro file format
         *     <li>{@link Options#DELIMITED_TEXT DELIMITED_TEXT}: Delimited
         *         text file format; e.g., CSV, TSV, PSV, etc.
         *     <li>{@link Options#GDB GDB}: Esri/GDB file format
         *     <li>{@link Options#JSON JSON}: Json file format
         *     <li>{@link Options#PARQUET PARQUET}: Apache Parquet file format
         *     <li>{@link Options#SHAPEFILE SHAPEFILE}: ShapeFile file format
         * </ul>
         * The default value is {@link Options#DELIMITED_TEXT DELIMITED_TEXT}.
         */
        public static final String FILE_TYPE = "file_type";

        /**
         * Avro file format
         */
        public static final String AVRO = "avro";

        /**
         * Delimited text file format; e.g., CSV, TSV, PSV, etc.
         */
        public static final String DELIMITED_TEXT = "delimited_text";

        /**
         * Esri/GDB file format
         */
        public static final String GDB = "gdb";

        /**
         * Json file format
         */
        public static final String JSON = "json";

        /**
         * Apache Parquet file format
         */
        public static final String PARQUET = "parquet";

        /**
         * ShapeFile file format
         */
        public static final String SHAPEFILE = "shapefile";

        /**
         * Specifies how to handle nested columns.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Break up nested columns to
         *         multiple columns
         *     <li>{@link Options#FALSE FALSE}: Treat nested columns as json
         *         columns instead of flattening
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String FLATTEN_COLUMNS = "flatten_columns";

        /**
         * Upsert new records when primary keys match existing records
         */
        public static final String TRUE = "true";

        /**
         * Reject new records when primary keys match existing records
         */
        public static final String FALSE = "false";

        /**
         * Comma separated list of gdal conf options, for the specific
         * requests: key=value
         */
        public static final String GDAL_CONFIGURATION_OPTIONS = "gdal_configuration_options";

        /**
         * Specifies the record collision error-suppression policy for
         * inserting into a table with a <a
         * href="../../../../../../concepts/tables/#primary-keys"
         * target="_top">primary key</a>, only used when not in upsert mode
         * (upsert mode is disabled when {@link Options#UPDATE_ON_EXISTING_PK
         * UPDATE_ON_EXISTING_PK} is {@link Options#FALSE FALSE}).  If set to
         * {@link Options#TRUE TRUE}, any record being inserted that is
         * rejected for having primary key values that match those of an
         * existing table record will be ignored with no error generated.  If
         * {@link Options#FALSE FALSE}, the rejection of any record for having
         * primary key values matching an existing record will result in an
         * error being reported, as determined by {@link Options#ERROR_HANDLING
         * ERROR_HANDLING}.  If the specified table does not have a primary key
         * or if upsert mode is in effect ({@link Options#UPDATE_ON_EXISTING_PK
         * UPDATE_ON_EXISTING_PK} is {@link Options#TRUE TRUE}), then this
         * option has no effect.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Ignore new records whose primary
         *         key values collide with those of existing records
         *     <li>{@link Options#FALSE FALSE}: Treat as errors any new records
         *         whose primary key values collide with those of existing
         *         records
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String IGNORE_EXISTING_PK = "ignore_existing_pk";

        /**
         * Whether to do a full load, dry run, or perform a type inference on
         * the source data.
         * Supported values:
         * <ul>
         *     <li>{@link Options#FULL FULL}: Run a type inference on the
         *         source data (if needed) and ingest
         *     <li>{@link Options#DRY_RUN DRY_RUN}: Does not load data, but
         *         walks through the source data and determines the number of
         *         valid records, taking into account the current mode of
         *         {@link Options#ERROR_HANDLING ERROR_HANDLING}.
         *     <li>{@link Options#TYPE_INFERENCE_ONLY TYPE_INFERENCE_ONLY}:
         *         Infer the type of the source data and return, without
         *         ingesting any data.  The inferred type is returned in the
         *         response.
         * </ul>
         * The default value is {@link Options#FULL FULL}.
         */
        public static final String INGESTION_MODE = "ingestion_mode";

        /**
         * Run a type inference on the source data (if needed) and ingest
         */
        public static final String FULL = "full";

        /**
         * Does not load data, but walks through the source data and determines
         * the number of valid records, taking into account the current mode of
         * {@link Options#ERROR_HANDLING ERROR_HANDLING}.
         */
        public static final String DRY_RUN = "dry_run";

        /**
         * Infer the type of the source data and return, without ingesting any
         * data.  The inferred type is returned in the response.
         */
        public static final String TYPE_INFERENCE_ONLY = "type_inference_only";

        /**
         * The JDBC fetch size, which determines how many rows to fetch per
         * round trip. The default value is '50000'.
         */
        public static final String JDBC_FETCH_SIZE = "jdbc_fetch_size";

        /**
         * Number of Kafka consumer threads per rank (valid range 1-6). The
         * default value is '1'.
         */
        public static final String KAFKA_CONSUMERS_PER_RANK = "kafka_consumers_per_rank";

        /**
         * The group id to be used when consuming data from a Kafka topic
         * (valid only for Kafka datasource subscriptions).
         */
        public static final String KAFKA_GROUP_ID = "kafka_group_id";

        /**
         * Policy to determine whether the Kafka data consumption starts either
         * at earliest offset or latest offset.
         * Supported values:
         * <ul>
         *     <li>{@link Options#EARLIEST EARLIEST}
         *     <li>{@link Options#LATEST LATEST}
         * </ul>
         * The default value is {@link Options#EARLIEST EARLIEST}.
         */
        public static final String KAFKA_OFFSET_RESET_POLICY = "kafka_offset_reset_policy";

        public static final String EARLIEST = "earliest";
        public static final String LATEST = "latest";

        /**
         * Enable optimistic ingestion where Kafka topic offsets and table data
         * are committed independently to achieve parallelism.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String KAFKA_OPTIMISTIC_INGEST = "kafka_optimistic_ingest";

        /**
         * Sets the Kafka subscription lifespan (in minutes). Expired
         * subscription will be cancelled automatically.
         */
        public static final String KAFKA_SUBSCRIPTION_CANCEL_AFTER = "kafka_subscription_cancel_after";

        /**
         * Maximum time to collect Kafka messages before type inferencing on
         * the set of them.
         */
        public static final String KAFKA_TYPE_INFERENCE_FETCH_TIMEOUT = "kafka_type_inference_fetch_timeout";

        /**
         * Geo files layer(s) name(s): comma separated.
         */
        public static final String LAYER = "layer";

        /**
         * Scheme for distributing the extraction and loading of data from the
         * source data file(s). This option applies only when loading files
         * that are local to the database.
         * Supported values:
         * <ul>
         *     <li>{@link Options#HEAD HEAD}: The head node loads all data. All
         *         files must be available to the head node.
         *     <li>{@link Options#DISTRIBUTED_SHARED DISTRIBUTED_SHARED}: The
         *         head node coordinates loading data by worker processes
         *         across all nodes from shared files available to all workers.
         *         NOTE:  Instead of existing on a shared source, the files can
         *         be duplicated on a source local to each host to improve
         *         performance, though the files must appear as the same data
         *         set from the perspective of all hosts performing the load.
         *     <li>{@link Options#DISTRIBUTED_LOCAL DISTRIBUTED_LOCAL}: A
         *         single worker process on each node loads all files that are
         *         available to it. This option works best when each worker
         *         loads files from its own file system, to maximize
         *         performance. In order to avoid data duplication, either each
         *         worker performing the load needs to have visibility to a set
         *         of files unique to it (no file is visible to more than one
         *         node) or the target table needs to have a primary key (which
         *         will allow the worker to automatically deduplicate data).
         *         NOTE:  If the target table doesn't exist, the table
         *         structure will be determined by the head node. If the head
         *         node has no files local to it, it will be unable to
         *         determine the structure and the request will fail.  If the
         *         head node is configured to have no worker processes, no data
         *         strictly accessible to the head node will be loaded.
         * </ul>
         * The default value is {@link Options#HEAD HEAD}.
         */
        public static final String LOADING_MODE = "loading_mode";

        /**
         * The head node loads all data. All files must be available to the
         * head node.
         */
        public static final String HEAD = "head";

        /**
         * The head node coordinates loading data by worker processes across
         * all nodes from shared files available to all workers.
         * <p>
         * NOTE:
         * <p>
         * Instead of existing on a shared source, the files can be duplicated
         * on a source local to each host to improve performance, though the
         * files must appear as the same data set from the perspective of all
         * hosts performing the load.
         */
        public static final String DISTRIBUTED_SHARED = "distributed_shared";

        /**
         * A single worker process on each node loads all files that are
         * available to it. This option works best when each worker loads files
         * from its own file system, to maximize performance. In order to avoid
         * data duplication, either each worker performing the load needs to
         * have visibility to a set of files unique to it (no file is visible
         * to more than one node) or the target table needs to have a primary
         * key (which will allow the worker to automatically deduplicate data).
         * <p>
         * NOTE:
         * <p>
         * If the target table doesn't exist, the table structure will be
         * determined by the head node. If the head node has no files local to
         * it, it will be unable to determine the structure and the request
         * will fail.
         * <p>
         * If the head node is configured to have no worker processes, no data
         * strictly accessible to the head node will be loaded.
         */
        public static final String DISTRIBUTED_LOCAL = "distributed_local";

        /**
         * Apply an offset to Avro local timestamp columns.
         */
        public static final String LOCAL_TIME_OFFSET = "local_time_offset";

        /**
         * Limit the number of records to load in this request: if this number
         * is larger than {@link Options#BATCH_SIZE BATCH_SIZE}, then the
         * number of records loaded will be limited to the next whole number of
         * {@link Options#BATCH_SIZE BATCH_SIZE} (per working thread).
         */
        public static final String MAX_RECORDS_TO_LOAD = "max_records_to_load";

        /**
         * Number of tasks for reading file per rank. Default will be system
         * configuration parameter, external_file_reader_num_tasks.
         */
        public static final String NUM_TASKS_PER_RANK = "num_tasks_per_rank";

        /**
         * If {@link Options#TRUE TRUE}, the number of seconds between attempts
         * to load external files into the table.  If zero, polling will be
         * continuous as long as data is found.  If no data is found, the
         * interval will steadily increase to a maximum of 60 seconds. The
         * default value is '0'.
         */
        public static final String POLL_INTERVAL = "poll_interval";

        /**
         * Comma separated list of column names to set as primary keys, when
         * not specified in the type.
         */
        public static final String PRIMARY_KEYS = "primary_keys";

        /**
         * Method by which the table can be refreshed from its source data.
         * Supported values:
         * <ul>
         *     <li>{@link Options#MANUAL MANUAL}: Refresh only occurs when
         *         manually requested by invoking the refresh action of {@link
         *         com.gpudb.GPUdb#alterTable(AlterTableRequest)
         *         GPUdb.alterTable} on this table.
         *     <li>{@link Options#ON_START ON_START}: Refresh table on database
         *         startup and when manually requested by invoking the refresh
         *         action of {@link
         *         com.gpudb.GPUdb#alterTable(AlterTableRequest)
         *         GPUdb.alterTable} on this table.
         * </ul>
         * The default value is {@link Options#MANUAL MANUAL}.
         */
        public static final String REFRESH_METHOD = "refresh_method";

        /**
         * Refresh only occurs when manually requested by invoking the refresh
         * action of {@link com.gpudb.GPUdb#alterTable(AlterTableRequest)
         * GPUdb.alterTable} on this table.
         */
        public static final String MANUAL = "manual";

        /**
         * Refresh table on database startup and when manually requested by
         * invoking the refresh action of {@link
         * com.gpudb.GPUdb#alterTable(AlterTableRequest) GPUdb.alterTable} on
         * this table.
         */
        public static final String ON_START = "on_start";

        /**
         * Confluent Schema registry connection timeout (in Secs)
         */
        public static final String SCHEMA_REGISTRY_CONNECTION_RETRIES = "schema_registry_connection_retries";

        /**
         * Confluent Schema registry connection timeout (in Secs)
         */
        public static final String SCHEMA_REGISTRY_CONNECTION_TIMEOUT = "schema_registry_connection_timeout";

        /**
         * Max records to skip due to SR connection failures, before failing
         */
        public static final String SCHEMA_REGISTRY_MAX_CONSECUTIVE_CONNECTION_FAILURES = "schema_registry_max_consecutive_connection_failures";

        /**
         * Max records to skip due to schema related errors, before failing
         */
        public static final String MAX_CONSECUTIVE_INVALID_SCHEMA_FAILURE = "max_consecutive_invalid_schema_failure";

        /**
         * Name of the Avro schema in the schema registry to use when reading
         * Avro records.
         */
        public static final String SCHEMA_REGISTRY_SCHEMA_NAME = "schema_registry_schema_name";

        /**
         * Comma separated list of column names to set as shard keys, when not
         * specified in the type.
         */
        public static final String SHARD_KEYS = "shard_keys";

        /**
         * Skip a number of lines from the beginning of the file.
         */
        public static final String SKIP_LINES = "skip_lines";

        /**
         * Starting offsets by partition to fetch from kafka. A comma separated
         * list of partition:offset pairs.
         */
        public static final String START_OFFSETS = "start_offsets";

        /**
         * Continuously poll the data source to check for new data and load it
         * into the table.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String SUBSCRIBE = "subscribe";

        /**
         * Insertion scheme to use when inserting records from multiple
         * shapefiles.
         * Supported values:
         * <ul>
         *     <li>{@link Options#SINGLE SINGLE}: Insert all records into a
         *         single table.
         *     <li>{@link Options#TABLE_PER_FILE TABLE_PER_FILE}: Insert
         *         records from each file into a new table corresponding to
         *         that file.
         * </ul>
         * The default value is {@link Options#SINGLE SINGLE}.
         */
        public static final String TABLE_INSERT_MODE = "table_insert_mode";

        /**
         * Insert all records into a single table.
         */
        public static final String SINGLE = "single";

        /**
         * Insert records from each file into a new table corresponding to that
         * file.
         */
        public static final String TABLE_PER_FILE = "table_per_file";

        /**
         * Specifies the character string that should be interpreted as a
         * comment line prefix in the source data.  All lines in the data
         * starting with the provided string are ignored.
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only. The default value is '#'.
         */
        public static final String TEXT_COMMENT_STRING = "text_comment_string";

        /**
         * Specifies the character delimiting field values in the source data
         * and field names in the header (if present).
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only. The default value is ','.
         */
        public static final String TEXT_DELIMITER = "text_delimiter";

        /**
         * Specifies the character that is used to escape other characters in
         * the source data.
         * <p>
         * An 'a', 'b', 'f', 'n', 'r', 't', or 'v' preceded by an escape
         * character will be interpreted as the ASCII bell, backspace, form
         * feed, line feed, carriage return, horizontal tab, & vertical tab,
         * respectively.  For example, the escape character followed by an 'n'
         * will be interpreted as a newline within a field value.
         * <p>
         * The escape character can also be used to escape the quoting
         * character, and will be treated as an escape character whether it is
         * within a quoted field value or not.
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only.
         */
        public static final String TEXT_ESCAPE_CHARACTER = "text_escape_character";

        /**
         * Indicates whether the source data contains a header row.
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#TRUE TRUE}.
         */
        public static final String TEXT_HAS_HEADER = "text_has_header";

        /**
         * Specifies the delimiter for <a
         * href="../../../../../../concepts/types/#column-properties"
         * target="_top">column properties</a> in the header row (if present).
         * Cannot be set to same value as {@link Options#TEXT_DELIMITER
         * TEXT_DELIMITER}.
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only. The default value is '|'.
         */
        public static final String TEXT_HEADER_PROPERTY_DELIMITER = "text_header_property_delimiter";

        /**
         * Specifies the character string that should be interpreted as a null
         * value in the source data.
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only. The default value is '\N'.
         */
        public static final String TEXT_NULL_STRING = "text_null_string";

        /**
         * Specifies the character that should be interpreted as a field value
         * quoting character in the source data.  The character must appear at
         * beginning and end of field value to take effect.  Delimiters within
         * quoted fields are treated as literals and not delimiters.  Within a
         * quoted field, two consecutive quote characters will be interpreted
         * as a single literal quote character, effectively escaping it.  To
         * not have a quote character, specify an empty string.
         * <p>
         * For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
         * Options#FILE_TYPE FILE_TYPE} only. The default value is '"'.
         */
        public static final String TEXT_QUOTE_CHARACTER = "text_quote_character";

        /**
         * Add 'text_search' property to internally inferenced string columns.
         * Comma separated list of column names or '*' for all columns. To add
         * 'text_search' property only to string columns greater than or equal
         * to a minimum size, also set the {@link
         * Options#TEXT_SEARCH_MIN_COLUMN_LENGTH TEXT_SEARCH_MIN_COLUMN_LENGTH}
         */
        public static final String TEXT_SEARCH_COLUMNS = "text_search_columns";

        /**
         * Set the minimum column size for strings to apply the 'text_search'
         * property to. Used only when {@link Options#TEXT_SEARCH_COLUMNS
         * TEXT_SEARCH_COLUMNS} has a value.
         */
        public static final String TEXT_SEARCH_MIN_COLUMN_LENGTH = "text_search_min_column_length";

        /**
         * If set to {@link Options#TRUE TRUE}, truncate string values that are
         * longer than the column's type size.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String TRUNCATE_STRINGS = "truncate_strings";

        /**
         * If set to {@link Options#TRUE TRUE}, truncates the table specified
         * by {@link #getTableName() tableName} prior to loading the file(s).
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String TRUNCATE_TABLE = "truncate_table";

        public static final String TYPE_INFERENCE_MAX_RECORDS_READ = "type_inference_max_records_read";

        /**
         * Optimize type inferencing for either speed or accuracy.
         * Supported values:
         * <ul>
         *     <li>{@link Options#ACCURACY ACCURACY}: Scans data to get
         *         exactly-typed & sized columns for all data scanned.
         *     <li>{@link Options#SPEED SPEED}: Scans data and picks the widest
         *         possible column types so that 'all' values will fit with
         *         minimum data scanned
         * </ul>
         * The default value is {@link Options#SPEED SPEED}.
         */
        public static final String TYPE_INFERENCE_MODE = "type_inference_mode";

        /**
         * Scans data to get exactly-typed & sized columns for all data
         * scanned.
         */
        public static final String ACCURACY = "accuracy";

        /**
         * Scans data and picks the widest possible column types so that 'all'
         * values will fit with minimum data scanned
         */
        public static final String SPEED = "speed";

        /**
         * Remote SQL query from which data will be sourced
         */
        public static final String REMOTE_QUERY = "remote_query";

        /**
         * Name of column to be used for splitting {@link Options#REMOTE_QUERY
         * REMOTE_QUERY} into multiple sub-queries using the data distribution
         * of given column
         */
        public static final String REMOTE_QUERY_FILTER_COLUMN = "remote_query_filter_column";

        /**
         * Column on subscribed remote query result that will increase for new
         * records (e.g., TIMESTAMP).
         */
        public static final String REMOTE_QUERY_INCREASING_COLUMN = "remote_query_increasing_column";

        /**
         * Alias name for {@link Options#REMOTE_QUERY_FILTER_COLUMN
         * REMOTE_QUERY_FILTER_COLUMN}.
         */
        public static final String REMOTE_QUERY_PARTITION_COLUMN = "remote_query_partition_column";

        /**
         * Specifies the record collision policy for inserting into a table
         * with a <a href="../../../../../../concepts/tables/#primary-keys"
         * target="_top">primary key</a>. If set to {@link Options#TRUE TRUE},
         * any existing table record with primary key values that match those
         * of a record being inserted will be replaced by that new record (the
         * new data will be 'upserted'). If set to {@link Options#FALSE FALSE},
         * any existing table record with primary key values that match those
         * of a record being inserted will remain unchanged, while the new
         * record will be rejected and the error handled as determined by
         * {@link Options#IGNORE_EXISTING_PK IGNORE_EXISTING_PK} & {@link
         * Options#ERROR_HANDLING ERROR_HANDLING}.  If the specified table does
         * not have a primary key, then this option has no effect.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Upsert new records when primary
         *         keys match existing records
         *     <li>{@link Options#FALSE FALSE}: Reject new records when primary
         *         keys match existing records
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String UPDATE_ON_EXISTING_PK = "update_on_existing_pk";

        private Options() {  }
    }

    private String tableName;
    private List<String> filepaths;
    private Map<String, Map<String, String>> modifyColumns;
    private Map<String, String> createTableOptions;
    private Map<String, String> options;

    /**
     * Constructs a CreateTableExternalRequest object with default parameters.
     */
    public CreateTableExternalRequest() {
        tableName = "";
        filepaths = new ArrayList<>();
        modifyColumns = new LinkedHashMap<>();
        createTableOptions = new LinkedHashMap<>();
        options = new LinkedHashMap<>();
    }

    /**
     * Constructs a CreateTableExternalRequest object with the specified
     * parameters.
     *
     * @param tableName  Name of the table to be created, in
     *                   [schema_name.]table_name format, using standard <a
     *                   href="../../../../../../concepts/tables/#table-name-resolution"
     *                   target="_top">name resolution rules</a> and meeting <a
     *                   href="../../../../../../concepts/tables/#table-naming-criteria"
     *                   target="_top">table naming criteria</a>.
     * @param filepaths  A list of file paths from which data will be sourced;
     *                   For paths in <a href="../../../../../../tools/kifs/"
     *                   target="_top">KiFS</a>, use the URI prefix of kifs://
     *                   followed by the path to a file or directory. File
     *                   matching by prefix is supported, e.g. kifs://dir/file
     *                   would match dir/file_1 and dir/file_2. When prefix
     *                   matching is used, the path must start with a full,
     *                   valid KiFS directory name.  If an external data source
     *                   is specified in {@link Options#DATASOURCE_NAME
     *                   DATASOURCE_NAME}, these file paths must resolve to
     *                   accessible files at that data source location. Prefix
     *                   matching is supported. If the data source is hdfs,
     *                   prefixes must be aligned with directories, i.e.
     *                   partial file names will not match.  If no data source
     *                   is specified, the files are assumed to be local to the
     *                   database and must all be accessible to the gpudb user,
     *                   residing on the path (or relative to the path)
     *                   specified by the external files directory in the
     *                   Kinetica <a
     *                   href="../../../../../../config/#config-main-external-files"
     *                   target="_top">configuration file</a>. Wildcards (*)
     *                   can be used to specify a group of files.  Prefix
     *                   matching is supported, the prefixes must be aligned
     *                   with directories.  If the first path ends in .tsv, the
     *                   text delimiter will be defaulted to a tab character.
     *                   If the first path ends in .psv, the text delimiter
     *                   will be defaulted to a pipe character (|).
     * @param modifyColumns  Not implemented yet. The default value is an empty
     *                       {@link Map}.
     * @param createTableOptions  Options from {@link
     *                            com.gpudb.GPUdb#createTable(CreateTableRequest)
     *                            GPUdb.createTable}, allowing the structure of
     *                            the table to be defined independently of the
     *                            data source.
     *                            <ul>
     *                                <li>{@link CreateTableOptions#TYPE_ID
     *                                    TYPE_ID}: ID of a currently
     *                                    registered <a
     *                                    href="../../../../../../concepts/types/"
     *                                    target="_top">type</a>.
     *                                <li>{@link
     *                                    CreateTableOptions#NO_ERROR_IF_EXISTS
     *                                    NO_ERROR_IF_EXISTS}: If {@link
     *                                    CreateTableOptions#TRUE TRUE},
     *                                    prevents an error from occurring if
     *                                    the table already exists and is of
     *                                    the given type.  If a table with the
     *                                    same name but a different type
     *                                    exists, it is still an error.
     *                                    Supported values:
     *                                    <ul>
     *                                        <li>{@link
     *                                            CreateTableOptions#TRUE TRUE}
     *                                        <li>{@link
     *                                            CreateTableOptions#FALSE
     *                                            FALSE}
     *                                    </ul>
     *                                    The default value is {@link
     *                                    CreateTableOptions#FALSE FALSE}.
     *                                <li>{@link
     *                                    CreateTableOptions#IS_REPLICATED
     *                                    IS_REPLICATED}: Affects the <a
     *                                    href="../../../../../../concepts/tables/#distribution"
     *                                    target="_top">distribution scheme</a>
     *                                    for the table's data.  If {@link
     *                                    CreateTableOptions#TRUE TRUE} and the
     *                                    given table has no explicit <a
     *                                    href="../../../../../../concepts/tables/#shard-key"
     *                                    target="_top">shard key</a> defined,
     *                                    the table will be <a
     *                                    href="../../../../../../concepts/tables/#replication"
     *                                    target="_top">replicated</a>.  If
     *                                    {@link CreateTableOptions#FALSE
     *                                    FALSE}, the table will be <a
     *                                    href="../../../../../../concepts/tables/#sharding"
     *                                    target="_top">sharded</a> according
     *                                    to the shard key specified in the
     *                                    given {@link
     *                                    CreateTableOptions#TYPE_ID TYPE_ID},
     *                                    or <a
     *                                    href="../../../../../../concepts/tables/#random-sharding"
     *                                    target="_top">randomly sharded</a>,
     *                                    if no shard key is specified. Note
     *                                    that a type containing a shard key
     *                                    cannot be used to create a replicated
     *                                    table.
     *                                    Supported values:
     *                                    <ul>
     *                                        <li>{@link
     *                                            CreateTableOptions#TRUE TRUE}
     *                                        <li>{@link
     *                                            CreateTableOptions#FALSE
     *                                            FALSE}
     *                                    </ul>
     *                                    The default value is {@link
     *                                    CreateTableOptions#FALSE FALSE}.
     *                                <li>{@link
     *                                    CreateTableOptions#FOREIGN_KEYS
     *                                    FOREIGN_KEYS}: Semicolon-separated
     *                                    list of <a
     *                                    href="../../../../../../concepts/tables/#foreign-keys"
     *                                    target="_top">foreign keys</a>, of
     *                                    the format '(source_column_name [,
     *                                    ...]) references
     *                                    target_table_name(primary_key_column_name
     *                                    [, ...]) [as foreign_key_name]'.
     *                                <li>{@link
     *                                    CreateTableOptions#FOREIGN_SHARD_KEY
     *                                    FOREIGN_SHARD_KEY}: Foreign shard key
     *                                    of the format 'source_column
     *                                    references shard_by_column from
     *                                    target_table(primary_key_column)'.
     *                                <li>{@link
     *                                    CreateTableOptions#PARTITION_TYPE
     *                                    PARTITION_TYPE}: <a
     *                                    href="../../../../../../concepts/tables/#partitioning"
     *                                    target="_top">Partitioning</a> scheme
     *                                    to use.
     *                                    Supported values:
     *                                    <ul>
     *                                        <li>{@link
     *                                            CreateTableOptions#RANGE
     *                                            RANGE}: Use <a
     *                                            href="../../../../../../concepts/tables/#partitioning-by-range"
     *                                            target="_top">range
     *                                            partitioning</a>.
     *                                        <li>{@link
     *                                            CreateTableOptions#INTERVAL
     *                                            INTERVAL}: Use <a
     *                                            href="../../../../../../concepts/tables/#partitioning-by-interval"
     *                                            target="_top">interval
     *                                            partitioning</a>.
     *                                        <li>{@link
     *                                            CreateTableOptions#LIST
     *                                            LIST}: Use <a
     *                                            href="../../../../../../concepts/tables/#partitioning-by-list"
     *                                            target="_top">list
     *                                            partitioning</a>.
     *                                        <li>{@link
     *                                            CreateTableOptions#HASH
     *                                            HASH}: Use <a
     *                                            href="../../../../../../concepts/tables/#partitioning-by-hash"
     *                                            target="_top">hash
     *                                            partitioning</a>.
     *                                        <li>{@link
     *                                            CreateTableOptions#SERIES
     *                                            SERIES}: Use <a
     *                                            href="../../../../../../concepts/tables/#partitioning-by-series"
     *                                            target="_top">series
     *                                            partitioning</a>.
     *                                    </ul>
     *                                <li>{@link
     *                                    CreateTableOptions#PARTITION_KEYS
     *                                    PARTITION_KEYS}: Comma-separated list
     *                                    of partition keys, which are the
     *                                    columns or column expressions by
     *                                    which records will be assigned to
     *                                    partitions defined by {@link
     *                                    CreateTableOptions#PARTITION_DEFINITIONS
     *                                    PARTITION_DEFINITIONS}.
     *                                <li>{@link
     *                                    CreateTableOptions#PARTITION_DEFINITIONS
     *                                    PARTITION_DEFINITIONS}:
     *                                    Comma-separated list of partition
     *                                    definitions, whose format depends on
     *                                    the choice of {@link
     *                                    CreateTableOptions#PARTITION_TYPE
     *                                    PARTITION_TYPE}.  See <a
     *                                    href="../../../../../../concepts/tables/#partitioning-by-range"
     *                                    target="_top">range partitioning</a>,
     *                                    <a
     *                                    href="../../../../../../concepts/tables/#partitioning-by-interval"
     *                                    target="_top">interval
     *                                    partitioning</a>, <a
     *                                    href="../../../../../../concepts/tables/#partitioning-by-list"
     *                                    target="_top">list partitioning</a>,
     *                                    <a
     *                                    href="../../../../../../concepts/tables/#partitioning-by-hash"
     *                                    target="_top">hash partitioning</a>,
     *                                    or <a
     *                                    href="../../../../../../concepts/tables/#partitioning-by-series"
     *                                    target="_top">series partitioning</a>
     *                                    for example formats.
     *                                <li>{@link
     *                                    CreateTableOptions#IS_AUTOMATIC_PARTITION
     *                                    IS_AUTOMATIC_PARTITION}: If {@link
     *                                    CreateTableOptions#TRUE TRUE}, a new
     *                                    partition will be created for values
     *                                    which don't fall into an existing
     *                                    partition.  Currently, only supported
     *                                    for <a
     *                                    href="../../../../../../concepts/tables/#partitioning-by-list"
     *                                    target="_top">list partitions</a>.
     *                                    Supported values:
     *                                    <ul>
     *                                        <li>{@link
     *                                            CreateTableOptions#TRUE TRUE}
     *                                        <li>{@link
     *                                            CreateTableOptions#FALSE
     *                                            FALSE}
     *                                    </ul>
     *                                    The default value is {@link
     *                                    CreateTableOptions#FALSE FALSE}.
     *                                <li>{@link CreateTableOptions#TTL TTL}:
     *                                    Sets the <a
     *                                    href="../../../../../../concepts/ttl/"
     *                                    target="_top">TTL</a> of the table
     *                                    specified in {@code tableName}.
     *                                <li>{@link CreateTableOptions#CHUNK_SIZE
     *                                    CHUNK_SIZE}: Indicates the number of
     *                                    records per chunk to be used for this
     *                                    table.
     *                                <li>{@link
     *                                    CreateTableOptions#CHUNK_COLUMN_MAX_MEMORY
     *                                    CHUNK_COLUMN_MAX_MEMORY}: Indicates
     *                                    the target maximum data size for each
     *                                    column in a chunk to be used for this
     *                                    table.
     *                                <li>{@link
     *                                    CreateTableOptions#CHUNK_MAX_MEMORY
     *                                    CHUNK_MAX_MEMORY}: Indicates the
     *                                    target maximum data size for all
     *                                    columns in a chunk to be used for
     *                                    this table.
     *                                <li>{@link
     *                                    CreateTableOptions#IS_RESULT_TABLE
     *                                    IS_RESULT_TABLE}: Indicates whether
     *                                    the table is a <a
     *                                    href="../../../../../../concepts/tables_memory_only/"
     *                                    target="_top">memory-only table</a>.
     *                                    A result table cannot contain columns
     *                                    with text_search <a
     *                                    href="../../../../../../concepts/types/#data-handling"
     *                                    target="_top">data-handling</a>, and
     *                                    it will not be retained if the server
     *                                    is restarted.
     *                                    Supported values:
     *                                    <ul>
     *                                        <li>{@link
     *                                            CreateTableOptions#TRUE TRUE}
     *                                        <li>{@link
     *                                            CreateTableOptions#FALSE
     *                                            FALSE}
     *                                    </ul>
     *                                    The default value is {@link
     *                                    CreateTableOptions#FALSE FALSE}.
     *                                <li>{@link
     *                                    CreateTableOptions#STRATEGY_DEFINITION
     *                                    STRATEGY_DEFINITION}: The <a
     *                                    href="../../../../../../rm/concepts/#tier-strategies"
     *                                    target="_top">tier strategy</a> for
     *                                    the table and its columns.
     *                                <li>{@link
     *                                    CreateTableOptions#COMPRESSION_CODEC
     *                                    COMPRESSION_CODEC}: The default <a
     *                                    href="../../../../../../concepts/column_compression/"
     *                                    target="_top">compression codec</a>
     *                                    for this table's columns.
     *                            </ul>
     *                            The default value is an empty {@link Map}.
     * @param options  Optional parameters.
     *                 <ul>
     *                     <li>{@link Options#BAD_RECORD_TABLE_NAME
     *                         BAD_RECORD_TABLE_NAME}: Name of a table to which
     *                         records that were rejected are written. The
     *                         bad-record-table has the following columns:
     *                         line_number (long), line_rejected (string),
     *                         error_message (string).  When {@link
     *                         Options#ERROR_HANDLING ERROR_HANDLING} is {@link
     *                         Options#ABORT ABORT}, bad records table is not
     *                         populated.
     *                     <li>{@link Options#BAD_RECORD_TABLE_LIMIT
     *                         BAD_RECORD_TABLE_LIMIT}: A positive integer
     *                         indicating the maximum number of records that
     *                         can be written to the bad-record-table. The
     *                         default value is '10000'.
     *                     <li>{@link Options#BAD_RECORD_TABLE_LIMIT_PER_INPUT
     *                         BAD_RECORD_TABLE_LIMIT_PER_INPUT}: For
     *                         subscriptions, a positive integer indicating the
     *                         maximum number of records that can be written to
     *                         the bad-record-table per file/payload. Default
     *                         value will be {@link
     *                         Options#BAD_RECORD_TABLE_LIMIT
     *                         BAD_RECORD_TABLE_LIMIT} and total size of the
     *                         table per rank is limited to {@link
     *                         Options#BAD_RECORD_TABLE_LIMIT
     *                         BAD_RECORD_TABLE_LIMIT}.
     *                     <li>{@link Options#BATCH_SIZE BATCH_SIZE}: Number of
     *                         records to insert per batch when inserting data.
     *                         The default value is '50000'.
     *                     <li>{@link Options#COLUMN_FORMATS COLUMN_FORMATS}:
     *                         For each target column specified, applies the
     *                         column-property-bound format to the source data
     *                         loaded into that column.  Each column format
     *                         will contain a mapping of one or more of its
     *                         column properties to an appropriate format for
     *                         each property.  Currently supported column
     *                         properties include date, time, & datetime. The
     *                         parameter value must be formatted as a JSON
     *                         string of maps of column names to maps of column
     *                         properties to their corresponding column
     *                         formats, e.g., '{ "order_date" : { "date" :
     *                         "%Y.%m.%d" }, "order_time" : { "time" :
     *                         "%H:%M:%S" } }'.  See {@link
     *                         Options#DEFAULT_COLUMN_FORMATS
     *                         DEFAULT_COLUMN_FORMATS} for valid format syntax.
     *                     <li>{@link Options#COLUMNS_TO_LOAD COLUMNS_TO_LOAD}:
     *                         Specifies a comma-delimited list of columns from
     *                         the source data to load.  If more than one file
     *                         is being loaded, this list applies to all files.
     *                         Column numbers can be specified discretely or as
     *                         a range.  For example, a value of '5,7,1..3'
     *                         will insert values from the fifth column in the
     *                         source data into the first column in the target
     *                         table, from the seventh column in the source
     *                         data into the second column in the target table,
     *                         and from the first through third columns in the
     *                         source data into the third through fifth columns
     *                         in the target table.  If the source data
     *                         contains a header, column names matching the
     *                         file header names may be provided instead of
     *                         column numbers.  If the target table doesn't
     *                         exist, the table will be created with the
     *                         columns in this order.  If the target table does
     *                         exist with columns in a different order than the
     *                         source data, this list can be used to match the
     *                         order of the target table.  For example, a value
     *                         of 'C, B, A' will create a three column table
     *                         with column C, followed by column B, followed by
     *                         column A; or will insert those fields in that
     *                         order into a table created with columns in that
     *                         order.  If the target table exists, the column
     *                         names must match the source data field names for
     *                         a name-mapping to be successful.  Mutually
     *                         exclusive with {@link Options#COLUMNS_TO_SKIP
     *                         COLUMNS_TO_SKIP}.
     *                     <li>{@link Options#COLUMNS_TO_SKIP COLUMNS_TO_SKIP}:
     *                         Specifies a comma-delimited list of columns from
     *                         the source data to skip.  Mutually exclusive
     *                         with {@link Options#COLUMNS_TO_LOAD
     *                         COLUMNS_TO_LOAD}.
     *                     <li>{@link Options#COMPRESSION_TYPE
     *                         COMPRESSION_TYPE}: Source data compression type.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#NONE NONE}: No
     *                                 compression.
     *                             <li>{@link Options#AUTO AUTO}: Auto detect
     *                                 compression type
     *                             <li>{@link Options#GZIP GZIP}: gzip file
     *                                 compression.
     *                             <li>{@link Options#BZIP2 BZIP2}: bzip2 file
     *                                 compression.
     *                         </ul>
     *                         The default value is {@link Options#AUTO AUTO}.
     *                     <li>{@link Options#DATASOURCE_NAME DATASOURCE_NAME}:
     *                         Name of an existing external data source from
     *                         which data file(s) specified in {@code
     *                         filepaths} will be loaded
     *                     <li>{@link Options#DEFAULT_COLUMN_FORMATS
     *                         DEFAULT_COLUMN_FORMATS}: Specifies the default
     *                         format to be applied to source data loaded into
     *                         columns with the corresponding column property.
     *                         Currently supported column properties include
     *                         date, time, & datetime.  This default
     *                         column-property-bound format can be overridden
     *                         by specifying a column property & format for a
     *                         given target column in {@link
     *                         Options#COLUMN_FORMATS COLUMN_FORMATS}. For each
     *                         specified annotation, the format will apply to
     *                         all columns with that annotation unless a custom
     *                         {@link Options#COLUMN_FORMATS COLUMN_FORMATS}
     *                         for that annotation is specified.  The parameter
     *                         value must be formatted as a JSON string that is
     *                         a map of column properties to their respective
     *                         column formats, e.g., '{ "date" : "%Y.%m.%d",
     *                         "time" : "%H:%M:%S" }'.  Column formats are
     *                         specified as a string of control characters and
     *                         plain text. The supported control characters are
     *                         'Y', 'm', 'd', 'H', 'M', 'S', and 's', which
     *                         follow the Linux 'strptime()' specification, as
     *                         well as 's', which specifies seconds and
     *                         fractional seconds (though the fractional
     *                         component will be truncated past milliseconds).
     *                         Formats for the 'date' annotation must include
     *                         the 'Y', 'm', and 'd' control characters.
     *                         Formats for the 'time' annotation must include
     *                         the 'H', 'M', and either 'S' or 's' (but not
     *                         both) control characters. Formats for the
     *                         'datetime' annotation meet both the 'date' and
     *                         'time' control character requirements. For
     *                         example, '{"datetime" : "%m/%d/%Y %H:%M:%S" }'
     *                         would be used to interpret text as "05/04/2000
     *                         12:12:11"
     *                     <li>{@link Options#ERROR_HANDLING ERROR_HANDLING}:
     *                         Specifies how errors should be handled upon
     *                         insertion.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#PERMISSIVE PERMISSIVE}:
     *                                 Records with missing columns are
     *                                 populated with nulls if possible;
     *                                 otherwise, the malformed records are
     *                                 skipped.
     *                             <li>{@link Options#IGNORE_BAD_RECORDS
     *                                 IGNORE_BAD_RECORDS}: Malformed records
     *                                 are skipped.
     *                             <li>{@link Options#ABORT ABORT}: Stops
     *                                 current insertion and aborts entire
     *                                 operation when an error is encountered.
     *                                 Primary key collisions are considered
     *                                 abortable errors in this mode.
     *                         </ul>
     *                         The default value is {@link Options#ABORT
     *                         ABORT}.
     *                     <li>{@link Options#EXTERNAL_TABLE_TYPE
     *                         EXTERNAL_TABLE_TYPE}: Specifies whether the
     *                         external table holds a local copy of the
     *                         external data.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#MATERIALIZED
     *                                 MATERIALIZED}: Loads a copy of the
     *                                 external data into the database,
     *                                 refreshed on demand
     *                             <li>{@link Options#LOGICAL LOGICAL}:
     *                                 External data will not be loaded into
     *                                 the database; the data will be retrieved
     *                                 from the source upon servicing each
     *                                 query against the external table
     *                         </ul>
     *                         The default value is {@link Options#MATERIALIZED
     *                         MATERIALIZED}.
     *                     <li>{@link Options#FILE_TYPE FILE_TYPE}: Specifies
     *                         the type of the file(s) whose records will be
     *                         inserted.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#AVRO AVRO}: Avro file
     *                                 format
     *                             <li>{@link Options#DELIMITED_TEXT
     *                                 DELIMITED_TEXT}: Delimited text file
     *                                 format; e.g., CSV, TSV, PSV, etc.
     *                             <li>{@link Options#GDB GDB}: Esri/GDB file
     *                                 format
     *                             <li>{@link Options#JSON JSON}: Json file
     *                                 format
     *                             <li>{@link Options#PARQUET PARQUET}: Apache
     *                                 Parquet file format
     *                             <li>{@link Options#SHAPEFILE SHAPEFILE}:
     *                                 ShapeFile file format
     *                         </ul>
     *                         The default value is {@link
     *                         Options#DELIMITED_TEXT DELIMITED_TEXT}.
     *                     <li>{@link Options#FLATTEN_COLUMNS FLATTEN_COLUMNS}:
     *                         Specifies how to handle nested columns.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Break up
     *                                 nested columns to multiple columns
     *                             <li>{@link Options#FALSE FALSE}: Treat
     *                                 nested columns as json columns instead
     *                                 of flattening
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#GDAL_CONFIGURATION_OPTIONS
     *                         GDAL_CONFIGURATION_OPTIONS}: Comma separated
     *                         list of gdal conf options, for the specific
     *                         requests: key=value
     *                     <li>{@link Options#IGNORE_EXISTING_PK
     *                         IGNORE_EXISTING_PK}: Specifies the record
     *                         collision error-suppression policy for inserting
     *                         into a table with a <a
     *                         href="../../../../../../concepts/tables/#primary-keys"
     *                         target="_top">primary key</a>, only used when
     *                         not in upsert mode (upsert mode is disabled when
     *                         {@link Options#UPDATE_ON_EXISTING_PK
     *                         UPDATE_ON_EXISTING_PK} is {@link Options#FALSE
     *                         FALSE}).  If set to {@link Options#TRUE TRUE},
     *                         any record being inserted that is rejected for
     *                         having primary key values that match those of an
     *                         existing table record will be ignored with no
     *                         error generated.  If {@link Options#FALSE
     *                         FALSE}, the rejection of any record for having
     *                         primary key values matching an existing record
     *                         will result in an error being reported, as
     *                         determined by {@link Options#ERROR_HANDLING
     *                         ERROR_HANDLING}.  If the specified table does
     *                         not have a primary key or if upsert mode is in
     *                         effect ({@link Options#UPDATE_ON_EXISTING_PK
     *                         UPDATE_ON_EXISTING_PK} is {@link Options#TRUE
     *                         TRUE}), then this option has no effect.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Ignore new
     *                                 records whose primary key values collide
     *                                 with those of existing records
     *                             <li>{@link Options#FALSE FALSE}: Treat as
     *                                 errors any new records whose primary key
     *                                 values collide with those of existing
     *                                 records
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#INGESTION_MODE INGESTION_MODE}:
     *                         Whether to do a full load, dry run, or perform a
     *                         type inference on the source data.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#FULL FULL}: Run a type
     *                                 inference on the source data (if needed)
     *                                 and ingest
     *                             <li>{@link Options#DRY_RUN DRY_RUN}: Does
     *                                 not load data, but walks through the
     *                                 source data and determines the number of
     *                                 valid records, taking into account the
     *                                 current mode of {@link
     *                                 Options#ERROR_HANDLING ERROR_HANDLING}.
     *                             <li>{@link Options#TYPE_INFERENCE_ONLY
     *                                 TYPE_INFERENCE_ONLY}: Infer the type of
     *                                 the source data and return, without
     *                                 ingesting any data.  The inferred type
     *                                 is returned in the response.
     *                         </ul>
     *                         The default value is {@link Options#FULL FULL}.
     *                     <li>{@link Options#JDBC_FETCH_SIZE JDBC_FETCH_SIZE}:
     *                         The JDBC fetch size, which determines how many
     *                         rows to fetch per round trip. The default value
     *                         is '50000'.
     *                     <li>{@link Options#KAFKA_CONSUMERS_PER_RANK
     *                         KAFKA_CONSUMERS_PER_RANK}: Number of Kafka
     *                         consumer threads per rank (valid range 1-6). The
     *                         default value is '1'.
     *                     <li>{@link Options#KAFKA_GROUP_ID KAFKA_GROUP_ID}:
     *                         The group id to be used when consuming data from
     *                         a Kafka topic (valid only for Kafka datasource
     *                         subscriptions).
     *                     <li>{@link Options#KAFKA_OFFSET_RESET_POLICY
     *                         KAFKA_OFFSET_RESET_POLICY}: Policy to determine
     *                         whether the Kafka data consumption starts either
     *                         at earliest offset or latest offset.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#EARLIEST EARLIEST}
     *                             <li>{@link Options#LATEST LATEST}
     *                         </ul>
     *                         The default value is {@link Options#EARLIEST
     *                         EARLIEST}.
     *                     <li>{@link Options#KAFKA_OPTIMISTIC_INGEST
     *                         KAFKA_OPTIMISTIC_INGEST}: Enable optimistic
     *                         ingestion where Kafka topic offsets and table
     *                         data are committed independently to achieve
     *                         parallelism.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#KAFKA_SUBSCRIPTION_CANCEL_AFTER
     *                         KAFKA_SUBSCRIPTION_CANCEL_AFTER}: Sets the Kafka
     *                         subscription lifespan (in minutes). Expired
     *                         subscription will be cancelled automatically.
     *                     <li>{@link
     *                         Options#KAFKA_TYPE_INFERENCE_FETCH_TIMEOUT
     *                         KAFKA_TYPE_INFERENCE_FETCH_TIMEOUT}: Maximum
     *                         time to collect Kafka messages before type
     *                         inferencing on the set of them.
     *                     <li>{@link Options#LAYER LAYER}: Geo files layer(s)
     *                         name(s): comma separated.
     *                     <li>{@link Options#LOADING_MODE LOADING_MODE}:
     *                         Scheme for distributing the extraction and
     *                         loading of data from the source data file(s).
     *                         This option applies only when loading files that
     *                         are local to the database.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#HEAD HEAD}: The head node
     *                                 loads all data. All files must be
     *                                 available to the head node.
     *                             <li>{@link Options#DISTRIBUTED_SHARED
     *                                 DISTRIBUTED_SHARED}: The head node
     *                                 coordinates loading data by worker
     *                                 processes across all nodes from shared
     *                                 files available to all workers.  NOTE:
     *                                 Instead of existing on a shared source,
     *                                 the files can be duplicated on a source
     *                                 local to each host to improve
     *                                 performance, though the files must
     *                                 appear as the same data set from the
     *                                 perspective of all hosts performing the
     *                                 load.
     *                             <li>{@link Options#DISTRIBUTED_LOCAL
     *                                 DISTRIBUTED_LOCAL}: A single worker
     *                                 process on each node loads all files
     *                                 that are available to it. This option
     *                                 works best when each worker loads files
     *                                 from its own file system, to maximize
     *                                 performance. In order to avoid data
     *                                 duplication, either each worker
     *                                 performing the load needs to have
     *                                 visibility to a set of files unique to
     *                                 it (no file is visible to more than one
     *                                 node) or the target table needs to have
     *                                 a primary key (which will allow the
     *                                 worker to automatically deduplicate
     *                                 data).  NOTE:  If the target table
     *                                 doesn't exist, the table structure will
     *                                 be determined by the head node. If the
     *                                 head node has no files local to it, it
     *                                 will be unable to determine the
     *                                 structure and the request will fail.  If
     *                                 the head node is configured to have no
     *                                 worker processes, no data strictly
     *                                 accessible to the head node will be
     *                                 loaded.
     *                         </ul>
     *                         The default value is {@link Options#HEAD HEAD}.
     *                     <li>{@link Options#LOCAL_TIME_OFFSET
     *                         LOCAL_TIME_OFFSET}: Apply an offset to Avro
     *                         local timestamp columns.
     *                     <li>{@link Options#MAX_RECORDS_TO_LOAD
     *                         MAX_RECORDS_TO_LOAD}: Limit the number of
     *                         records to load in this request: if this number
     *                         is larger than {@link Options#BATCH_SIZE
     *                         BATCH_SIZE}, then the number of records loaded
     *                         will be limited to the next whole number of
     *                         {@link Options#BATCH_SIZE BATCH_SIZE} (per
     *                         working thread).
     *                     <li>{@link Options#NUM_TASKS_PER_RANK
     *                         NUM_TASKS_PER_RANK}: Number of tasks for reading
     *                         file per rank. Default will be system
     *                         configuration parameter,
     *                         external_file_reader_num_tasks.
     *                     <li>{@link Options#POLL_INTERVAL POLL_INTERVAL}: If
     *                         {@link Options#TRUE TRUE}, the number of seconds
     *                         between attempts to load external files into the
     *                         table.  If zero, polling will be continuous as
     *                         long as data is found.  If no data is found, the
     *                         interval will steadily increase to a maximum of
     *                         60 seconds. The default value is '0'.
     *                     <li>{@link Options#PRIMARY_KEYS PRIMARY_KEYS}: Comma
     *                         separated list of column names to set as primary
     *                         keys, when not specified in the type.
     *                     <li>{@link Options#REFRESH_METHOD REFRESH_METHOD}:
     *                         Method by which the table can be refreshed from
     *                         its source data.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#MANUAL MANUAL}: Refresh
     *                                 only occurs when manually requested by
     *                                 invoking the refresh action of {@link
     *                                 com.gpudb.GPUdb#alterTable(AlterTableRequest)
     *                                 GPUdb.alterTable} on this table.
     *                             <li>{@link Options#ON_START ON_START}:
     *                                 Refresh table on database startup and
     *                                 when manually requested by invoking the
     *                                 refresh action of {@link
     *                                 com.gpudb.GPUdb#alterTable(AlterTableRequest)
     *                                 GPUdb.alterTable} on this table.
     *                         </ul>
     *                         The default value is {@link Options#MANUAL
     *                         MANUAL}.
     *                     <li>{@link
     *                         Options#SCHEMA_REGISTRY_CONNECTION_RETRIES
     *                         SCHEMA_REGISTRY_CONNECTION_RETRIES}: Confluent
     *                         Schema registry connection timeout (in Secs)
     *                     <li>{@link
     *                         Options#SCHEMA_REGISTRY_CONNECTION_TIMEOUT
     *                         SCHEMA_REGISTRY_CONNECTION_TIMEOUT}: Confluent
     *                         Schema registry connection timeout (in Secs)
     *                     <li>{@link
     *                         Options#SCHEMA_REGISTRY_MAX_CONSECUTIVE_CONNECTION_FAILURES
     *                         SCHEMA_REGISTRY_MAX_CONSECUTIVE_CONNECTION_FAILURES}:
     *                         Max records to skip due to SR connection
     *                         failures, before failing
     *                     <li>{@link
     *                         Options#MAX_CONSECUTIVE_INVALID_SCHEMA_FAILURE
     *                         MAX_CONSECUTIVE_INVALID_SCHEMA_FAILURE}: Max
     *                         records to skip due to schema related errors,
     *                         before failing
     *                     <li>{@link Options#SCHEMA_REGISTRY_SCHEMA_NAME
     *                         SCHEMA_REGISTRY_SCHEMA_NAME}: Name of the Avro
     *                         schema in the schema registry to use when
     *                         reading Avro records.
     *                     <li>{@link Options#SHARD_KEYS SHARD_KEYS}: Comma
     *                         separated list of column names to set as shard
     *                         keys, when not specified in the type.
     *                     <li>{@link Options#SKIP_LINES SKIP_LINES}: Skip a
     *                         number of lines from the beginning of the file.
     *                     <li>{@link Options#START_OFFSETS START_OFFSETS}:
     *                         Starting offsets by partition to fetch from
     *                         kafka. A comma separated list of
     *                         partition:offset pairs.
     *                     <li>{@link Options#SUBSCRIBE SUBSCRIBE}:
     *                         Continuously poll the data source to check for
     *                         new data and load it into the table.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#TABLE_INSERT_MODE
     *                         TABLE_INSERT_MODE}: Insertion scheme to use when
     *                         inserting records from multiple shapefiles.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#SINGLE SINGLE}: Insert
     *                                 all records into a single table.
     *                             <li>{@link Options#TABLE_PER_FILE
     *                                 TABLE_PER_FILE}: Insert records from
     *                                 each file into a new table corresponding
     *                                 to that file.
     *                         </ul>
     *                         The default value is {@link Options#SINGLE
     *                         SINGLE}.
     *                     <li>{@link Options#TEXT_COMMENT_STRING
     *                         TEXT_COMMENT_STRING}: Specifies the character
     *                         string that should be interpreted as a comment
     *                         line prefix in the source data.  All lines in
     *                         the data starting with the provided string are
     *                         ignored.  For {@link Options#DELIMITED_TEXT
     *                         DELIMITED_TEXT} {@link Options#FILE_TYPE
     *                         FILE_TYPE} only. The default value is '#'.
     *                     <li>{@link Options#TEXT_DELIMITER TEXT_DELIMITER}:
     *                         Specifies the character delimiting field values
     *                         in the source data and field names in the header
     *                         (if present).  For {@link Options#DELIMITED_TEXT
     *                         DELIMITED_TEXT} {@link Options#FILE_TYPE
     *                         FILE_TYPE} only. The default value is ','.
     *                     <li>{@link Options#TEXT_ESCAPE_CHARACTER
     *                         TEXT_ESCAPE_CHARACTER}: Specifies the character
     *                         that is used to escape other characters in the
     *                         source data.  An 'a', 'b', 'f', 'n', 'r', 't',
     *                         or 'v' preceded by an escape character will be
     *                         interpreted as the ASCII bell, backspace, form
     *                         feed, line feed, carriage return, horizontal
     *                         tab, & vertical tab, respectively.  For example,
     *                         the escape character followed by an 'n' will be
     *                         interpreted as a newline within a field value.
     *                         The escape character can also be used to escape
     *                         the quoting character, and will be treated as an
     *                         escape character whether it is within a quoted
     *                         field value or not.  For {@link
     *                         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
     *                         Options#FILE_TYPE FILE_TYPE} only.
     *                     <li>{@link Options#TEXT_HAS_HEADER TEXT_HAS_HEADER}:
     *                         Indicates whether the source data contains a
     *                         header row.  For {@link Options#DELIMITED_TEXT
     *                         DELIMITED_TEXT} {@link Options#FILE_TYPE
     *                         FILE_TYPE} only.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#TRUE TRUE}.
     *                     <li>{@link Options#TEXT_HEADER_PROPERTY_DELIMITER
     *                         TEXT_HEADER_PROPERTY_DELIMITER}: Specifies the
     *                         delimiter for <a
     *                         href="../../../../../../concepts/types/#column-properties"
     *                         target="_top">column properties</a> in the
     *                         header row (if present).  Cannot be set to same
     *                         value as {@link Options#TEXT_DELIMITER
     *                         TEXT_DELIMITER}.  For {@link
     *                         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
     *                         Options#FILE_TYPE FILE_TYPE} only. The default
     *                         value is '|'.
     *                     <li>{@link Options#TEXT_NULL_STRING
     *                         TEXT_NULL_STRING}: Specifies the character
     *                         string that should be interpreted as a null
     *                         value in the source data.  For {@link
     *                         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
     *                         Options#FILE_TYPE FILE_TYPE} only. The default
     *                         value is '\N'.
     *                     <li>{@link Options#TEXT_QUOTE_CHARACTER
     *                         TEXT_QUOTE_CHARACTER}: Specifies the character
     *                         that should be interpreted as a field value
     *                         quoting character in the source data.  The
     *                         character must appear at beginning and end of
     *                         field value to take effect.  Delimiters within
     *                         quoted fields are treated as literals and not
     *                         delimiters.  Within a quoted field, two
     *                         consecutive quote characters will be interpreted
     *                         as a single literal quote character, effectively
     *                         escaping it.  To not have a quote character,
     *                         specify an empty string.  For {@link
     *                         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
     *                         Options#FILE_TYPE FILE_TYPE} only. The default
     *                         value is '"'.
     *                     <li>{@link Options#TEXT_SEARCH_COLUMNS
     *                         TEXT_SEARCH_COLUMNS}: Add 'text_search' property
     *                         to internally inferenced string columns. Comma
     *                         separated list of column names or '*' for all
     *                         columns. To add 'text_search' property only to
     *                         string columns greater than or equal to a
     *                         minimum size, also set the {@link
     *                         Options#TEXT_SEARCH_MIN_COLUMN_LENGTH
     *                         TEXT_SEARCH_MIN_COLUMN_LENGTH}
     *                     <li>{@link Options#TEXT_SEARCH_MIN_COLUMN_LENGTH
     *                         TEXT_SEARCH_MIN_COLUMN_LENGTH}: Set the minimum
     *                         column size for strings to apply the
     *                         'text_search' property to. Used only when {@link
     *                         Options#TEXT_SEARCH_COLUMNS TEXT_SEARCH_COLUMNS}
     *                         has a value.
     *                     <li>{@link Options#TRUNCATE_STRINGS
     *                         TRUNCATE_STRINGS}: If set to {@link Options#TRUE
     *                         TRUE}, truncate string values that are longer
     *                         than the column's type size.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#TRUNCATE_TABLE TRUNCATE_TABLE}:
     *                         If set to {@link Options#TRUE TRUE}, truncates
     *                         the table specified by {@code tableName} prior
     *                         to loading the file(s).
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#TYPE_INFERENCE_MAX_RECORDS_READ
     *                         TYPE_INFERENCE_MAX_RECORDS_READ}
     *                     <li>{@link Options#TYPE_INFERENCE_MODE
     *                         TYPE_INFERENCE_MODE}: Optimize type inferencing
     *                         for either speed or accuracy.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#ACCURACY ACCURACY}: Scans
     *                                 data to get exactly-typed & sized
     *                                 columns for all data scanned.
     *                             <li>{@link Options#SPEED SPEED}: Scans data
     *                                 and picks the widest possible column
     *                                 types so that 'all' values will fit with
     *                                 minimum data scanned
     *                         </ul>
     *                         The default value is {@link Options#SPEED
     *                         SPEED}.
     *                     <li>{@link Options#REMOTE_QUERY REMOTE_QUERY}:
     *                         Remote SQL query from which data will be sourced
     *                     <li>{@link Options#REMOTE_QUERY_FILTER_COLUMN
     *                         REMOTE_QUERY_FILTER_COLUMN}: Name of column to
     *                         be used for splitting {@link
     *                         Options#REMOTE_QUERY REMOTE_QUERY} into multiple
     *                         sub-queries using the data distribution of given
     *                         column
     *                     <li>{@link Options#REMOTE_QUERY_INCREASING_COLUMN
     *                         REMOTE_QUERY_INCREASING_COLUMN}: Column on
     *                         subscribed remote query result that will
     *                         increase for new records (e.g., TIMESTAMP).
     *                     <li>{@link Options#REMOTE_QUERY_PARTITION_COLUMN
     *                         REMOTE_QUERY_PARTITION_COLUMN}: Alias name for
     *                         {@link Options#REMOTE_QUERY_FILTER_COLUMN
     *                         REMOTE_QUERY_FILTER_COLUMN}.
     *                     <li>{@link Options#UPDATE_ON_EXISTING_PK
     *                         UPDATE_ON_EXISTING_PK}: Specifies the record
     *                         collision policy for inserting into a table with
     *                         a <a
     *                         href="../../../../../../concepts/tables/#primary-keys"
     *                         target="_top">primary key</a>. If set to {@link
     *                         Options#TRUE TRUE}, any existing table record
     *                         with primary key values that match those of a
     *                         record being inserted will be replaced by that
     *                         new record (the new data will be 'upserted'). If
     *                         set to {@link Options#FALSE FALSE}, any existing
     *                         table record with primary key values that match
     *                         those of a record being inserted will remain
     *                         unchanged, while the new record will be rejected
     *                         and the error handled as determined by {@link
     *                         Options#IGNORE_EXISTING_PK IGNORE_EXISTING_PK} &
     *                         {@link Options#ERROR_HANDLING ERROR_HANDLING}.
     *                         If the specified table does not have a primary
     *                         key, then this option has no effect.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Upsert new
     *                                 records when primary keys match existing
     *                                 records
     *                             <li>{@link Options#FALSE FALSE}: Reject new
     *                                 records when primary keys match existing
     *                                 records
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                 </ul>
     *                 The default value is an empty {@link Map}.
     */
    public CreateTableExternalRequest(String tableName, List<String> filepaths, Map<String, Map<String, String>> modifyColumns, Map<String, String> createTableOptions, Map<String, String> options) {
        this.tableName = (tableName == null) ? "" : tableName;
        this.filepaths = (filepaths == null) ? new ArrayList<String>() : filepaths;
        this.modifyColumns = (modifyColumns == null) ? new LinkedHashMap<String, Map<String, String>>() : modifyColumns;
        this.createTableOptions = (createTableOptions == null) ? new LinkedHashMap<String, String>() : createTableOptions;
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
    }

    /**
     * Name of the table to be created, in [schema_name.]table_name format,
     * using standard <a
     * href="../../../../../../concepts/tables/#table-name-resolution"
     * target="_top">name resolution rules</a> and meeting <a
     * href="../../../../../../concepts/tables/#table-naming-criteria"
     * target="_top">table naming criteria</a>.
     *
     * @return The current value of {@code tableName}.
     */
    public String getTableName() {
        return tableName;
    }

    /**
     * Name of the table to be created, in [schema_name.]table_name format,
     * using standard <a
     * href="../../../../../../concepts/tables/#table-name-resolution"
     * target="_top">name resolution rules</a> and meeting <a
     * href="../../../../../../concepts/tables/#table-naming-criteria"
     * target="_top">table naming criteria</a>.
     *
     * @param tableName  The new value for {@code tableName}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public CreateTableExternalRequest setTableName(String tableName) {
        this.tableName = (tableName == null) ? "" : tableName;
        return this;
    }

    /**
     * A list of file paths from which data will be sourced;
     * <p>
     * For paths in <a href="../../../../../../tools/kifs/"
     * target="_top">KiFS</a>, use the URI prefix of kifs:// followed by the
     * path to a file or directory. File matching by prefix is supported,
     * e.g.&nbsp;kifs://dir/file would match dir/file_1 and dir/file_2. When
     * prefix matching is used, the path must start with a full, valid KiFS
     * directory name.
     * <p>
     * If an external data source is specified in {@link
     * Options#DATASOURCE_NAME DATASOURCE_NAME}, these file paths must resolve
     * to accessible files at that data source location. Prefix matching is
     * supported. If the data source is hdfs, prefixes must be aligned with
     * directories, i.e.&nbsp;partial file names will not match.
     * <p>
     * If no data source is specified, the files are assumed to be local to the
     * database and must all be accessible to the gpudb user, residing on the
     * path (or relative to the path) specified by the external files directory
     * in the Kinetica <a
     * href="../../../../../../config/#config-main-external-files"
     * target="_top">configuration file</a>. Wildcards (*) can be used to
     * specify a group of files.  Prefix matching is supported, the prefixes
     * must be aligned with directories.
     * <p>
     * If the first path ends in .tsv, the text delimiter will be defaulted to
     * a tab character. If the first path ends in .psv, the text delimiter will
     * be defaulted to a pipe character (|).
     *
     * @return The current value of {@code filepaths}.
     */
    public List<String> getFilepaths() {
        return filepaths;
    }

    /**
     * A list of file paths from which data will be sourced;
     * <p>
     * For paths in <a href="../../../../../../tools/kifs/"
     * target="_top">KiFS</a>, use the URI prefix of kifs:// followed by the
     * path to a file or directory. File matching by prefix is supported,
     * e.g.&nbsp;kifs://dir/file would match dir/file_1 and dir/file_2. When
     * prefix matching is used, the path must start with a full, valid KiFS
     * directory name.
     * <p>
     * If an external data source is specified in {@link
     * Options#DATASOURCE_NAME DATASOURCE_NAME}, these file paths must resolve
     * to accessible files at that data source location. Prefix matching is
     * supported. If the data source is hdfs, prefixes must be aligned with
     * directories, i.e.&nbsp;partial file names will not match.
     * <p>
     * If no data source is specified, the files are assumed to be local to the
     * database and must all be accessible to the gpudb user, residing on the
     * path (or relative to the path) specified by the external files directory
     * in the Kinetica <a
     * href="../../../../../../config/#config-main-external-files"
     * target="_top">configuration file</a>. Wildcards (*) can be used to
     * specify a group of files.  Prefix matching is supported, the prefixes
     * must be aligned with directories.
     * <p>
     * If the first path ends in .tsv, the text delimiter will be defaulted to
     * a tab character. If the first path ends in .psv, the text delimiter will
     * be defaulted to a pipe character (|).
     *
     * @param filepaths  The new value for {@code filepaths}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public CreateTableExternalRequest setFilepaths(List<String> filepaths) {
        this.filepaths = (filepaths == null) ? new ArrayList<String>() : filepaths;
        return this;
    }

    /**
     * Not implemented yet. The default value is an empty {@link Map}.
     *
     * @return The current value of {@code modifyColumns}.
     */
    public Map<String, Map<String, String>> getModifyColumns() {
        return modifyColumns;
    }

    /**
     * Not implemented yet. The default value is an empty {@link Map}.
     *
     * @param modifyColumns  The new value for {@code modifyColumns}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public CreateTableExternalRequest setModifyColumns(Map<String, Map<String, String>> modifyColumns) {
        this.modifyColumns = (modifyColumns == null) ? new LinkedHashMap<String, Map<String, String>>() : modifyColumns;
        return this;
    }

    /**
     * Options from {@link com.gpudb.GPUdb#createTable(CreateTableRequest)
     * GPUdb.createTable}, allowing the structure of the table to be defined
     * independently of the data source.
     * <ul>
     *     <li>{@link CreateTableOptions#TYPE_ID TYPE_ID}: ID of a currently
     *         registered <a href="../../../../../../concepts/types/"
     *         target="_top">type</a>.
     *     <li>{@link CreateTableOptions#NO_ERROR_IF_EXISTS
     *         NO_ERROR_IF_EXISTS}: If {@link CreateTableOptions#TRUE TRUE},
     *         prevents an error from occurring if the table already exists and
     *         is of the given type.  If a table with the same name but a
     *         different type exists, it is still an error.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#IS_REPLICATED IS_REPLICATED}: Affects
     *         the <a href="../../../../../../concepts/tables/#distribution"
     *         target="_top">distribution scheme</a> for the table's data.  If
     *         {@link CreateTableOptions#TRUE TRUE} and the given table has no
     *         explicit <a href="../../../../../../concepts/tables/#shard-key"
     *         target="_top">shard key</a> defined, the table will be <a
     *         href="../../../../../../concepts/tables/#replication"
     *         target="_top">replicated</a>.  If {@link
     *         CreateTableOptions#FALSE FALSE}, the table will be <a
     *         href="../../../../../../concepts/tables/#sharding"
     *         target="_top">sharded</a> according to the shard key specified
     *         in the given {@link CreateTableOptions#TYPE_ID TYPE_ID}, or <a
     *         href="../../../../../../concepts/tables/#random-sharding"
     *         target="_top">randomly sharded</a>, if no shard key is
     *         specified. Note that a type containing a shard key cannot be
     *         used to create a replicated table.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#FOREIGN_KEYS FOREIGN_KEYS}:
     *         Semicolon-separated list of <a
     *         href="../../../../../../concepts/tables/#foreign-keys"
     *         target="_top">foreign keys</a>, of the format
     *         '(source_column_name [, ...]) references
     *         target_table_name(primary_key_column_name [, ...]) [as
     *         foreign_key_name]'.
     *     <li>{@link CreateTableOptions#FOREIGN_SHARD_KEY FOREIGN_SHARD_KEY}:
     *         Foreign shard key of the format 'source_column references
     *         shard_by_column from target_table(primary_key_column)'.
     *     <li>{@link CreateTableOptions#PARTITION_TYPE PARTITION_TYPE}: <a
     *         href="../../../../../../concepts/tables/#partitioning"
     *         target="_top">Partitioning</a> scheme to use.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#RANGE RANGE}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-range"
     *                 target="_top">range partitioning</a>.
     *             <li>{@link CreateTableOptions#INTERVAL INTERVAL}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-interval"
     *                 target="_top">interval partitioning</a>.
     *             <li>{@link CreateTableOptions#LIST LIST}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-list"
     *                 target="_top">list partitioning</a>.
     *             <li>{@link CreateTableOptions#HASH HASH}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-hash"
     *                 target="_top">hash partitioning</a>.
     *             <li>{@link CreateTableOptions#SERIES SERIES}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-series"
     *                 target="_top">series partitioning</a>.
     *         </ul>
     *     <li>{@link CreateTableOptions#PARTITION_KEYS PARTITION_KEYS}:
     *         Comma-separated list of partition keys, which are the columns or
     *         column expressions by which records will be assigned to
     *         partitions defined by {@link
     *         CreateTableOptions#PARTITION_DEFINITIONS PARTITION_DEFINITIONS}.
     *     <li>{@link CreateTableOptions#PARTITION_DEFINITIONS
     *         PARTITION_DEFINITIONS}: Comma-separated list of partition
     *         definitions, whose format depends on the choice of {@link
     *         CreateTableOptions#PARTITION_TYPE PARTITION_TYPE}.  See <a
     *         href="../../../../../../concepts/tables/#partitioning-by-range"
     *         target="_top">range partitioning</a>, <a
     *         href="../../../../../../concepts/tables/#partitioning-by-interval"
     *         target="_top">interval partitioning</a>, <a
     *         href="../../../../../../concepts/tables/#partitioning-by-list"
     *         target="_top">list partitioning</a>, <a
     *         href="../../../../../../concepts/tables/#partitioning-by-hash"
     *         target="_top">hash partitioning</a>, or <a
     *         href="../../../../../../concepts/tables/#partitioning-by-series"
     *         target="_top">series partitioning</a> for example formats.
     *     <li>{@link CreateTableOptions#IS_AUTOMATIC_PARTITION
     *         IS_AUTOMATIC_PARTITION}: If {@link CreateTableOptions#TRUE
     *         TRUE}, a new partition will be created for values which don't
     *         fall into an existing partition.  Currently, only supported for
     *         <a
     *         href="../../../../../../concepts/tables/#partitioning-by-list"
     *         target="_top">list partitions</a>.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#TTL TTL}: Sets the <a
     *         href="../../../../../../concepts/ttl/" target="_top">TTL</a> of
     *         the table specified in {@link #getTableName() tableName}.
     *     <li>{@link CreateTableOptions#CHUNK_SIZE CHUNK_SIZE}: Indicates the
     *         number of records per chunk to be used for this table.
     *     <li>{@link CreateTableOptions#CHUNK_COLUMN_MAX_MEMORY
     *         CHUNK_COLUMN_MAX_MEMORY}: Indicates the target maximum data size
     *         for each column in a chunk to be used for this table.
     *     <li>{@link CreateTableOptions#CHUNK_MAX_MEMORY CHUNK_MAX_MEMORY}:
     *         Indicates the target maximum data size for all columns in a
     *         chunk to be used for this table.
     *     <li>{@link CreateTableOptions#IS_RESULT_TABLE IS_RESULT_TABLE}:
     *         Indicates whether the table is a <a
     *         href="../../../../../../concepts/tables_memory_only/"
     *         target="_top">memory-only table</a>. A result table cannot
     *         contain columns with text_search <a
     *         href="../../../../../../concepts/types/#data-handling"
     *         target="_top">data-handling</a>, and it will not be retained if
     *         the server is restarted.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#STRATEGY_DEFINITION
     *         STRATEGY_DEFINITION}: The <a
     *         href="../../../../../../rm/concepts/#tier-strategies"
     *         target="_top">tier strategy</a> for the table and its columns.
     *     <li>{@link CreateTableOptions#COMPRESSION_CODEC COMPRESSION_CODEC}:
     *         The default <a
     *         href="../../../../../../concepts/column_compression/"
     *         target="_top">compression codec</a> for this table's columns.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @return The current value of {@code createTableOptions}.
     */
    public Map<String, String> getCreateTableOptions() {
        return createTableOptions;
    }

    /**
     * Options from {@link com.gpudb.GPUdb#createTable(CreateTableRequest)
     * GPUdb.createTable}, allowing the structure of the table to be defined
     * independently of the data source.
     * <ul>
     *     <li>{@link CreateTableOptions#TYPE_ID TYPE_ID}: ID of a currently
     *         registered <a href="../../../../../../concepts/types/"
     *         target="_top">type</a>.
     *     <li>{@link CreateTableOptions#NO_ERROR_IF_EXISTS
     *         NO_ERROR_IF_EXISTS}: If {@link CreateTableOptions#TRUE TRUE},
     *         prevents an error from occurring if the table already exists and
     *         is of the given type.  If a table with the same name but a
     *         different type exists, it is still an error.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#IS_REPLICATED IS_REPLICATED}: Affects
     *         the <a href="../../../../../../concepts/tables/#distribution"
     *         target="_top">distribution scheme</a> for the table's data.  If
     *         {@link CreateTableOptions#TRUE TRUE} and the given table has no
     *         explicit <a href="../../../../../../concepts/tables/#shard-key"
     *         target="_top">shard key</a> defined, the table will be <a
     *         href="../../../../../../concepts/tables/#replication"
     *         target="_top">replicated</a>.  If {@link
     *         CreateTableOptions#FALSE FALSE}, the table will be <a
     *         href="../../../../../../concepts/tables/#sharding"
     *         target="_top">sharded</a> according to the shard key specified
     *         in the given {@link CreateTableOptions#TYPE_ID TYPE_ID}, or <a
     *         href="../../../../../../concepts/tables/#random-sharding"
     *         target="_top">randomly sharded</a>, if no shard key is
     *         specified. Note that a type containing a shard key cannot be
     *         used to create a replicated table.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#FOREIGN_KEYS FOREIGN_KEYS}:
     *         Semicolon-separated list of <a
     *         href="../../../../../../concepts/tables/#foreign-keys"
     *         target="_top">foreign keys</a>, of the format
     *         '(source_column_name [, ...]) references
     *         target_table_name(primary_key_column_name [, ...]) [as
     *         foreign_key_name]'.
     *     <li>{@link CreateTableOptions#FOREIGN_SHARD_KEY FOREIGN_SHARD_KEY}:
     *         Foreign shard key of the format 'source_column references
     *         shard_by_column from target_table(primary_key_column)'.
     *     <li>{@link CreateTableOptions#PARTITION_TYPE PARTITION_TYPE}: <a
     *         href="../../../../../../concepts/tables/#partitioning"
     *         target="_top">Partitioning</a> scheme to use.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#RANGE RANGE}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-range"
     *                 target="_top">range partitioning</a>.
     *             <li>{@link CreateTableOptions#INTERVAL INTERVAL}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-interval"
     *                 target="_top">interval partitioning</a>.
     *             <li>{@link CreateTableOptions#LIST LIST}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-list"
     *                 target="_top">list partitioning</a>.
     *             <li>{@link CreateTableOptions#HASH HASH}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-hash"
     *                 target="_top">hash partitioning</a>.
     *             <li>{@link CreateTableOptions#SERIES SERIES}: Use <a
     *                 href="../../../../../../concepts/tables/#partitioning-by-series"
     *                 target="_top">series partitioning</a>.
     *         </ul>
     *     <li>{@link CreateTableOptions#PARTITION_KEYS PARTITION_KEYS}:
     *         Comma-separated list of partition keys, which are the columns or
     *         column expressions by which records will be assigned to
     *         partitions defined by {@link
     *         CreateTableOptions#PARTITION_DEFINITIONS PARTITION_DEFINITIONS}.
     *     <li>{@link CreateTableOptions#PARTITION_DEFINITIONS
     *         PARTITION_DEFINITIONS}: Comma-separated list of partition
     *         definitions, whose format depends on the choice of {@link
     *         CreateTableOptions#PARTITION_TYPE PARTITION_TYPE}.  See <a
     *         href="../../../../../../concepts/tables/#partitioning-by-range"
     *         target="_top">range partitioning</a>, <a
     *         href="../../../../../../concepts/tables/#partitioning-by-interval"
     *         target="_top">interval partitioning</a>, <a
     *         href="../../../../../../concepts/tables/#partitioning-by-list"
     *         target="_top">list partitioning</a>, <a
     *         href="../../../../../../concepts/tables/#partitioning-by-hash"
     *         target="_top">hash partitioning</a>, or <a
     *         href="../../../../../../concepts/tables/#partitioning-by-series"
     *         target="_top">series partitioning</a> for example formats.
     *     <li>{@link CreateTableOptions#IS_AUTOMATIC_PARTITION
     *         IS_AUTOMATIC_PARTITION}: If {@link CreateTableOptions#TRUE
     *         TRUE}, a new partition will be created for values which don't
     *         fall into an existing partition.  Currently, only supported for
     *         <a
     *         href="../../../../../../concepts/tables/#partitioning-by-list"
     *         target="_top">list partitions</a>.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#TTL TTL}: Sets the <a
     *         href="../../../../../../concepts/ttl/" target="_top">TTL</a> of
     *         the table specified in {@link #getTableName() tableName}.
     *     <li>{@link CreateTableOptions#CHUNK_SIZE CHUNK_SIZE}: Indicates the
     *         number of records per chunk to be used for this table.
     *     <li>{@link CreateTableOptions#CHUNK_COLUMN_MAX_MEMORY
     *         CHUNK_COLUMN_MAX_MEMORY}: Indicates the target maximum data size
     *         for each column in a chunk to be used for this table.
     *     <li>{@link CreateTableOptions#CHUNK_MAX_MEMORY CHUNK_MAX_MEMORY}:
     *         Indicates the target maximum data size for all columns in a
     *         chunk to be used for this table.
     *     <li>{@link CreateTableOptions#IS_RESULT_TABLE IS_RESULT_TABLE}:
     *         Indicates whether the table is a <a
     *         href="../../../../../../concepts/tables_memory_only/"
     *         target="_top">memory-only table</a>. A result table cannot
     *         contain columns with text_search <a
     *         href="../../../../../../concepts/types/#data-handling"
     *         target="_top">data-handling</a>, and it will not be retained if
     *         the server is restarted.
     *         Supported values:
     *         <ul>
     *             <li>{@link CreateTableOptions#TRUE TRUE}
     *             <li>{@link CreateTableOptions#FALSE FALSE}
     *         </ul>
     *         The default value is {@link CreateTableOptions#FALSE FALSE}.
     *     <li>{@link CreateTableOptions#STRATEGY_DEFINITION
     *         STRATEGY_DEFINITION}: The <a
     *         href="../../../../../../rm/concepts/#tier-strategies"
     *         target="_top">tier strategy</a> for the table and its columns.
     *     <li>{@link CreateTableOptions#COMPRESSION_CODEC COMPRESSION_CODEC}:
     *         The default <a
     *         href="../../../../../../concepts/column_compression/"
     *         target="_top">compression codec</a> for this table's columns.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @param createTableOptions  The new value for {@code createTableOptions}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public CreateTableExternalRequest setCreateTableOptions(Map<String, String> createTableOptions) {
        this.createTableOptions = (createTableOptions == null) ? new LinkedHashMap<String, String>() : createTableOptions;
        return this;
    }

    /**
     * Optional parameters.
     * <ul>
     *     <li>{@link Options#BAD_RECORD_TABLE_NAME BAD_RECORD_TABLE_NAME}:
     *         Name of a table to which records that were rejected are written.
     *         The bad-record-table has the following columns: line_number
     *         (long), line_rejected (string), error_message (string).  When
     *         {@link Options#ERROR_HANDLING ERROR_HANDLING} is {@link
     *         Options#ABORT ABORT}, bad records table is not populated.
     *     <li>{@link Options#BAD_RECORD_TABLE_LIMIT BAD_RECORD_TABLE_LIMIT}: A
     *         positive integer indicating the maximum number of records that
     *         can be written to the bad-record-table. The default value is
     *         '10000'.
     *     <li>{@link Options#BAD_RECORD_TABLE_LIMIT_PER_INPUT
     *         BAD_RECORD_TABLE_LIMIT_PER_INPUT}: For subscriptions, a positive
     *         integer indicating the maximum number of records that can be
     *         written to the bad-record-table per file/payload. Default value
     *         will be {@link Options#BAD_RECORD_TABLE_LIMIT
     *         BAD_RECORD_TABLE_LIMIT} and total size of the table per rank is
     *         limited to {@link Options#BAD_RECORD_TABLE_LIMIT
     *         BAD_RECORD_TABLE_LIMIT}.
     *     <li>{@link Options#BATCH_SIZE BATCH_SIZE}: Number of records to
     *         insert per batch when inserting data. The default value is
     *         '50000'.
     *     <li>{@link Options#COLUMN_FORMATS COLUMN_FORMATS}: For each target
     *         column specified, applies the column-property-bound format to
     *         the source data loaded into that column.  Each column format
     *         will contain a mapping of one or more of its column properties
     *         to an appropriate format for each property.  Currently supported
     *         column properties include date, time, & datetime. The parameter
     *         value must be formatted as a JSON string of maps of column names
     *         to maps of column properties to their corresponding column
     *         formats, e.g., '{ "order_date" : { "date" : "%Y.%m.%d" },
     *         "order_time" : { "time" : "%H:%M:%S" } }'.  See {@link
     *         Options#DEFAULT_COLUMN_FORMATS DEFAULT_COLUMN_FORMATS} for valid
     *         format syntax.
     *     <li>{@link Options#COLUMNS_TO_LOAD COLUMNS_TO_LOAD}: Specifies a
     *         comma-delimited list of columns from the source data to load.
     *         If more than one file is being loaded, this list applies to all
     *         files.  Column numbers can be specified discretely or as a
     *         range.  For example, a value of '5,7,1..3' will insert values
     *         from the fifth column in the source data into the first column
     *         in the target table, from the seventh column in the source data
     *         into the second column in the target table, and from the first
     *         through third columns in the source data into the third through
     *         fifth columns in the target table.  If the source data contains
     *         a header, column names matching the file header names may be
     *         provided instead of column numbers.  If the target table doesn't
     *         exist, the table will be created with the columns in this order.
     *         If the target table does exist with columns in a different order
     *         than the source data, this list can be used to match the order
     *         of the target table.  For example, a value of 'C, B, A' will
     *         create a three column table with column C, followed by column B,
     *         followed by column A; or will insert those fields in that order
     *         into a table created with columns in that order.  If the target
     *         table exists, the column names must match the source data field
     *         names for a name-mapping to be successful.  Mutually exclusive
     *         with {@link Options#COLUMNS_TO_SKIP COLUMNS_TO_SKIP}.
     *     <li>{@link Options#COLUMNS_TO_SKIP COLUMNS_TO_SKIP}: Specifies a
     *         comma-delimited list of columns from the source data to skip.
     *         Mutually exclusive with {@link Options#COLUMNS_TO_LOAD
     *         COLUMNS_TO_LOAD}.
     *     <li>{@link Options#COMPRESSION_TYPE COMPRESSION_TYPE}: Source data
     *         compression type.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#NONE NONE}: No compression.
     *             <li>{@link Options#AUTO AUTO}: Auto detect compression type
     *             <li>{@link Options#GZIP GZIP}: gzip file compression.
     *             <li>{@link Options#BZIP2 BZIP2}: bzip2 file compression.
     *         </ul>
     *         The default value is {@link Options#AUTO AUTO}.
     *     <li>{@link Options#DATASOURCE_NAME DATASOURCE_NAME}: Name of an
     *         existing external data source from which data file(s) specified
     *         in {@link #getFilepaths() filepaths} will be loaded
     *     <li>{@link Options#DEFAULT_COLUMN_FORMATS DEFAULT_COLUMN_FORMATS}:
     *         Specifies the default format to be applied to source data loaded
     *         into columns with the corresponding column property.  Currently
     *         supported column properties include date, time, & datetime.
     *         This default column-property-bound format can be overridden by
     *         specifying a column property & format for a given target column
     *         in {@link Options#COLUMN_FORMATS COLUMN_FORMATS}. For each
     *         specified annotation, the format will apply to all columns with
     *         that annotation unless a custom {@link Options#COLUMN_FORMATS
     *         COLUMN_FORMATS} for that annotation is specified.  The parameter
     *         value must be formatted as a JSON string that is a map of column
     *         properties to their respective column formats, e.g., '{ "date" :
     *         "%Y.%m.%d", "time" : "%H:%M:%S" }'.  Column formats are
     *         specified as a string of control characters and plain text. The
     *         supported control characters are 'Y', 'm', 'd', 'H', 'M', 'S',
     *         and 's', which follow the Linux 'strptime()' specification, as
     *         well as 's', which specifies seconds and fractional seconds
     *         (though the fractional component will be truncated past
     *         milliseconds).  Formats for the 'date' annotation must include
     *         the 'Y', 'm', and 'd' control characters. Formats for the 'time'
     *         annotation must include the 'H', 'M', and either 'S' or 's' (but
     *         not both) control characters. Formats for the 'datetime'
     *         annotation meet both the 'date' and 'time' control character
     *         requirements. For example, '{"datetime" : "%m/%d/%Y %H:%M:%S" }'
     *         would be used to interpret text as "05/04/2000 12:12:11"
     *     <li>{@link Options#ERROR_HANDLING ERROR_HANDLING}: Specifies how
     *         errors should be handled upon insertion.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#PERMISSIVE PERMISSIVE}: Records with
     *                 missing columns are populated with nulls if possible;
     *                 otherwise, the malformed records are skipped.
     *             <li>{@link Options#IGNORE_BAD_RECORDS IGNORE_BAD_RECORDS}:
     *                 Malformed records are skipped.
     *             <li>{@link Options#ABORT ABORT}: Stops current insertion and
     *                 aborts entire operation when an error is encountered.
     *                 Primary key collisions are considered abortable errors
     *                 in this mode.
     *         </ul>
     *         The default value is {@link Options#ABORT ABORT}.
     *     <li>{@link Options#EXTERNAL_TABLE_TYPE EXTERNAL_TABLE_TYPE}:
     *         Specifies whether the external table holds a local copy of the
     *         external data.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#MATERIALIZED MATERIALIZED}: Loads a copy
     *                 of the external data into the database, refreshed on
     *                 demand
     *             <li>{@link Options#LOGICAL LOGICAL}: External data will not
     *                 be loaded into the database; the data will be retrieved
     *                 from the source upon servicing each query against the
     *                 external table
     *         </ul>
     *         The default value is {@link Options#MATERIALIZED MATERIALIZED}.
     *     <li>{@link Options#FILE_TYPE FILE_TYPE}: Specifies the type of the
     *         file(s) whose records will be inserted.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#AVRO AVRO}: Avro file format
     *             <li>{@link Options#DELIMITED_TEXT DELIMITED_TEXT}: Delimited
     *                 text file format; e.g., CSV, TSV, PSV, etc.
     *             <li>{@link Options#GDB GDB}: Esri/GDB file format
     *             <li>{@link Options#JSON JSON}: Json file format
     *             <li>{@link Options#PARQUET PARQUET}: Apache Parquet file
     *                 format
     *             <li>{@link Options#SHAPEFILE SHAPEFILE}: ShapeFile file
     *                 format
     *         </ul>
     *         The default value is {@link Options#DELIMITED_TEXT
     *         DELIMITED_TEXT}.
     *     <li>{@link Options#FLATTEN_COLUMNS FLATTEN_COLUMNS}: Specifies how
     *         to handle nested columns.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Break up nested columns to
     *                 multiple columns
     *             <li>{@link Options#FALSE FALSE}: Treat nested columns as
     *                 json columns instead of flattening
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#GDAL_CONFIGURATION_OPTIONS
     *         GDAL_CONFIGURATION_OPTIONS}: Comma separated list of gdal conf
     *         options, for the specific requests: key=value
     *     <li>{@link Options#IGNORE_EXISTING_PK IGNORE_EXISTING_PK}: Specifies
     *         the record collision error-suppression policy for inserting into
     *         a table with a <a
     *         href="../../../../../../concepts/tables/#primary-keys"
     *         target="_top">primary key</a>, only used when not in upsert mode
     *         (upsert mode is disabled when {@link
     *         Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK} is {@link
     *         Options#FALSE FALSE}).  If set to {@link Options#TRUE TRUE}, any
     *         record being inserted that is rejected for having primary key
     *         values that match those of an existing table record will be
     *         ignored with no error generated.  If {@link Options#FALSE
     *         FALSE}, the rejection of any record for having primary key
     *         values matching an existing record will result in an error being
     *         reported, as determined by {@link Options#ERROR_HANDLING
     *         ERROR_HANDLING}.  If the specified table does not have a primary
     *         key or if upsert mode is in effect ({@link
     *         Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK} is {@link
     *         Options#TRUE TRUE}), then this option has no effect.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Ignore new records whose
     *                 primary key values collide with those of existing
     *                 records
     *             <li>{@link Options#FALSE FALSE}: Treat as errors any new
     *                 records whose primary key values collide with those of
     *                 existing records
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#INGESTION_MODE INGESTION_MODE}: Whether to do a
     *         full load, dry run, or perform a type inference on the source
     *         data.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#FULL FULL}: Run a type inference on the
     *                 source data (if needed) and ingest
     *             <li>{@link Options#DRY_RUN DRY_RUN}: Does not load data, but
     *                 walks through the source data and determines the number
     *                 of valid records, taking into account the current mode
     *                 of {@link Options#ERROR_HANDLING ERROR_HANDLING}.
     *             <li>{@link Options#TYPE_INFERENCE_ONLY TYPE_INFERENCE_ONLY}:
     *                 Infer the type of the source data and return, without
     *                 ingesting any data.  The inferred type is returned in
     *                 the response.
     *         </ul>
     *         The default value is {@link Options#FULL FULL}.
     *     <li>{@link Options#JDBC_FETCH_SIZE JDBC_FETCH_SIZE}: The JDBC fetch
     *         size, which determines how many rows to fetch per round trip.
     *         The default value is '50000'.
     *     <li>{@link Options#KAFKA_CONSUMERS_PER_RANK
     *         KAFKA_CONSUMERS_PER_RANK}: Number of Kafka consumer threads per
     *         rank (valid range 1-6). The default value is '1'.
     *     <li>{@link Options#KAFKA_GROUP_ID KAFKA_GROUP_ID}: The group id to
     *         be used when consuming data from a Kafka topic (valid only for
     *         Kafka datasource subscriptions).
     *     <li>{@link Options#KAFKA_OFFSET_RESET_POLICY
     *         KAFKA_OFFSET_RESET_POLICY}: Policy to determine whether the
     *         Kafka data consumption starts either at earliest offset or
     *         latest offset.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#EARLIEST EARLIEST}
     *             <li>{@link Options#LATEST LATEST}
     *         </ul>
     *         The default value is {@link Options#EARLIEST EARLIEST}.
     *     <li>{@link Options#KAFKA_OPTIMISTIC_INGEST KAFKA_OPTIMISTIC_INGEST}:
     *         Enable optimistic ingestion where Kafka topic offsets and table
     *         data are committed independently to achieve parallelism.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#KAFKA_SUBSCRIPTION_CANCEL_AFTER
     *         KAFKA_SUBSCRIPTION_CANCEL_AFTER}: Sets the Kafka subscription
     *         lifespan (in minutes). Expired subscription will be cancelled
     *         automatically.
     *     <li>{@link Options#KAFKA_TYPE_INFERENCE_FETCH_TIMEOUT
     *         KAFKA_TYPE_INFERENCE_FETCH_TIMEOUT}: Maximum time to collect
     *         Kafka messages before type inferencing on the set of them.
     *     <li>{@link Options#LAYER LAYER}: Geo files layer(s) name(s): comma
     *         separated.
     *     <li>{@link Options#LOADING_MODE LOADING_MODE}: Scheme for
     *         distributing the extraction and loading of data from the source
     *         data file(s). This option applies only when loading files that
     *         are local to the database.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#HEAD HEAD}: The head node loads all data.
     *                 All files must be available to the head node.
     *             <li>{@link Options#DISTRIBUTED_SHARED DISTRIBUTED_SHARED}:
     *                 The head node coordinates loading data by worker
     *                 processes across all nodes from shared files available
     *                 to all workers.  NOTE:  Instead of existing on a shared
     *                 source, the files can be duplicated on a source local to
     *                 each host to improve performance, though the files must
     *                 appear as the same data set from the perspective of all
     *                 hosts performing the load.
     *             <li>{@link Options#DISTRIBUTED_LOCAL DISTRIBUTED_LOCAL}: A
     *                 single worker process on each node loads all files that
     *                 are available to it. This option works best when each
     *                 worker loads files from its own file system, to maximize
     *                 performance. In order to avoid data duplication, either
     *                 each worker performing the load needs to have visibility
     *                 to a set of files unique to it (no file is visible to
     *                 more than one node) or the target table needs to have a
     *                 primary key (which will allow the worker to
     *                 automatically deduplicate data).  NOTE:  If the target
     *                 table doesn't exist, the table structure will be
     *                 determined by the head node. If the head node has no
     *                 files local to it, it will be unable to determine the
     *                 structure and the request will fail.  If the head node
     *                 is configured to have no worker processes, no data
     *                 strictly accessible to the head node will be loaded.
     *         </ul>
     *         The default value is {@link Options#HEAD HEAD}.
     *     <li>{@link Options#LOCAL_TIME_OFFSET LOCAL_TIME_OFFSET}: Apply an
     *         offset to Avro local timestamp columns.
     *     <li>{@link Options#MAX_RECORDS_TO_LOAD MAX_RECORDS_TO_LOAD}: Limit
     *         the number of records to load in this request: if this number is
     *         larger than {@link Options#BATCH_SIZE BATCH_SIZE}, then the
     *         number of records loaded will be limited to the next whole
     *         number of {@link Options#BATCH_SIZE BATCH_SIZE} (per working
     *         thread).
     *     <li>{@link Options#NUM_TASKS_PER_RANK NUM_TASKS_PER_RANK}: Number of
     *         tasks for reading file per rank. Default will be system
     *         configuration parameter, external_file_reader_num_tasks.
     *     <li>{@link Options#POLL_INTERVAL POLL_INTERVAL}: If {@link
     *         Options#TRUE TRUE}, the number of seconds between attempts to
     *         load external files into the table.  If zero, polling will be
     *         continuous as long as data is found.  If no data is found, the
     *         interval will steadily increase to a maximum of 60 seconds. The
     *         default value is '0'.
     *     <li>{@link Options#PRIMARY_KEYS PRIMARY_KEYS}: Comma separated list
     *         of column names to set as primary keys, when not specified in
     *         the type.
     *     <li>{@link Options#REFRESH_METHOD REFRESH_METHOD}: Method by which
     *         the table can be refreshed from its source data.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#MANUAL MANUAL}: Refresh only occurs when
     *                 manually requested by invoking the refresh action of
     *                 {@link com.gpudb.GPUdb#alterTable(AlterTableRequest)
     *                 GPUdb.alterTable} on this table.
     *             <li>{@link Options#ON_START ON_START}: Refresh table on
     *                 database startup and when manually requested by invoking
     *                 the refresh action of {@link
     *                 com.gpudb.GPUdb#alterTable(AlterTableRequest)
     *                 GPUdb.alterTable} on this table.
     *         </ul>
     *         The default value is {@link Options#MANUAL MANUAL}.
     *     <li>{@link Options#SCHEMA_REGISTRY_CONNECTION_RETRIES
     *         SCHEMA_REGISTRY_CONNECTION_RETRIES}: Confluent Schema registry
     *         connection timeout (in Secs)
     *     <li>{@link Options#SCHEMA_REGISTRY_CONNECTION_TIMEOUT
     *         SCHEMA_REGISTRY_CONNECTION_TIMEOUT}: Confluent Schema registry
     *         connection timeout (in Secs)
     *     <li>{@link
     *         Options#SCHEMA_REGISTRY_MAX_CONSECUTIVE_CONNECTION_FAILURES
     *         SCHEMA_REGISTRY_MAX_CONSECUTIVE_CONNECTION_FAILURES}: Max
     *         records to skip due to SR connection failures, before failing
     *     <li>{@link Options#MAX_CONSECUTIVE_INVALID_SCHEMA_FAILURE
     *         MAX_CONSECUTIVE_INVALID_SCHEMA_FAILURE}: Max records to skip due
     *         to schema related errors, before failing
     *     <li>{@link Options#SCHEMA_REGISTRY_SCHEMA_NAME
     *         SCHEMA_REGISTRY_SCHEMA_NAME}: Name of the Avro schema in the
     *         schema registry to use when reading Avro records.
     *     <li>{@link Options#SHARD_KEYS SHARD_KEYS}: Comma separated list of
     *         column names to set as shard keys, when not specified in the
     *         type.
     *     <li>{@link Options#SKIP_LINES SKIP_LINES}: Skip a number of lines
     *         from the beginning of the file.
     *     <li>{@link Options#START_OFFSETS START_OFFSETS}: Starting offsets by
     *         partition to fetch from kafka. A comma separated list of
     *         partition:offset pairs.
     *     <li>{@link Options#SUBSCRIBE SUBSCRIBE}: Continuously poll the data
     *         source to check for new data and load it into the table.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TABLE_INSERT_MODE TABLE_INSERT_MODE}: Insertion
     *         scheme to use when inserting records from multiple shapefiles.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#SINGLE SINGLE}: Insert all records into a
     *                 single table.
     *             <li>{@link Options#TABLE_PER_FILE TABLE_PER_FILE}: Insert
     *                 records from each file into a new table corresponding to
     *                 that file.
     *         </ul>
     *         The default value is {@link Options#SINGLE SINGLE}.
     *     <li>{@link Options#TEXT_COMMENT_STRING TEXT_COMMENT_STRING}:
     *         Specifies the character string that should be interpreted as a
     *         comment line prefix in the source data.  All lines in the data
     *         starting with the provided string are ignored.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is '#'.
     *     <li>{@link Options#TEXT_DELIMITER TEXT_DELIMITER}: Specifies the
     *         character delimiting field values in the source data and field
     *         names in the header (if present).  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is ','.
     *     <li>{@link Options#TEXT_ESCAPE_CHARACTER TEXT_ESCAPE_CHARACTER}:
     *         Specifies the character that is used to escape other characters
     *         in the source data.  An 'a', 'b', 'f', 'n', 'r', 't', or 'v'
     *         preceded by an escape character will be interpreted as the ASCII
     *         bell, backspace, form feed, line feed, carriage return,
     *         horizontal tab, & vertical tab, respectively.  For example, the
     *         escape character followed by an 'n' will be interpreted as a
     *         newline within a field value.  The escape character can also be
     *         used to escape the quoting character, and will be treated as an
     *         escape character whether it is within a quoted field value or
     *         not.  For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
     *         Options#FILE_TYPE FILE_TYPE} only.
     *     <li>{@link Options#TEXT_HAS_HEADER TEXT_HAS_HEADER}: Indicates
     *         whether the source data contains a header row.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#TEXT_HEADER_PROPERTY_DELIMITER
     *         TEXT_HEADER_PROPERTY_DELIMITER}: Specifies the delimiter for <a
     *         href="../../../../../../concepts/types/#column-properties"
     *         target="_top">column properties</a> in the header row (if
     *         present).  Cannot be set to same value as {@link
     *         Options#TEXT_DELIMITER TEXT_DELIMITER}.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is '|'.
     *     <li>{@link Options#TEXT_NULL_STRING TEXT_NULL_STRING}: Specifies the
     *         character string that should be interpreted as a null value in
     *         the source data.  For {@link Options#DELIMITED_TEXT
     *         DELIMITED_TEXT} {@link Options#FILE_TYPE FILE_TYPE} only. The
     *         default value is '\N'.
     *     <li>{@link Options#TEXT_QUOTE_CHARACTER TEXT_QUOTE_CHARACTER}:
     *         Specifies the character that should be interpreted as a field
     *         value quoting character in the source data.  The character must
     *         appear at beginning and end of field value to take effect.
     *         Delimiters within quoted fields are treated as literals and not
     *         delimiters.  Within a quoted field, two consecutive quote
     *         characters will be interpreted as a single literal quote
     *         character, effectively escaping it.  To not have a quote
     *         character, specify an empty string.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is '"'.
     *     <li>{@link Options#TEXT_SEARCH_COLUMNS TEXT_SEARCH_COLUMNS}: Add
     *         'text_search' property to internally inferenced string columns.
     *         Comma separated list of column names or '*' for all columns. To
     *         add 'text_search' property only to string columns greater than
     *         or equal to a minimum size, also set the {@link
     *         Options#TEXT_SEARCH_MIN_COLUMN_LENGTH
     *         TEXT_SEARCH_MIN_COLUMN_LENGTH}
     *     <li>{@link Options#TEXT_SEARCH_MIN_COLUMN_LENGTH
     *         TEXT_SEARCH_MIN_COLUMN_LENGTH}: Set the minimum column size for
     *         strings to apply the 'text_search' property to. Used only when
     *         {@link Options#TEXT_SEARCH_COLUMNS TEXT_SEARCH_COLUMNS} has a
     *         value.
     *     <li>{@link Options#TRUNCATE_STRINGS TRUNCATE_STRINGS}: If set to
     *         {@link Options#TRUE TRUE}, truncate string values that are
     *         longer than the column's type size.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TRUNCATE_TABLE TRUNCATE_TABLE}: If set to {@link
     *         Options#TRUE TRUE}, truncates the table specified by {@link
     *         #getTableName() tableName} prior to loading the file(s).
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TYPE_INFERENCE_MAX_RECORDS_READ
     *         TYPE_INFERENCE_MAX_RECORDS_READ}
     *     <li>{@link Options#TYPE_INFERENCE_MODE TYPE_INFERENCE_MODE}:
     *         Optimize type inferencing for either speed or accuracy.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#ACCURACY ACCURACY}: Scans data to get
     *                 exactly-typed & sized columns for all data scanned.
     *             <li>{@link Options#SPEED SPEED}: Scans data and picks the
     *                 widest possible column types so that 'all' values will
     *                 fit with minimum data scanned
     *         </ul>
     *         The default value is {@link Options#SPEED SPEED}.
     *     <li>{@link Options#REMOTE_QUERY REMOTE_QUERY}: Remote SQL query from
     *         which data will be sourced
     *     <li>{@link Options#REMOTE_QUERY_FILTER_COLUMN
     *         REMOTE_QUERY_FILTER_COLUMN}: Name of column to be used for
     *         splitting {@link Options#REMOTE_QUERY REMOTE_QUERY} into
     *         multiple sub-queries using the data distribution of given column
     *     <li>{@link Options#REMOTE_QUERY_INCREASING_COLUMN
     *         REMOTE_QUERY_INCREASING_COLUMN}: Column on subscribed remote
     *         query result that will increase for new records (e.g.,
     *         TIMESTAMP).
     *     <li>{@link Options#REMOTE_QUERY_PARTITION_COLUMN
     *         REMOTE_QUERY_PARTITION_COLUMN}: Alias name for {@link
     *         Options#REMOTE_QUERY_FILTER_COLUMN REMOTE_QUERY_FILTER_COLUMN}.
     *     <li>{@link Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK}:
     *         Specifies the record collision policy for inserting into a table
     *         with a <a href="../../../../../../concepts/tables/#primary-keys"
     *         target="_top">primary key</a>. If set to {@link Options#TRUE
     *         TRUE}, any existing table record with primary key values that
     *         match those of a record being inserted will be replaced by that
     *         new record (the new data will be 'upserted'). If set to {@link
     *         Options#FALSE FALSE}, any existing table record with primary key
     *         values that match those of a record being inserted will remain
     *         unchanged, while the new record will be rejected and the error
     *         handled as determined by {@link Options#IGNORE_EXISTING_PK
     *         IGNORE_EXISTING_PK} & {@link Options#ERROR_HANDLING
     *         ERROR_HANDLING}.  If the specified table does not have a primary
     *         key, then this option has no effect.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Upsert new records when
     *                 primary keys match existing records
     *             <li>{@link Options#FALSE FALSE}: Reject new records when
     *                 primary keys match existing records
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @return The current value of {@code options}.
     */
    public Map<String, String> getOptions() {
        return options;
    }

    /**
     * Optional parameters.
     * <ul>
     *     <li>{@link Options#BAD_RECORD_TABLE_NAME BAD_RECORD_TABLE_NAME}:
     *         Name of a table to which records that were rejected are written.
     *         The bad-record-table has the following columns: line_number
     *         (long), line_rejected (string), error_message (string).  When
     *         {@link Options#ERROR_HANDLING ERROR_HANDLING} is {@link
     *         Options#ABORT ABORT}, bad records table is not populated.
     *     <li>{@link Options#BAD_RECORD_TABLE_LIMIT BAD_RECORD_TABLE_LIMIT}: A
     *         positive integer indicating the maximum number of records that
     *         can be written to the bad-record-table. The default value is
     *         '10000'.
     *     <li>{@link Options#BAD_RECORD_TABLE_LIMIT_PER_INPUT
     *         BAD_RECORD_TABLE_LIMIT_PER_INPUT}: For subscriptions, a positive
     *         integer indicating the maximum number of records that can be
     *         written to the bad-record-table per file/payload. Default value
     *         will be {@link Options#BAD_RECORD_TABLE_LIMIT
     *         BAD_RECORD_TABLE_LIMIT} and total size of the table per rank is
     *         limited to {@link Options#BAD_RECORD_TABLE_LIMIT
     *         BAD_RECORD_TABLE_LIMIT}.
     *     <li>{@link Options#BATCH_SIZE BATCH_SIZE}: Number of records to
     *         insert per batch when inserting data. The default value is
     *         '50000'.
     *     <li>{@link Options#COLUMN_FORMATS COLUMN_FORMATS}: For each target
     *         column specified, applies the column-property-bound format to
     *         the source data loaded into that column.  Each column format
     *         will contain a mapping of one or more of its column properties
     *         to an appropriate format for each property.  Currently supported
     *         column properties include date, time, & datetime. The parameter
     *         value must be formatted as a JSON string of maps of column names
     *         to maps of column properties to their corresponding column
     *         formats, e.g., '{ "order_date" : { "date" : "%Y.%m.%d" },
     *         "order_time" : { "time" : "%H:%M:%S" } }'.  See {@link
     *         Options#DEFAULT_COLUMN_FORMATS DEFAULT_COLUMN_FORMATS} for valid
     *         format syntax.
     *     <li>{@link Options#COLUMNS_TO_LOAD COLUMNS_TO_LOAD}: Specifies a
     *         comma-delimited list of columns from the source data to load.
     *         If more than one file is being loaded, this list applies to all
     *         files.  Column numbers can be specified discretely or as a
     *         range.  For example, a value of '5,7,1..3' will insert values
     *         from the fifth column in the source data into the first column
     *         in the target table, from the seventh column in the source data
     *         into the second column in the target table, and from the first
     *         through third columns in the source data into the third through
     *         fifth columns in the target table.  If the source data contains
     *         a header, column names matching the file header names may be
     *         provided instead of column numbers.  If the target table doesn't
     *         exist, the table will be created with the columns in this order.
     *         If the target table does exist with columns in a different order
     *         than the source data, this list can be used to match the order
     *         of the target table.  For example, a value of 'C, B, A' will
     *         create a three column table with column C, followed by column B,
     *         followed by column A; or will insert those fields in that order
     *         into a table created with columns in that order.  If the target
     *         table exists, the column names must match the source data field
     *         names for a name-mapping to be successful.  Mutually exclusive
     *         with {@link Options#COLUMNS_TO_SKIP COLUMNS_TO_SKIP}.
     *     <li>{@link Options#COLUMNS_TO_SKIP COLUMNS_TO_SKIP}: Specifies a
     *         comma-delimited list of columns from the source data to skip.
     *         Mutually exclusive with {@link Options#COLUMNS_TO_LOAD
     *         COLUMNS_TO_LOAD}.
     *     <li>{@link Options#COMPRESSION_TYPE COMPRESSION_TYPE}: Source data
     *         compression type.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#NONE NONE}: No compression.
     *             <li>{@link Options#AUTO AUTO}: Auto detect compression type
     *             <li>{@link Options#GZIP GZIP}: gzip file compression.
     *             <li>{@link Options#BZIP2 BZIP2}: bzip2 file compression.
     *         </ul>
     *         The default value is {@link Options#AUTO AUTO}.
     *     <li>{@link Options#DATASOURCE_NAME DATASOURCE_NAME}: Name of an
     *         existing external data source from which data file(s) specified
     *         in {@link #getFilepaths() filepaths} will be loaded
     *     <li>{@link Options#DEFAULT_COLUMN_FORMATS DEFAULT_COLUMN_FORMATS}:
     *         Specifies the default format to be applied to source data loaded
     *         into columns with the corresponding column property.  Currently
     *         supported column properties include date, time, & datetime.
     *         This default column-property-bound format can be overridden by
     *         specifying a column property & format for a given target column
     *         in {@link Options#COLUMN_FORMATS COLUMN_FORMATS}. For each
     *         specified annotation, the format will apply to all columns with
     *         that annotation unless a custom {@link Options#COLUMN_FORMATS
     *         COLUMN_FORMATS} for that annotation is specified.  The parameter
     *         value must be formatted as a JSON string that is a map of column
     *         properties to their respective column formats, e.g., '{ "date" :
     *         "%Y.%m.%d", "time" : "%H:%M:%S" }'.  Column formats are
     *         specified as a string of control characters and plain text. The
     *         supported control characters are 'Y', 'm', 'd', 'H', 'M', 'S',
     *         and 's', which follow the Linux 'strptime()' specification, as
     *         well as 's', which specifies seconds and fractional seconds
     *         (though the fractional component will be truncated past
     *         milliseconds).  Formats for the 'date' annotation must include
     *         the 'Y', 'm', and 'd' control characters. Formats for the 'time'
     *         annotation must include the 'H', 'M', and either 'S' or 's' (but
     *         not both) control characters. Formats for the 'datetime'
     *         annotation meet both the 'date' and 'time' control character
     *         requirements. For example, '{"datetime" : "%m/%d/%Y %H:%M:%S" }'
     *         would be used to interpret text as "05/04/2000 12:12:11"
     *     <li>{@link Options#ERROR_HANDLING ERROR_HANDLING}: Specifies how
     *         errors should be handled upon insertion.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#PERMISSIVE PERMISSIVE}: Records with
     *                 missing columns are populated with nulls if possible;
     *                 otherwise, the malformed records are skipped.
     *             <li>{@link Options#IGNORE_BAD_RECORDS IGNORE_BAD_RECORDS}:
     *                 Malformed records are skipped.
     *             <li>{@link Options#ABORT ABORT}: Stops current insertion and
     *                 aborts entire operation when an error is encountered.
     *                 Primary key collisions are considered abortable errors
     *                 in this mode.
     *         </ul>
     *         The default value is {@link Options#ABORT ABORT}.
     *     <li>{@link Options#EXTERNAL_TABLE_TYPE EXTERNAL_TABLE_TYPE}:
     *         Specifies whether the external table holds a local copy of the
     *         external data.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#MATERIALIZED MATERIALIZED}: Loads a copy
     *                 of the external data into the database, refreshed on
     *                 demand
     *             <li>{@link Options#LOGICAL LOGICAL}: External data will not
     *                 be loaded into the database; the data will be retrieved
     *                 from the source upon servicing each query against the
     *                 external table
     *         </ul>
     *         The default value is {@link Options#MATERIALIZED MATERIALIZED}.
     *     <li>{@link Options#FILE_TYPE FILE_TYPE}: Specifies the type of the
     *         file(s) whose records will be inserted.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#AVRO AVRO}: Avro file format
     *             <li>{@link Options#DELIMITED_TEXT DELIMITED_TEXT}: Delimited
     *                 text file format; e.g., CSV, TSV, PSV, etc.
     *             <li>{@link Options#GDB GDB}: Esri/GDB file format
     *             <li>{@link Options#JSON JSON}: Json file format
     *             <li>{@link Options#PARQUET PARQUET}: Apache Parquet file
     *                 format
     *             <li>{@link Options#SHAPEFILE SHAPEFILE}: ShapeFile file
     *                 format
     *         </ul>
     *         The default value is {@link Options#DELIMITED_TEXT
     *         DELIMITED_TEXT}.
     *     <li>{@link Options#FLATTEN_COLUMNS FLATTEN_COLUMNS}: Specifies how
     *         to handle nested columns.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Break up nested columns to
     *                 multiple columns
     *             <li>{@link Options#FALSE FALSE}: Treat nested columns as
     *                 json columns instead of flattening
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#GDAL_CONFIGURATION_OPTIONS
     *         GDAL_CONFIGURATION_OPTIONS}: Comma separated list of gdal conf
     *         options, for the specific requests: key=value
     *     <li>{@link Options#IGNORE_EXISTING_PK IGNORE_EXISTING_PK}: Specifies
     *         the record collision error-suppression policy for inserting into
     *         a table with a <a
     *         href="../../../../../../concepts/tables/#primary-keys"
     *         target="_top">primary key</a>, only used when not in upsert mode
     *         (upsert mode is disabled when {@link
     *         Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK} is {@link
     *         Options#FALSE FALSE}).  If set to {@link Options#TRUE TRUE}, any
     *         record being inserted that is rejected for having primary key
     *         values that match those of an existing table record will be
     *         ignored with no error generated.  If {@link Options#FALSE
     *         FALSE}, the rejection of any record for having primary key
     *         values matching an existing record will result in an error being
     *         reported, as determined by {@link Options#ERROR_HANDLING
     *         ERROR_HANDLING}.  If the specified table does not have a primary
     *         key or if upsert mode is in effect ({@link
     *         Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK} is {@link
     *         Options#TRUE TRUE}), then this option has no effect.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Ignore new records whose
     *                 primary key values collide with those of existing
     *                 records
     *             <li>{@link Options#FALSE FALSE}: Treat as errors any new
     *                 records whose primary key values collide with those of
     *                 existing records
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#INGESTION_MODE INGESTION_MODE}: Whether to do a
     *         full load, dry run, or perform a type inference on the source
     *         data.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#FULL FULL}: Run a type inference on the
     *                 source data (if needed) and ingest
     *             <li>{@link Options#DRY_RUN DRY_RUN}: Does not load data, but
     *                 walks through the source data and determines the number
     *                 of valid records, taking into account the current mode
     *                 of {@link Options#ERROR_HANDLING ERROR_HANDLING}.
     *             <li>{@link Options#TYPE_INFERENCE_ONLY TYPE_INFERENCE_ONLY}:
     *                 Infer the type of the source data and return, without
     *                 ingesting any data.  The inferred type is returned in
     *                 the response.
     *         </ul>
     *         The default value is {@link Options#FULL FULL}.
     *     <li>{@link Options#JDBC_FETCH_SIZE JDBC_FETCH_SIZE}: The JDBC fetch
     *         size, which determines how many rows to fetch per round trip.
     *         The default value is '50000'.
     *     <li>{@link Options#KAFKA_CONSUMERS_PER_RANK
     *         KAFKA_CONSUMERS_PER_RANK}: Number of Kafka consumer threads per
     *         rank (valid range 1-6). The default value is '1'.
     *     <li>{@link Options#KAFKA_GROUP_ID KAFKA_GROUP_ID}: The group id to
     *         be used when consuming data from a Kafka topic (valid only for
     *         Kafka datasource subscriptions).
     *     <li>{@link Options#KAFKA_OFFSET_RESET_POLICY
     *         KAFKA_OFFSET_RESET_POLICY}: Policy to determine whether the
     *         Kafka data consumption starts either at earliest offset or
     *         latest offset.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#EARLIEST EARLIEST}
     *             <li>{@link Options#LATEST LATEST}
     *         </ul>
     *         The default value is {@link Options#EARLIEST EARLIEST}.
     *     <li>{@link Options#KAFKA_OPTIMISTIC_INGEST KAFKA_OPTIMISTIC_INGEST}:
     *         Enable optimistic ingestion where Kafka topic offsets and table
     *         data are committed independently to achieve parallelism.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#KAFKA_SUBSCRIPTION_CANCEL_AFTER
     *         KAFKA_SUBSCRIPTION_CANCEL_AFTER}: Sets the Kafka subscription
     *         lifespan (in minutes). Expired subscription will be cancelled
     *         automatically.
     *     <li>{@link Options#KAFKA_TYPE_INFERENCE_FETCH_TIMEOUT
     *         KAFKA_TYPE_INFERENCE_FETCH_TIMEOUT}: Maximum time to collect
     *         Kafka messages before type inferencing on the set of them.
     *     <li>{@link Options#LAYER LAYER}: Geo files layer(s) name(s): comma
     *         separated.
     *     <li>{@link Options#LOADING_MODE LOADING_MODE}: Scheme for
     *         distributing the extraction and loading of data from the source
     *         data file(s). This option applies only when loading files that
     *         are local to the database.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#HEAD HEAD}: The head node loads all data.
     *                 All files must be available to the head node.
     *             <li>{@link Options#DISTRIBUTED_SHARED DISTRIBUTED_SHARED}:
     *                 The head node coordinates loading data by worker
     *                 processes across all nodes from shared files available
     *                 to all workers.  NOTE:  Instead of existing on a shared
     *                 source, the files can be duplicated on a source local to
     *                 each host to improve performance, though the files must
     *                 appear as the same data set from the perspective of all
     *                 hosts performing the load.
     *             <li>{@link Options#DISTRIBUTED_LOCAL DISTRIBUTED_LOCAL}: A
     *                 single worker process on each node loads all files that
     *                 are available to it. This option works best when each
     *                 worker loads files from its own file system, to maximize
     *                 performance. In order to avoid data duplication, either
     *                 each worker performing the load needs to have visibility
     *                 to a set of files unique to it (no file is visible to
     *                 more than one node) or the target table needs to have a
     *                 primary key (which will allow the worker to
     *                 automatically deduplicate data).  NOTE:  If the target
     *                 table doesn't exist, the table structure will be
     *                 determined by the head node. If the head node has no
     *                 files local to it, it will be unable to determine the
     *                 structure and the request will fail.  If the head node
     *                 is configured to have no worker processes, no data
     *                 strictly accessible to the head node will be loaded.
     *         </ul>
     *         The default value is {@link Options#HEAD HEAD}.
     *     <li>{@link Options#LOCAL_TIME_OFFSET LOCAL_TIME_OFFSET}: Apply an
     *         offset to Avro local timestamp columns.
     *     <li>{@link Options#MAX_RECORDS_TO_LOAD MAX_RECORDS_TO_LOAD}: Limit
     *         the number of records to load in this request: if this number is
     *         larger than {@link Options#BATCH_SIZE BATCH_SIZE}, then the
     *         number of records loaded will be limited to the next whole
     *         number of {@link Options#BATCH_SIZE BATCH_SIZE} (per working
     *         thread).
     *     <li>{@link Options#NUM_TASKS_PER_RANK NUM_TASKS_PER_RANK}: Number of
     *         tasks for reading file per rank. Default will be system
     *         configuration parameter, external_file_reader_num_tasks.
     *     <li>{@link Options#POLL_INTERVAL POLL_INTERVAL}: If {@link
     *         Options#TRUE TRUE}, the number of seconds between attempts to
     *         load external files into the table.  If zero, polling will be
     *         continuous as long as data is found.  If no data is found, the
     *         interval will steadily increase to a maximum of 60 seconds. The
     *         default value is '0'.
     *     <li>{@link Options#PRIMARY_KEYS PRIMARY_KEYS}: Comma separated list
     *         of column names to set as primary keys, when not specified in
     *         the type.
     *     <li>{@link Options#REFRESH_METHOD REFRESH_METHOD}: Method by which
     *         the table can be refreshed from its source data.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#MANUAL MANUAL}: Refresh only occurs when
     *                 manually requested by invoking the refresh action of
     *                 {@link com.gpudb.GPUdb#alterTable(AlterTableRequest)
     *                 GPUdb.alterTable} on this table.
     *             <li>{@link Options#ON_START ON_START}: Refresh table on
     *                 database startup and when manually requested by invoking
     *                 the refresh action of {@link
     *                 com.gpudb.GPUdb#alterTable(AlterTableRequest)
     *                 GPUdb.alterTable} on this table.
     *         </ul>
     *         The default value is {@link Options#MANUAL MANUAL}.
     *     <li>{@link Options#SCHEMA_REGISTRY_CONNECTION_RETRIES
     *         SCHEMA_REGISTRY_CONNECTION_RETRIES}: Confluent Schema registry
     *         connection timeout (in Secs)
     *     <li>{@link Options#SCHEMA_REGISTRY_CONNECTION_TIMEOUT
     *         SCHEMA_REGISTRY_CONNECTION_TIMEOUT}: Confluent Schema registry
     *         connection timeout (in Secs)
     *     <li>{@link
     *         Options#SCHEMA_REGISTRY_MAX_CONSECUTIVE_CONNECTION_FAILURES
     *         SCHEMA_REGISTRY_MAX_CONSECUTIVE_CONNECTION_FAILURES}: Max
     *         records to skip due to SR connection failures, before failing
     *     <li>{@link Options#MAX_CONSECUTIVE_INVALID_SCHEMA_FAILURE
     *         MAX_CONSECUTIVE_INVALID_SCHEMA_FAILURE}: Max records to skip due
     *         to schema related errors, before failing
     *     <li>{@link Options#SCHEMA_REGISTRY_SCHEMA_NAME
     *         SCHEMA_REGISTRY_SCHEMA_NAME}: Name of the Avro schema in the
     *         schema registry to use when reading Avro records.
     *     <li>{@link Options#SHARD_KEYS SHARD_KEYS}: Comma separated list of
     *         column names to set as shard keys, when not specified in the
     *         type.
     *     <li>{@link Options#SKIP_LINES SKIP_LINES}: Skip a number of lines
     *         from the beginning of the file.
     *     <li>{@link Options#START_OFFSETS START_OFFSETS}: Starting offsets by
     *         partition to fetch from kafka. A comma separated list of
     *         partition:offset pairs.
     *     <li>{@link Options#SUBSCRIBE SUBSCRIBE}: Continuously poll the data
     *         source to check for new data and load it into the table.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TABLE_INSERT_MODE TABLE_INSERT_MODE}: Insertion
     *         scheme to use when inserting records from multiple shapefiles.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#SINGLE SINGLE}: Insert all records into a
     *                 single table.
     *             <li>{@link Options#TABLE_PER_FILE TABLE_PER_FILE}: Insert
     *                 records from each file into a new table corresponding to
     *                 that file.
     *         </ul>
     *         The default value is {@link Options#SINGLE SINGLE}.
     *     <li>{@link Options#TEXT_COMMENT_STRING TEXT_COMMENT_STRING}:
     *         Specifies the character string that should be interpreted as a
     *         comment line prefix in the source data.  All lines in the data
     *         starting with the provided string are ignored.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is '#'.
     *     <li>{@link Options#TEXT_DELIMITER TEXT_DELIMITER}: Specifies the
     *         character delimiting field values in the source data and field
     *         names in the header (if present).  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is ','.
     *     <li>{@link Options#TEXT_ESCAPE_CHARACTER TEXT_ESCAPE_CHARACTER}:
     *         Specifies the character that is used to escape other characters
     *         in the source data.  An 'a', 'b', 'f', 'n', 'r', 't', or 'v'
     *         preceded by an escape character will be interpreted as the ASCII
     *         bell, backspace, form feed, line feed, carriage return,
     *         horizontal tab, & vertical tab, respectively.  For example, the
     *         escape character followed by an 'n' will be interpreted as a
     *         newline within a field value.  The escape character can also be
     *         used to escape the quoting character, and will be treated as an
     *         escape character whether it is within a quoted field value or
     *         not.  For {@link Options#DELIMITED_TEXT DELIMITED_TEXT} {@link
     *         Options#FILE_TYPE FILE_TYPE} only.
     *     <li>{@link Options#TEXT_HAS_HEADER TEXT_HAS_HEADER}: Indicates
     *         whether the source data contains a header row.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#TEXT_HEADER_PROPERTY_DELIMITER
     *         TEXT_HEADER_PROPERTY_DELIMITER}: Specifies the delimiter for <a
     *         href="../../../../../../concepts/types/#column-properties"
     *         target="_top">column properties</a> in the header row (if
     *         present).  Cannot be set to same value as {@link
     *         Options#TEXT_DELIMITER TEXT_DELIMITER}.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is '|'.
     *     <li>{@link Options#TEXT_NULL_STRING TEXT_NULL_STRING}: Specifies the
     *         character string that should be interpreted as a null value in
     *         the source data.  For {@link Options#DELIMITED_TEXT
     *         DELIMITED_TEXT} {@link Options#FILE_TYPE FILE_TYPE} only. The
     *         default value is '\N'.
     *     <li>{@link Options#TEXT_QUOTE_CHARACTER TEXT_QUOTE_CHARACTER}:
     *         Specifies the character that should be interpreted as a field
     *         value quoting character in the source data.  The character must
     *         appear at beginning and end of field value to take effect.
     *         Delimiters within quoted fields are treated as literals and not
     *         delimiters.  Within a quoted field, two consecutive quote
     *         characters will be interpreted as a single literal quote
     *         character, effectively escaping it.  To not have a quote
     *         character, specify an empty string.  For {@link
     *         Options#DELIMITED_TEXT DELIMITED_TEXT} {@link Options#FILE_TYPE
     *         FILE_TYPE} only. The default value is '"'.
     *     <li>{@link Options#TEXT_SEARCH_COLUMNS TEXT_SEARCH_COLUMNS}: Add
     *         'text_search' property to internally inferenced string columns.
     *         Comma separated list of column names or '*' for all columns. To
     *         add 'text_search' property only to string columns greater than
     *         or equal to a minimum size, also set the {@link
     *         Options#TEXT_SEARCH_MIN_COLUMN_LENGTH
     *         TEXT_SEARCH_MIN_COLUMN_LENGTH}
     *     <li>{@link Options#TEXT_SEARCH_MIN_COLUMN_LENGTH
     *         TEXT_SEARCH_MIN_COLUMN_LENGTH}: Set the minimum column size for
     *         strings to apply the 'text_search' property to. Used only when
     *         {@link Options#TEXT_SEARCH_COLUMNS TEXT_SEARCH_COLUMNS} has a
     *         value.
     *     <li>{@link Options#TRUNCATE_STRINGS TRUNCATE_STRINGS}: If set to
     *         {@link Options#TRUE TRUE}, truncate string values that are
     *         longer than the column's type size.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TRUNCATE_TABLE TRUNCATE_TABLE}: If set to {@link
     *         Options#TRUE TRUE}, truncates the table specified by {@link
     *         #getTableName() tableName} prior to loading the file(s).
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TYPE_INFERENCE_MAX_RECORDS_READ
     *         TYPE_INFERENCE_MAX_RECORDS_READ}
     *     <li>{@link Options#TYPE_INFERENCE_MODE TYPE_INFERENCE_MODE}:
     *         Optimize type inferencing for either speed or accuracy.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#ACCURACY ACCURACY}: Scans data to get
     *                 exactly-typed & sized columns for all data scanned.
     *             <li>{@link Options#SPEED SPEED}: Scans data and picks the
     *                 widest possible column types so that 'all' values will
     *                 fit with minimum data scanned
     *         </ul>
     *         The default value is {@link Options#SPEED SPEED}.
     *     <li>{@link Options#REMOTE_QUERY REMOTE_QUERY}: Remote SQL query from
     *         which data will be sourced
     *     <li>{@link Options#REMOTE_QUERY_FILTER_COLUMN
     *         REMOTE_QUERY_FILTER_COLUMN}: Name of column to be used for
     *         splitting {@link Options#REMOTE_QUERY REMOTE_QUERY} into
     *         multiple sub-queries using the data distribution of given column
     *     <li>{@link Options#REMOTE_QUERY_INCREASING_COLUMN
     *         REMOTE_QUERY_INCREASING_COLUMN}: Column on subscribed remote
     *         query result that will increase for new records (e.g.,
     *         TIMESTAMP).
     *     <li>{@link Options#REMOTE_QUERY_PARTITION_COLUMN
     *         REMOTE_QUERY_PARTITION_COLUMN}: Alias name for {@link
     *         Options#REMOTE_QUERY_FILTER_COLUMN REMOTE_QUERY_FILTER_COLUMN}.
     *     <li>{@link Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK}:
     *         Specifies the record collision policy for inserting into a table
     *         with a <a href="../../../../../../concepts/tables/#primary-keys"
     *         target="_top">primary key</a>. If set to {@link Options#TRUE
     *         TRUE}, any existing table record with primary key values that
     *         match those of a record being inserted will be replaced by that
     *         new record (the new data will be 'upserted'). If set to {@link
     *         Options#FALSE FALSE}, any existing table record with primary key
     *         values that match those of a record being inserted will remain
     *         unchanged, while the new record will be rejected and the error
     *         handled as determined by {@link Options#IGNORE_EXISTING_PK
     *         IGNORE_EXISTING_PK} & {@link Options#ERROR_HANDLING
     *         ERROR_HANDLING}.  If the specified table does not have a primary
     *         key, then this option has no effect.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Upsert new records when
     *                 primary keys match existing records
     *             <li>{@link Options#FALSE FALSE}: Reject new records when
     *                 primary keys match existing records
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @param options  The new value for {@code options}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public CreateTableExternalRequest setOptions(Map<String, String> options) {
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
        return this;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @return The schema object describing this class.
     */
    @Override
    public Schema getSchema() {
        return schema$;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @param index  the position of the field to get
     *
     * @return value of the field with the given index.
     *
     * @throws IndexOutOfBoundsException
     */
    @Override
    public Object get(int index) {
        switch (index) {
            case 0:
                return this.tableName;

            case 1:
                return this.filepaths;

            case 2:
                return this.modifyColumns;

            case 3:
                return this.createTableOptions;

            case 4:
                return this.options;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @param index  the position of the field to set
     * @param value  the value to set
     *
     * @throws IndexOutOfBoundsException
     */
    @Override
    @SuppressWarnings("unchecked")
    public void put(int index, Object value) {
        switch (index) {
            case 0:
                this.tableName = (String)value;
                break;

            case 1:
                this.filepaths = (List<String>)value;
                break;

            case 2:
                this.modifyColumns = (Map<String, Map<String, String>>)value;
                break;

            case 3:
                this.createTableOptions = (Map<String, String>)value;
                break;

            case 4:
                this.options = (Map<String, String>)value;
                break;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if( obj == this ) {
            return true;
        }

        if( (obj == null) || (obj.getClass() != this.getClass()) ) {
            return false;
        }

        CreateTableExternalRequest that = (CreateTableExternalRequest)obj;

        return ( this.tableName.equals( that.tableName )
                 && this.filepaths.equals( that.filepaths )
                 && this.modifyColumns.equals( that.modifyColumns )
                 && this.createTableOptions.equals( that.createTableOptions )
                 && this.options.equals( that.options ) );
    }

    @Override
    public String toString() {
        GenericData gd = GenericData.get();
        StringBuilder builder = new StringBuilder();
        builder.append( "{" );
        builder.append( gd.toString( "tableName" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.tableName ) );
        builder.append( ", " );
        builder.append( gd.toString( "filepaths" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.filepaths ) );
        builder.append( ", " );
        builder.append( gd.toString( "modifyColumns" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.modifyColumns ) );
        builder.append( ", " );
        builder.append( gd.toString( "createTableOptions" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.createTableOptions ) );
        builder.append( ", " );
        builder.append( gd.toString( "options" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.options ) );
        builder.append( "}" );

        return builder.toString();
    }

    @Override
    public int hashCode() {
        int hashCode = 1;
        hashCode = (31 * hashCode) + this.tableName.hashCode();
        hashCode = (31 * hashCode) + this.filepaths.hashCode();
        hashCode = (31 * hashCode) + this.modifyColumns.hashCode();
        hashCode = (31 * hashCode) + this.createTableOptions.hashCode();
        hashCode = (31 * hashCode) + this.options.hashCode();
        return hashCode;
    }
}
