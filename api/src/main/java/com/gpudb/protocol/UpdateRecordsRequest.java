/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
package com.gpudb.protocol;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.apache.avro.generic.GenericData;

/**
 * A set of parameters for {@link
 * com.gpudb.GPUdb#updateRecords(UpdateRecordsRequest) GPUdb.updateRecords}.
 * <p>
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in {@link #getNewValuesMaps() newValuesMaps}.  There is also an
 * optional 'upsert' capability where if a particular predicate doesn't match
 * any existing record, then a new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through {@link
 * #getOptions() options}.
 * <p>
 * The {@link Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK} option
 * specifies the record primary key collision policy for tables with a <a
 * href="../../../../../../concepts/tables/#primary-keys" target="_top">primary
 * key</a>, while {@link Options#IGNORE_EXISTING_PK IGNORE_EXISTING_PK}
 * specifies the record primary key collision error-suppression policy when
 * those collisions result in the update being rejected.  Both are ignored on
 * tables with no primary key.
 *
 * @param <T>  The type of object being processed.
 *
 */
public class UpdateRecordsRequest<T> {
    /**
     * A set of string constants for the {@link UpdateRecordsRequest} parameter
     * {@link #getOptions() options}.
     * <p>
     * Optional parameters.
     */
    public static final class Options {
        /**
         * An optional global expression to reduce the search space of the
         * predicates listed in {@link #getExpressions() expressions}. The
         * default value is ''.
         */
        public static final String GLOBAL_EXPRESSION = "global_expression";

        /**
         * When set to {@link Options#TRUE TRUE}, all predicates are available
         * for primary key updates.  Keep in mind that it is possible to
         * destroy data in this case, since a single predicate may match
         * multiple objects (potentially all of records of a table), and then
         * updating all of those records to have the same primary key will, due
         * to the primary key uniqueness constraints, effectively delete all
         * but one of those updated records.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String BYPASS_SAFETY_CHECKS = "bypass_safety_checks";

        public static final String TRUE = "true";
        public static final String FALSE = "false";

        /**
         * Specifies the record collision policy for updating a table with a <a
         * href="../../../../../../concepts/tables/#primary-keys"
         * target="_top">primary key</a>.  There are two ways that a record
         * collision can occur.
         * <p>
         * The first is an "update collision", which happens when the update
         * changes the value of the updated record's primary key, and that new
         * primary key already exists as the primary key of another record in
         * the table.
         * <p>
         * The second is an "insert collision", which occurs when a given
         * filter in {@link #getExpressions() expressions} finds no records to
         * update, and the alternate insert record given in {@link #getData()
         * data} (or {@code recordsToInsertStr}) contains a primary key
         * matching that of an existing record in the table.
         * <p>
         * If {@link Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK} is
         * set to {@link Options#TRUE TRUE}, "update collisions" will result in
         * the existing record collided into being removed and the record
         * updated with values specified in {@link #getNewValuesMaps()
         * newValuesMaps} taking its place; "insert collisions" will result in
         * the collided-into record being updated with the values in {@link
         * #getData() data}/{@code recordsToInsertStr} (if given).
         * <p>
         * If set to {@link Options#FALSE FALSE}, the existing collided-into
         * record will remain unchanged, while the update will be rejected and
         * the error handled as determined by {@link Options#IGNORE_EXISTING_PK
         * IGNORE_EXISTING_PK}.  If the specified table does not have a primary
         * key, then this option has no effect.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Overwrite the collided-into
         *         record when updating a record's primary key or inserting an
         *         alternate record causes a primary key collision between the
         *         record being updated/inserted and another existing record in
         *         the table
         *     <li>{@link Options#FALSE FALSE}: Reject updates which cause
         *         primary key collisions between the record being
         *         updated/inserted and an existing record in the table
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String UPDATE_ON_EXISTING_PK = "update_on_existing_pk";

        /**
         * Specifies the record collision error-suppression policy for updating
         * a table with a <a
         * href="../../../../../../concepts/tables/#primary-keys"
         * target="_top">primary key</a>, only used when primary key record
         * collisions are rejected ({@link Options#UPDATE_ON_EXISTING_PK
         * UPDATE_ON_EXISTING_PK} is {@link Options#FALSE FALSE}).  If set to
         * {@link Options#TRUE TRUE}, any record update that is rejected for
         * resulting in a primary key collision with an existing table record
         * will be ignored with no error generated.  If {@link Options#FALSE
         * FALSE}, the rejection of any update for resulting in a primary key
         * collision will cause an error to be reported.  If the specified
         * table does not have a primary key or if {@link
         * Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK} is {@link
         * Options#TRUE TRUE}, then this option has no effect.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: Ignore updates that result in
         *         primary key collisions with existing records
         *     <li>{@link Options#FALSE FALSE}: Treat as errors any updates
         *         that result in primary key collisions with existing records
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String IGNORE_EXISTING_PK = "ignore_existing_pk";

        /**
         * Force qualifying records to be deleted and reinserted so their
         * partition membership will be reevaluated.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String UPDATE_PARTITION = "update_partition";

        /**
         * If set to {@link Options#TRUE TRUE}, any strings which are too long
         * for their charN string fields will be truncated to fit.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String TRUNCATE_STRINGS = "truncate_strings";

        /**
         * When set to {@link Options#TRUE TRUE}, all new values in {@link
         * #getNewValuesMaps() newValuesMaps} are considered as expression
         * values. When set to {@link Options#FALSE FALSE}, all new values in
         * {@link #getNewValuesMaps() newValuesMaps} are considered as
         * constants.  NOTE:  When {@link Options#TRUE TRUE}, string constants
         * will need to be quoted to avoid being evaluated as expressions.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String USE_EXPRESSIONS_IN_NEW_VALUES_MAPS = "use_expressions_in_new_values_maps";

        /**
         * ID of a single record to be updated (returned in the call to {@link
         * com.gpudb.GPUdb#insertRecords(InsertRecordsRequest)
         * GPUdb.insertRecords} or {@link
         * com.gpudb.GPUdb#getRecordsFromCollection(GetRecordsFromCollectionRequest)
         * GPUdb.getRecordsFromCollection}).
         */
        public static final String RECORD_ID = "record_id";

        private Options() {  }
    }

    private String tableName;
    private List<String> expressions;
    private List<Map<String, String>> newValuesMaps;
    private List<T> data;
    private Map<String, String> options;

    /**
     * Constructs an UpdateRecordsRequest object with default parameters.
     */
    public UpdateRecordsRequest() {
        tableName = "";
        expressions = new ArrayList<>();
        newValuesMaps = new ArrayList<>();
        data = new ArrayList<>();
        options = new LinkedHashMap<>();
    }

    /**
     * Constructs an UpdateRecordsRequest object with the specified parameters.
     *
     * @param tableName  Name of table to be updated, in
     *                   [schema_name.]table_name format, using standard <a
     *                   href="../../../../../../concepts/tables/#table-name-resolution"
     *                   target="_top">name resolution rules</a>.  Must be a
     *                   currently existing table and not a view.
     * @param expressions  A list of the actual predicates, one for each
     *                     update; format should follow the guidelines {@link
     *                     com.gpudb.GPUdb#filter(FilterRequest) here}.
     * @param newValuesMaps  List of new values for the matching records.  Each
     *                       element is a map with (key, value) pairs where the
     *                       keys are the names of the columns whose values are
     *                       to be updated; the values are the new values.  The
     *                       number of elements in the list should match the
     *                       length of {@code expressions}.
     * @param data  An *optional* list of new binary-avro encoded records to
     *              insert, one for each update.  If one of {@code expressions}
     *              does not yield a matching record to be updated, then the
     *              corresponding element from this list will be added to the
     *              table. The default value is an empty {@link List}.
     * @param options  Optional parameters.
     *                 <ul>
     *                     <li>{@link Options#GLOBAL_EXPRESSION
     *                         GLOBAL_EXPRESSION}: An optional global
     *                         expression to reduce the search space of the
     *                         predicates listed in {@code expressions}. The
     *                         default value is ''.
     *                     <li>{@link Options#BYPASS_SAFETY_CHECKS
     *                         BYPASS_SAFETY_CHECKS}: When set to {@link
     *                         Options#TRUE TRUE}, all predicates are available
     *                         for primary key updates.  Keep in mind that it
     *                         is possible to destroy data in this case, since
     *                         a single predicate may match multiple objects
     *                         (potentially all of records of a table), and
     *                         then updating all of those records to have the
     *                         same primary key will, due to the primary key
     *                         uniqueness constraints, effectively delete all
     *                         but one of those updated records.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#UPDATE_ON_EXISTING_PK
     *                         UPDATE_ON_EXISTING_PK}: Specifies the record
     *                         collision policy for updating a table with a <a
     *                         href="../../../../../../concepts/tables/#primary-keys"
     *                         target="_top">primary key</a>.  There are two
     *                         ways that a record collision can occur.  The
     *                         first is an "update collision", which happens
     *                         when the update changes the value of the updated
     *                         record's primary key, and that new primary key
     *                         already exists as the primary key of another
     *                         record in the table.  The second is an "insert
     *                         collision", which occurs when a given filter in
     *                         {@code expressions} finds no records to update,
     *                         and the alternate insert record given in {@code
     *                         data} (or {@code recordsToInsertStr}) contains a
     *                         primary key matching that of an existing record
     *                         in the table.  If {@link
     *                         Options#UPDATE_ON_EXISTING_PK
     *                         UPDATE_ON_EXISTING_PK} is set to {@link
     *                         Options#TRUE TRUE}, "update collisions" will
     *                         result in the existing record collided into
     *                         being removed and the record updated with values
     *                         specified in {@code newValuesMaps} taking its
     *                         place; "insert collisions" will result in the
     *                         collided-into record being updated with the
     *                         values in {@code data}/{@code
     *                         recordsToInsertStr} (if given).  If set to
     *                         {@link Options#FALSE FALSE}, the existing
     *                         collided-into record will remain unchanged,
     *                         while the update will be rejected and the error
     *                         handled as determined by {@link
     *                         Options#IGNORE_EXISTING_PK IGNORE_EXISTING_PK}.
     *                         If the specified table does not have a primary
     *                         key, then this option has no effect.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Overwrite the
     *                                 collided-into record when updating a
     *                                 record's primary key or inserting an
     *                                 alternate record causes a primary key
     *                                 collision between the record being
     *                                 updated/inserted and another existing
     *                                 record in the table
     *                             <li>{@link Options#FALSE FALSE}: Reject
     *                                 updates which cause primary key
     *                                 collisions between the record being
     *                                 updated/inserted and an existing record
     *                                 in the table
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#IGNORE_EXISTING_PK
     *                         IGNORE_EXISTING_PK}: Specifies the record
     *                         collision error-suppression policy for updating
     *                         a table with a <a
     *                         href="../../../../../../concepts/tables/#primary-keys"
     *                         target="_top">primary key</a>, only used when
     *                         primary key record collisions are rejected
     *                         ({@link Options#UPDATE_ON_EXISTING_PK
     *                         UPDATE_ON_EXISTING_PK} is {@link Options#FALSE
     *                         FALSE}).  If set to {@link Options#TRUE TRUE},
     *                         any record update that is rejected for resulting
     *                         in a primary key collision with an existing
     *                         table record will be ignored with no error
     *                         generated.  If {@link Options#FALSE FALSE}, the
     *                         rejection of any update for resulting in a
     *                         primary key collision will cause an error to be
     *                         reported.  If the specified table does not have
     *                         a primary key or if {@link
     *                         Options#UPDATE_ON_EXISTING_PK
     *                         UPDATE_ON_EXISTING_PK} is {@link Options#TRUE
     *                         TRUE}, then this option has no effect.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: Ignore
     *                                 updates that result in primary key
     *                                 collisions with existing records
     *                             <li>{@link Options#FALSE FALSE}: Treat as
     *                                 errors any updates that result in
     *                                 primary key collisions with existing
     *                                 records
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#UPDATE_PARTITION
     *                         UPDATE_PARTITION}: Force qualifying records to
     *                         be deleted and reinserted so their partition
     *                         membership will be reevaluated.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#TRUNCATE_STRINGS
     *                         TRUNCATE_STRINGS}: If set to {@link Options#TRUE
     *                         TRUE}, any strings which are too long for their
     *                         charN string fields will be truncated to fit.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link
     *                         Options#USE_EXPRESSIONS_IN_NEW_VALUES_MAPS
     *                         USE_EXPRESSIONS_IN_NEW_VALUES_MAPS}: When set to
     *                         {@link Options#TRUE TRUE}, all new values in
     *                         {@code newValuesMaps} are considered as
     *                         expression values. When set to {@link
     *                         Options#FALSE FALSE}, all new values in {@code
     *                         newValuesMaps} are considered as constants.
     *                         NOTE:  When {@link Options#TRUE TRUE}, string
     *                         constants will need to be quoted to avoid being
     *                         evaluated as expressions.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#RECORD_ID RECORD_ID}: ID of a
     *                         single record to be updated (returned in the
     *                         call to {@link
     *                         com.gpudb.GPUdb#insertRecords(InsertRecordsRequest)
     *                         GPUdb.insertRecords} or {@link
     *                         com.gpudb.GPUdb#getRecordsFromCollection(GetRecordsFromCollectionRequest)
     *                         GPUdb.getRecordsFromCollection}).
     *                 </ul>
     *                 The default value is an empty {@link Map}.
     */
    public UpdateRecordsRequest(String tableName, List<String> expressions, List<Map<String, String>> newValuesMaps, List<T> data, Map<String, String> options) {
        this.tableName = (tableName == null) ? "" : tableName;
        this.expressions = (expressions == null) ? new ArrayList<String>() : expressions;
        this.newValuesMaps = (newValuesMaps == null) ? new ArrayList<Map<String, String>>() : newValuesMaps;
        this.data = (data == null) ? new ArrayList<T>() : data;
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
    }

    /**
     * Name of table to be updated, in [schema_name.]table_name format, using
     * standard <a
     * href="../../../../../../concepts/tables/#table-name-resolution"
     * target="_top">name resolution rules</a>.  Must be a currently existing
     * table and not a view.
     *
     * @return The current value of {@code tableName}.
     */
    public String getTableName() {
        return tableName;
    }

    /**
     * Name of table to be updated, in [schema_name.]table_name format, using
     * standard <a
     * href="../../../../../../concepts/tables/#table-name-resolution"
     * target="_top">name resolution rules</a>.  Must be a currently existing
     * table and not a view.
     *
     * @param tableName  The new value for {@code tableName}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public UpdateRecordsRequest<T> setTableName(String tableName) {
        this.tableName = (tableName == null) ? "" : tableName;
        return this;
    }

    /**
     * A list of the actual predicates, one for each update; format should
     * follow the guidelines {@link com.gpudb.GPUdb#filter(FilterRequest)
     * here}.
     *
     * @return The current value of {@code expressions}.
     */
    public List<String> getExpressions() {
        return expressions;
    }

    /**
     * A list of the actual predicates, one for each update; format should
     * follow the guidelines {@link com.gpudb.GPUdb#filter(FilterRequest)
     * here}.
     *
     * @param expressions  The new value for {@code expressions}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public UpdateRecordsRequest<T> setExpressions(List<String> expressions) {
        this.expressions = (expressions == null) ? new ArrayList<String>() : expressions;
        return this;
    }

    /**
     * List of new values for the matching records.  Each element is a map with
     * (key, value) pairs where the keys are the names of the columns whose
     * values are to be updated; the values are the new values.  The number of
     * elements in the list should match the length of {@link #getExpressions()
     * expressions}.
     *
     * @return The current value of {@code newValuesMaps}.
     */
    public List<Map<String, String>> getNewValuesMaps() {
        return newValuesMaps;
    }

    /**
     * List of new values for the matching records.  Each element is a map with
     * (key, value) pairs where the keys are the names of the columns whose
     * values are to be updated; the values are the new values.  The number of
     * elements in the list should match the length of {@link #getExpressions()
     * expressions}.
     *
     * @param newValuesMaps  The new value for {@code newValuesMaps}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public UpdateRecordsRequest<T> setNewValuesMaps(List<Map<String, String>> newValuesMaps) {
        this.newValuesMaps = (newValuesMaps == null) ? new ArrayList<Map<String, String>>() : newValuesMaps;
        return this;
    }

    /**
     * An *optional* list of new binary-avro encoded records to insert, one for
     * each update.  If one of {@link #getExpressions() expressions} does not
     * yield a matching record to be updated, then the corresponding element
     * from this list will be added to the table. The default value is an empty
     * {@link List}.
     *
     * @return The current value of {@code data}.
     */
    public List<T> getData() {
        return data;
    }

    /**
     * An *optional* list of new binary-avro encoded records to insert, one for
     * each update.  If one of {@link #getExpressions() expressions} does not
     * yield a matching record to be updated, then the corresponding element
     * from this list will be added to the table. The default value is an empty
     * {@link List}.
     *
     * @param data  The new value for {@code data}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public UpdateRecordsRequest<T> setData(List<T> data) {
        this.data = (data == null) ? new ArrayList<T>() : data;
        return this;
    }

    /**
     * Optional parameters.
     * <ul>
     *     <li>{@link Options#GLOBAL_EXPRESSION GLOBAL_EXPRESSION}: An optional
     *         global expression to reduce the search space of the predicates
     *         listed in {@link #getExpressions() expressions}. The default
     *         value is ''.
     *     <li>{@link Options#BYPASS_SAFETY_CHECKS BYPASS_SAFETY_CHECKS}: When
     *         set to {@link Options#TRUE TRUE}, all predicates are available
     *         for primary key updates.  Keep in mind that it is possible to
     *         destroy data in this case, since a single predicate may match
     *         multiple objects (potentially all of records of a table), and
     *         then updating all of those records to have the same primary key
     *         will, due to the primary key uniqueness constraints, effectively
     *         delete all but one of those updated records.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK}:
     *         Specifies the record collision policy for updating a table with
     *         a <a href="../../../../../../concepts/tables/#primary-keys"
     *         target="_top">primary key</a>.  There are two ways that a record
     *         collision can occur.  The first is an "update collision", which
     *         happens when the update changes the value of the updated
     *         record's primary key, and that new primary key already exists as
     *         the primary key of another record in the table.  The second is
     *         an "insert collision", which occurs when a given filter in
     *         {@link #getExpressions() expressions} finds no records to
     *         update, and the alternate insert record given in {@link
     *         #getData() data} (or {@code recordsToInsertStr}) contains a
     *         primary key matching that of an existing record in the table.
     *         If {@link Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK}
     *         is set to {@link Options#TRUE TRUE}, "update collisions" will
     *         result in the existing record collided into being removed and
     *         the record updated with values specified in {@link
     *         #getNewValuesMaps() newValuesMaps} taking its place; "insert
     *         collisions" will result in the collided-into record being
     *         updated with the values in {@link #getData() data}/{@code
     *         recordsToInsertStr} (if given).  If set to {@link Options#FALSE
     *         FALSE}, the existing collided-into record will remain unchanged,
     *         while the update will be rejected and the error handled as
     *         determined by {@link Options#IGNORE_EXISTING_PK
     *         IGNORE_EXISTING_PK}.  If the specified table does not have a
     *         primary key, then this option has no effect.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Overwrite the collided-into
     *                 record when updating a record's primary key or inserting
     *                 an alternate record causes a primary key collision
     *                 between the record being updated/inserted and another
     *                 existing record in the table
     *             <li>{@link Options#FALSE FALSE}: Reject updates which cause
     *                 primary key collisions between the record being
     *                 updated/inserted and an existing record in the table
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#IGNORE_EXISTING_PK IGNORE_EXISTING_PK}: Specifies
     *         the record collision error-suppression policy for updating a
     *         table with a <a
     *         href="../../../../../../concepts/tables/#primary-keys"
     *         target="_top">primary key</a>, only used when primary key record
     *         collisions are rejected ({@link Options#UPDATE_ON_EXISTING_PK
     *         UPDATE_ON_EXISTING_PK} is {@link Options#FALSE FALSE}).  If set
     *         to {@link Options#TRUE TRUE}, any record update that is rejected
     *         for resulting in a primary key collision with an existing table
     *         record will be ignored with no error generated.  If {@link
     *         Options#FALSE FALSE}, the rejection of any update for resulting
     *         in a primary key collision will cause an error to be reported.
     *         If the specified table does not have a primary key or if {@link
     *         Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK} is {@link
     *         Options#TRUE TRUE}, then this option has no effect.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Ignore updates that result in
     *                 primary key collisions with existing records
     *             <li>{@link Options#FALSE FALSE}: Treat as errors any updates
     *                 that result in primary key collisions with existing
     *                 records
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#UPDATE_PARTITION UPDATE_PARTITION}: Force
     *         qualifying records to be deleted and reinserted so their
     *         partition membership will be reevaluated.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TRUNCATE_STRINGS TRUNCATE_STRINGS}: If set to
     *         {@link Options#TRUE TRUE}, any strings which are too long for
     *         their charN string fields will be truncated to fit.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#USE_EXPRESSIONS_IN_NEW_VALUES_MAPS
     *         USE_EXPRESSIONS_IN_NEW_VALUES_MAPS}: When set to {@link
     *         Options#TRUE TRUE}, all new values in {@link #getNewValuesMaps()
     *         newValuesMaps} are considered as expression values. When set to
     *         {@link Options#FALSE FALSE}, all new values in {@link
     *         #getNewValuesMaps() newValuesMaps} are considered as constants.
     *         NOTE:  When {@link Options#TRUE TRUE}, string constants will
     *         need to be quoted to avoid being evaluated as expressions.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#RECORD_ID RECORD_ID}: ID of a single record to be
     *         updated (returned in the call to {@link
     *         com.gpudb.GPUdb#insertRecords(InsertRecordsRequest)
     *         GPUdb.insertRecords} or {@link
     *         com.gpudb.GPUdb#getRecordsFromCollection(GetRecordsFromCollectionRequest)
     *         GPUdb.getRecordsFromCollection}).
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @return The current value of {@code options}.
     */
    public Map<String, String> getOptions() {
        return options;
    }

    /**
     * Optional parameters.
     * <ul>
     *     <li>{@link Options#GLOBAL_EXPRESSION GLOBAL_EXPRESSION}: An optional
     *         global expression to reduce the search space of the predicates
     *         listed in {@link #getExpressions() expressions}. The default
     *         value is ''.
     *     <li>{@link Options#BYPASS_SAFETY_CHECKS BYPASS_SAFETY_CHECKS}: When
     *         set to {@link Options#TRUE TRUE}, all predicates are available
     *         for primary key updates.  Keep in mind that it is possible to
     *         destroy data in this case, since a single predicate may match
     *         multiple objects (potentially all of records of a table), and
     *         then updating all of those records to have the same primary key
     *         will, due to the primary key uniqueness constraints, effectively
     *         delete all but one of those updated records.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK}:
     *         Specifies the record collision policy for updating a table with
     *         a <a href="../../../../../../concepts/tables/#primary-keys"
     *         target="_top">primary key</a>.  There are two ways that a record
     *         collision can occur.  The first is an "update collision", which
     *         happens when the update changes the value of the updated
     *         record's primary key, and that new primary key already exists as
     *         the primary key of another record in the table.  The second is
     *         an "insert collision", which occurs when a given filter in
     *         {@link #getExpressions() expressions} finds no records to
     *         update, and the alternate insert record given in {@link
     *         #getData() data} (or {@code recordsToInsertStr}) contains a
     *         primary key matching that of an existing record in the table.
     *         If {@link Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK}
     *         is set to {@link Options#TRUE TRUE}, "update collisions" will
     *         result in the existing record collided into being removed and
     *         the record updated with values specified in {@link
     *         #getNewValuesMaps() newValuesMaps} taking its place; "insert
     *         collisions" will result in the collided-into record being
     *         updated with the values in {@link #getData() data}/{@code
     *         recordsToInsertStr} (if given).  If set to {@link Options#FALSE
     *         FALSE}, the existing collided-into record will remain unchanged,
     *         while the update will be rejected and the error handled as
     *         determined by {@link Options#IGNORE_EXISTING_PK
     *         IGNORE_EXISTING_PK}.  If the specified table does not have a
     *         primary key, then this option has no effect.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Overwrite the collided-into
     *                 record when updating a record's primary key or inserting
     *                 an alternate record causes a primary key collision
     *                 between the record being updated/inserted and another
     *                 existing record in the table
     *             <li>{@link Options#FALSE FALSE}: Reject updates which cause
     *                 primary key collisions between the record being
     *                 updated/inserted and an existing record in the table
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#IGNORE_EXISTING_PK IGNORE_EXISTING_PK}: Specifies
     *         the record collision error-suppression policy for updating a
     *         table with a <a
     *         href="../../../../../../concepts/tables/#primary-keys"
     *         target="_top">primary key</a>, only used when primary key record
     *         collisions are rejected ({@link Options#UPDATE_ON_EXISTING_PK
     *         UPDATE_ON_EXISTING_PK} is {@link Options#FALSE FALSE}).  If set
     *         to {@link Options#TRUE TRUE}, any record update that is rejected
     *         for resulting in a primary key collision with an existing table
     *         record will be ignored with no error generated.  If {@link
     *         Options#FALSE FALSE}, the rejection of any update for resulting
     *         in a primary key collision will cause an error to be reported.
     *         If the specified table does not have a primary key or if {@link
     *         Options#UPDATE_ON_EXISTING_PK UPDATE_ON_EXISTING_PK} is {@link
     *         Options#TRUE TRUE}, then this option has no effect.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: Ignore updates that result in
     *                 primary key collisions with existing records
     *             <li>{@link Options#FALSE FALSE}: Treat as errors any updates
     *                 that result in primary key collisions with existing
     *                 records
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#UPDATE_PARTITION UPDATE_PARTITION}: Force
     *         qualifying records to be deleted and reinserted so their
     *         partition membership will be reevaluated.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#TRUNCATE_STRINGS TRUNCATE_STRINGS}: If set to
     *         {@link Options#TRUE TRUE}, any strings which are too long for
     *         their charN string fields will be truncated to fit.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#USE_EXPRESSIONS_IN_NEW_VALUES_MAPS
     *         USE_EXPRESSIONS_IN_NEW_VALUES_MAPS}: When set to {@link
     *         Options#TRUE TRUE}, all new values in {@link #getNewValuesMaps()
     *         newValuesMaps} are considered as expression values. When set to
     *         {@link Options#FALSE FALSE}, all new values in {@link
     *         #getNewValuesMaps() newValuesMaps} are considered as constants.
     *         NOTE:  When {@link Options#TRUE TRUE}, string constants will
     *         need to be quoted to avoid being evaluated as expressions.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#RECORD_ID RECORD_ID}: ID of a single record to be
     *         updated (returned in the call to {@link
     *         com.gpudb.GPUdb#insertRecords(InsertRecordsRequest)
     *         GPUdb.insertRecords} or {@link
     *         com.gpudb.GPUdb#getRecordsFromCollection(GetRecordsFromCollectionRequest)
     *         GPUdb.getRecordsFromCollection}).
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @param options  The new value for {@code options}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public UpdateRecordsRequest<T> setOptions(Map<String, String> options) {
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
        return this;
    }
    @Override
    public boolean equals(Object obj) {
        if( obj == this ) {
            return true;
        }

        if( (obj == null) || (obj.getClass() != this.getClass()) ) {
            return false;
        }

        UpdateRecordsRequest that = (UpdateRecordsRequest)obj;

        return ( this.tableName.equals( that.tableName )
                 && this.expressions.equals( that.expressions )
                 && this.newValuesMaps.equals( that.newValuesMaps )
                 && this.data.equals( that.data )
                 && this.options.equals( that.options ) );
    }

    @Override
    public String toString() {
        GenericData gd = GenericData.get();
        StringBuilder builder = new StringBuilder();
        builder.append( "{" );
        builder.append( gd.toString( "tableName" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.tableName ) );
        builder.append( ", " );
        builder.append( gd.toString( "expressions" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.expressions ) );
        builder.append( ", " );
        builder.append( gd.toString( "newValuesMaps" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.newValuesMaps ) );
        builder.append( ", " );
        builder.append( gd.toString( "data" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.data ) );
        builder.append( ", " );
        builder.append( gd.toString( "options" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.options ) );
        builder.append( "}" );

        return builder.toString();
    }

    @Override
    public int hashCode() {
        int hashCode = 1;
        hashCode = (31 * hashCode) + this.tableName.hashCode();
        hashCode = (31 * hashCode) + this.expressions.hashCode();
        hashCode = (31 * hashCode) + this.newValuesMaps.hashCode();
        hashCode = (31 * hashCode) + this.data.hashCode();
        hashCode = (31 * hashCode) + this.options.hashCode();
        return hashCode;
    }
}
