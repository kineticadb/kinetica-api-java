/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
package com.gpudb.protocol;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.apache.avro.Schema;
import org.apache.avro.SchemaBuilder;
import org.apache.avro.generic.GenericData;
import org.apache.avro.generic.IndexedRecord;

/**
 * A set of parameters for {@link com.gpudb.GPUdb#solveGraph(SolveGraphRequest)
 * GPUdb.solveGraph}.
 * <p>
 * Solves an existing graph for a type of problem (e.g., shortest path, page
 * rank, traveling salesman, etc.) using source nodes, destination nodes, and
 * additional, optional weights and restrictions.
 * <p>
 * IMPORTANT: It's highly recommended that you review the <a
 * href="../../../../../../graph_solver/network_graph_solver/"
 * target="_top">Graphs and Solvers</a> concepts documentation, the <a
 * href="../../../../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>, and/or some <a
 * href="../../../../../../guide-tags/graph---solve" target="_top">/solve/graph
 * examples</a> before using this endpoint.
 */
public class SolveGraphRequest implements IndexedRecord {
    private static final Schema schema$ = SchemaBuilder
            .record("SolveGraphRequest")
            .namespace("com.gpudb")
            .fields()
                .name("graphName").type().stringType().noDefault()
                .name("weightsOnEdges").type().array().items().stringType().noDefault()
                .name("restrictions").type().array().items().stringType().noDefault()
                .name("solverType").type().stringType().noDefault()
                .name("sourceNodes").type().array().items().stringType().noDefault()
                .name("destinationNodes").type().array().items().stringType().noDefault()
                .name("solutionTable").type().stringType().noDefault()
                .name("options").type().map().values().stringType().noDefault()
            .endRecord();

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @return The schema for the class.
     */
    public static Schema getClassSchema() {
        return schema$;
    }

    /**
     * A set of string constants for the {@link SolveGraphRequest} parameter
     * {@link #getSolverType() solverType}.
     * <p>
     * The type of solver to use for the graph.
     */
    public static final class SolverType {
        /**
         * Solves for the optimal (shortest) path based on weights and
         * restrictions from one source to destinations nodes. Also known as
         * the Dijkstra solver.
         */
        public static final String SHORTEST_PATH = "SHORTEST_PATH";

        /**
         * Solves for the probability of each destination node being visited
         * based on the links of the graph topology. Weights are not required
         * to use this solver.
         */
        public static final String PAGE_RANK = "PAGE_RANK";

        /**
         * Solves for the transitional probability (Hidden Markov) for each
         * node based on the weights (probability assigned over given edges).
         */
        public static final String PROBABILITY_RANK = "PROBABILITY_RANK";

        /**
         * Solves for the degree of a node to depict how many pairs of
         * individuals that would have to go through the node to reach one
         * another in the minimum number of hops. Also known as betweenness.
         */
        public static final String CENTRALITY = "CENTRALITY";

        /**
         * Solves for finding the minimum cost cumulative path for a round-trip
         * starting from the given source and visiting each given destination
         * node once then returning to the source. Also known as the traveling
         * salesman problem.
         */
        public static final String MULTIPLE_ROUTING = "MULTIPLE_ROUTING";

        /**
         * Solves for finding the optimal path cost for each destination node
         * to route to the source node. Also known as inverse Dijkstra or the
         * service man routing problem.
         */
        public static final String INVERSE_SHORTEST_PATH = "INVERSE_SHORTEST_PATH";

        /**
         * Solves for optimal routes that connect remote asset nodes to the
         * fixed (backbone) asset nodes.
         */
        public static final String BACKHAUL_ROUTING = "BACKHAUL_ROUTING";

        /**
         * Solves for paths that would give costs between max and min solution
         * radia - Make sure to limit by the 'max_solution_targets' option. Min
         * cost should be &gt;= shortest_path cost.
         */
        public static final String ALLPATHS = "ALLPATHS";

        /**
         * Solves for graph statistics such as graph diameter, longest pairs,
         * vertex valences, topology numbers, average and max cluster sizes,
         * etc.
         */
        public static final String STATS_ALL = "STATS_ALL";

        /**
         * Solves for the centrality closeness score per node as the sum of the
         * inverse shortest path costs to all nodes in the graph.
         */
        public static final String CLOSENESS = "CLOSENESS";

        private SolverType() {  }
    }

    /**
     * A set of string constants for the {@link SolveGraphRequest} parameter
     * {@link #getOptions() options}.
     * <p>
     * Additional parameters
     */
    public static final class Options {
        /**
         * For {@link SolverType#ALLPATHS ALLPATHS}, {@link
         * SolverType#SHORTEST_PATH SHORTEST_PATH} and {@link
         * SolverType#INVERSE_SHORTEST_PATH INVERSE_SHORTEST_PATH} solvers
         * only. Sets the maximum solution cost radius, which ignores the
         * {@link #getDestinationNodes() destinationNodes} list and instead
         * outputs the nodes within the radius sorted by ascending cost. If set
         * to '0.0', the setting is ignored. The default value is '0.0'.
         */
        public static final String MAX_SOLUTION_RADIUS = "max_solution_radius";

        /**
         * For {@link SolverType#ALLPATHS ALLPATHS}, {@link
         * SolverType#SHORTEST_PATH SHORTEST_PATH} and {@link
         * SolverType#INVERSE_SHORTEST_PATH INVERSE_SHORTEST_PATH} solvers
         * only. Applicable only when {@link Options#MAX_SOLUTION_RADIUS
         * MAX_SOLUTION_RADIUS} is set. Sets the minimum solution cost radius,
         * which ignores the {@link #getDestinationNodes() destinationNodes}
         * list and instead outputs the nodes within the radius sorted by
         * ascending cost. If set to '0.0', the setting is ignored. The default
         * value is '0.0'.
         */
        public static final String MIN_SOLUTION_RADIUS = "min_solution_radius";

        /**
         * For {@link SolverType#ALLPATHS ALLPATHS}, {@link
         * SolverType#SHORTEST_PATH SHORTEST_PATH} and {@link
         * SolverType#INVERSE_SHORTEST_PATH INVERSE_SHORTEST_PATH} solvers
         * only. Sets the maximum number of solution targets, which ignores the
         * {@link #getDestinationNodes() destinationNodes} list and instead
         * outputs no more than n number of nodes sorted by ascending cost
         * where n is equal to the setting value. If set to 0, the setting is
         * ignored. The default value is '1000'.
         */
        public static final String MAX_SOLUTION_TARGETS = "max_solution_targets";

        /**
         * When specified, assigns the given value to all the edges in the
         * graph. Note that weights provided in {@link #getWeightsOnEdges()
         * weightsOnEdges} will override this value.
         */
        public static final String UNIFORM_WEIGHTS = "uniform_weights";

        /**
         * This will add an additional weight over the edges labeled as 'left
         * turn' if the 'add_turn' option parameter of the {@link
         * com.gpudb.GPUdb#createGraph(CreateGraphRequest) GPUdb.createGraph}
         * was invoked at graph creation. The default value is '0.0'.
         */
        public static final String LEFT_TURN_PENALTY = "left_turn_penalty";

        /**
         * This will add an additional weight over the edges labeled as' right
         * turn' if the 'add_turn' option parameter of the {@link
         * com.gpudb.GPUdb#createGraph(CreateGraphRequest) GPUdb.createGraph}
         * was invoked at graph creation. The default value is '0.0'.
         */
        public static final String RIGHT_TURN_PENALTY = "right_turn_penalty";

        /**
         * This will add an additional weight over the edges labeled as
         * 'intersection' if the 'add_turn' option parameter of the {@link
         * com.gpudb.GPUdb#createGraph(CreateGraphRequest) GPUdb.createGraph}
         * was invoked at graph creation. The default value is '0.0'.
         */
        public static final String INTERSECTION_PENALTY = "intersection_penalty";

        /**
         * This will add an additional weight over the edges labeled as 'sharp
         * turn' or 'u-turn' if the 'add_turn' option parameter of the {@link
         * com.gpudb.GPUdb#createGraph(CreateGraphRequest) GPUdb.createGraph}
         * was invoked at graph creation. The default value is '0.0'.
         */
        public static final String SHARP_TURN_PENALTY = "sharp_turn_penalty";

        /**
         * For {@link SolverType#MULTIPLE_ROUTING MULTIPLE_ROUTING} solvers
         * only; sets the number of shortest paths computed from each node.
         * This is the heuristic criterion. Default value of zero allows the
         * number to be computed automatically by the solver. The user may want
         * to override this parameter to speed-up the solver. The default value
         * is '0'.
         */
        public static final String NUM_BEST_PATHS = "num_best_paths";

        /**
         * For {@link SolverType#MULTIPLE_ROUTING MULTIPLE_ROUTING} solvers
         * only; sets the cap on the combinatorial sequences generated. If the
         * default value of two millions is overridden to a lesser value, it
         * can potentially speed up the solver. The default value is '2000000'.
         */
        public static final String MAX_NUM_COMBINATIONS = "max_num_combinations";

        /**
         * If true then concatenated edge IDs will be added as the EDGE path
         * column of the solution table for each source and target pair in
         * shortest path solves.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String OUTPUT_EDGE_PATH = "output_edge_path";

        /**
         * An additional column 'CLUSTER' will be added for each node
         */
        public static final String TRUE = "true";

        /**
         * No extra cluster info per node will be available in the output
         */
        public static final String FALSE = "false";

        /**
         * If true then concatenated wkt line segments will be added as the
         * Wktroute column of the solution table for each source and target
         * pair in shortest path solves.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}
         *     <li>{@link Options#FALSE FALSE}
         * </ul>
         * The default value is {@link Options#TRUE TRUE}.
         */
        public static final String OUTPUT_WKT_PATH = "output_wkt_path";

        /**
         * Indicates which graph server(s) to send the request to. Default is
         * to send to the server, amongst those containing the corresponding
         * graph, that has the most computational bandwidth. For SHORTEST_PATH
         * solver type, the input is split amongst the server containing the
         * corresponding graph.
         */
        public static final String SERVER_ID = "server_id";

        /**
         * For {@link SolverType#PAGE_RANK PAGE_RANK} solvers only; Maximum
         * percent relative threshold on the page rank scores of each node
         * between consecutive iterations to satisfy convergence. Default value
         * is 1 (one) percent. The default value is '1.0'.
         */
        public static final String CONVERGENCE_LIMIT = "convergence_limit";

        /**
         * For {@link SolverType#PAGE_RANK PAGE_RANK} solvers only; Maximum
         * number of page rank iterations for satisfying convergence. Default
         * value is 100. The default value is '100'.
         */
        public static final String MAX_ITERATIONS = "max_iterations";

        /**
         * For all {@link SolverType#CENTRALITY CENTRALITY} solvers only; Sets
         * the maximum number of shortest path runs; maximum possible value is
         * the number of nodes in the graph. Default value of 0 enables this
         * value to be auto computed by the solver. The default value is '0'.
         */
        public static final String MAX_RUNS = "max_runs";

        /**
         * For {@link SolverType#STATS_ALL STATS_ALL} solvers only; the cluster
         * index for each node will be inserted as an additional column in the
         * output.
         * Supported values:
         * <ul>
         *     <li>{@link Options#TRUE TRUE}: An additional column 'CLUSTER'
         *         will be added for each node
         *     <li>{@link Options#FALSE FALSE}: No extra cluster info per node
         *         will be available in the output
         * </ul>
         * The default value is {@link Options#FALSE FALSE}.
         */
        public static final String OUTPUT_CLUSTERS = "output_clusters";

        /**
         * Specify heuristic search criterion only for the geo graphs and
         * shortest path solves towards a single target.
         * Supported values:
         * <ul>
         *     <li>{@link Options#ASTAR ASTAR}: Employs A-STAR heuristics to
         *         speed up the shortest path traversal
         *     <li>{@link Options#NONE NONE}: No heuristics are applied
         * </ul>
         * The default value is {@link Options#NONE NONE}.
         */
        public static final String SOLVE_HEURISTIC = "solve_heuristic";

        /**
         * Employs A-STAR heuristics to speed up the shortest path traversal
         */
        public static final String ASTAR = "astar";

        /**
         * No heuristics are applied
         */
        public static final String NONE = "none";

        /**
         * For path solvers only when 'solve_heuristic' option is 'astar'. The
         * shortest path traversal front includes nodes only within this radius
         * (kilometers) as it moves towards the target location. The default
         * value is '70'.
         */
        public static final String ASTAR_RADIUS = "astar_radius";

        private Options() {  }
    }

    private String graphName;
    private List<String> weightsOnEdges;
    private List<String> restrictions;
    private String solverType;
    private List<String> sourceNodes;
    private List<String> destinationNodes;
    private String solutionTable;
    private Map<String, String> options;

    /**
     * Constructs a SolveGraphRequest object with default parameters.
     */
    public SolveGraphRequest() {
        graphName = "";
        weightsOnEdges = new ArrayList<>();
        restrictions = new ArrayList<>();
        solverType = "";
        sourceNodes = new ArrayList<>();
        destinationNodes = new ArrayList<>();
        solutionTable = "";
        options = new LinkedHashMap<>();
    }

    /**
     * Constructs a SolveGraphRequest object with the specified parameters.
     *
     * @param graphName  Name of the graph resource to solve.
     * @param weightsOnEdges  Additional weights to apply to the edges of an
     *                        existing graph. Weights must be specified using
     *                        <a
     *                        href="../../../../../../graph_solver/network_graph_solver/#identifiers"
     *                        target="_top">identifiers</a>; identifiers are
     *                        grouped as <a
     *                        href="../../../../../../graph_solver/network_graph_solver/#id-combos"
     *                        target="_top">combinations</a>. Identifiers can
     *                        be used with existing column names, e.g.,
     *                        'table.column AS WEIGHTS_EDGE_ID', expressions,
     *                        e.g., 'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED',
     *                        or constant values, e.g., '{4, 15, 2} AS
     *                        WEIGHTS_VALUESPECIFIED'. Any provided weights
     *                        will be added (in the case of
     *                        'WEIGHTS_VALUESPECIFIED') to or multiplied with
     *                        (in the case of 'WEIGHTS_FACTORSPECIFIED') the
     *                        existing weight(s). If using constant values in
     *                        an identifier combination, the number of values
     *                        specified must match across the combination. The
     *                        default value is an empty {@link List}.
     * @param restrictions  Additional restrictions to apply to the nodes/edges
     *                      of an existing graph. Restrictions must be
     *                      specified using <a
     *                      href="../../../../../../graph_solver/network_graph_solver/#identifiers"
     *                      target="_top">identifiers</a>; identifiers are
     *                      grouped as <a
     *                      href="../../../../../../graph_solver/network_graph_solver/#id-combos"
     *                      target="_top">combinations</a>. Identifiers can be
     *                      used with existing column names, e.g.,
     *                      'table.column AS RESTRICTIONS_EDGE_ID',
     *                      expressions, e.g., 'column/2 AS
     *                      RESTRICTIONS_VALUECOMPARED', or constant values,
     *                      e.g., '{0, 0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'.
     *                      If using constant values in an identifier
     *                      combination, the number of values specified must
     *                      match across the combination. If
     *                      remove_previous_restrictions option is set to true,
     *                      any provided restrictions will replace the existing
     *                      restrictions. Otherwise, any provided restrictions
     *                      will be added (in the case of
     *                      'RESTRICTIONS_VALUECOMPARED') to or replaced (in
     *                      the case of 'RESTRICTIONS_ONOFFCOMPARED'). The
     *                      default value is an empty {@link List}.
     * @param solverType  The type of solver to use for the graph.
     *                    Supported values:
     *                    <ul>
     *                        <li>{@link SolverType#SHORTEST_PATH
     *                            SHORTEST_PATH}: Solves for the optimal
     *                            (shortest) path based on weights and
     *                            restrictions from one source to destinations
     *                            nodes. Also known as the Dijkstra solver.
     *                        <li>{@link SolverType#PAGE_RANK PAGE_RANK}:
     *                            Solves for the probability of each
     *                            destination node being visited based on the
     *                            links of the graph topology. Weights are not
     *                            required to use this solver.
     *                        <li>{@link SolverType#PROBABILITY_RANK
     *                            PROBABILITY_RANK}: Solves for the
     *                            transitional probability (Hidden Markov) for
     *                            each node based on the weights (probability
     *                            assigned over given edges).
     *                        <li>{@link SolverType#CENTRALITY CENTRALITY}:
     *                            Solves for the degree of a node to depict how
     *                            many pairs of individuals that would have to
     *                            go through the node to reach one another in
     *                            the minimum number of hops. Also known as
     *                            betweenness.
     *                        <li>{@link SolverType#MULTIPLE_ROUTING
     *                            MULTIPLE_ROUTING}: Solves for finding the
     *                            minimum cost cumulative path for a round-trip
     *                            starting from the given source and visiting
     *                            each given destination node once then
     *                            returning to the source. Also known as the
     *                            traveling salesman problem.
     *                        <li>{@link SolverType#INVERSE_SHORTEST_PATH
     *                            INVERSE_SHORTEST_PATH}: Solves for finding
     *                            the optimal path cost for each destination
     *                            node to route to the source node. Also known
     *                            as inverse Dijkstra or the service man
     *                            routing problem.
     *                        <li>{@link SolverType#BACKHAUL_ROUTING
     *                            BACKHAUL_ROUTING}: Solves for optimal routes
     *                            that connect remote asset nodes to the fixed
     *                            (backbone) asset nodes.
     *                        <li>{@link SolverType#ALLPATHS ALLPATHS}: Solves
     *                            for paths that would give costs between max
     *                            and min solution radia - Make sure to limit
     *                            by the 'max_solution_targets' option. Min
     *                            cost should be &gt;= shortest_path cost.
     *                        <li>{@link SolverType#STATS_ALL STATS_ALL}:
     *                            Solves for graph statistics such as graph
     *                            diameter, longest pairs, vertex valences,
     *                            topology numbers, average and max cluster
     *                            sizes, etc.
     *                        <li>{@link SolverType#CLOSENESS CLOSENESS}:
     *                            Solves for the centrality closeness score per
     *                            node as the sum of the inverse shortest path
     *                            costs to all nodes in the graph.
     *                    </ul>
     *                    The default value is {@link SolverType#SHORTEST_PATH
     *                    SHORTEST_PATH}.
     * @param sourceNodes  It can be one of the nodal identifiers - e.g:
     *                     'NODE_WKTPOINT' for source nodes. For {@link
     *                     SolverType#BACKHAUL_ROUTING BACKHAUL_ROUTING}, this
     *                     list depicts the fixed assets. The default value is
     *                     an empty {@link List}.
     * @param destinationNodes  It can be one of the nodal identifiers - e.g:
     *                          'NODE_WKTPOINT' for destination (target) nodes.
     *                          For {@link SolverType#BACKHAUL_ROUTING
     *                          BACKHAUL_ROUTING}, this list depicts the remote
     *                          assets. The default value is an empty {@link
     *                          List}.
     * @param solutionTable  Name of the table to store the solution, in
     *                       [schema_name.]table_name format, using standard <a
     *                       href="../../../../../../concepts/tables/#table-name-resolution"
     *                       target="_top">name resolution rules</a>. The
     *                       default value is 'graph_solutions'.
     * @param options  Additional parameters.
     *                 <ul>
     *                     <li>{@link Options#MAX_SOLUTION_RADIUS
     *                         MAX_SOLUTION_RADIUS}: For {@link
     *                         SolverType#ALLPATHS ALLPATHS}, {@link
     *                         SolverType#SHORTEST_PATH SHORTEST_PATH} and
     *                         {@link SolverType#INVERSE_SHORTEST_PATH
     *                         INVERSE_SHORTEST_PATH} solvers only. Sets the
     *                         maximum solution cost radius, which ignores the
     *                         {@code destinationNodes} list and instead
     *                         outputs the nodes within the radius sorted by
     *                         ascending cost. If set to '0.0', the setting is
     *                         ignored. The default value is '0.0'.
     *                     <li>{@link Options#MIN_SOLUTION_RADIUS
     *                         MIN_SOLUTION_RADIUS}: For {@link
     *                         SolverType#ALLPATHS ALLPATHS}, {@link
     *                         SolverType#SHORTEST_PATH SHORTEST_PATH} and
     *                         {@link SolverType#INVERSE_SHORTEST_PATH
     *                         INVERSE_SHORTEST_PATH} solvers only. Applicable
     *                         only when {@link Options#MAX_SOLUTION_RADIUS
     *                         MAX_SOLUTION_RADIUS} is set. Sets the minimum
     *                         solution cost radius, which ignores the {@code
     *                         destinationNodes} list and instead outputs the
     *                         nodes within the radius sorted by ascending
     *                         cost. If set to '0.0', the setting is ignored.
     *                         The default value is '0.0'.
     *                     <li>{@link Options#MAX_SOLUTION_TARGETS
     *                         MAX_SOLUTION_TARGETS}: For {@link
     *                         SolverType#ALLPATHS ALLPATHS}, {@link
     *                         SolverType#SHORTEST_PATH SHORTEST_PATH} and
     *                         {@link SolverType#INVERSE_SHORTEST_PATH
     *                         INVERSE_SHORTEST_PATH} solvers only. Sets the
     *                         maximum number of solution targets, which
     *                         ignores the {@code destinationNodes} list and
     *                         instead outputs no more than n number of nodes
     *                         sorted by ascending cost where n is equal to the
     *                         setting value. If set to 0, the setting is
     *                         ignored. The default value is '1000'.
     *                     <li>{@link Options#UNIFORM_WEIGHTS UNIFORM_WEIGHTS}:
     *                         When specified, assigns the given value to all
     *                         the edges in the graph. Note that weights
     *                         provided in {@code weightsOnEdges} will override
     *                         this value.
     *                     <li>{@link Options#LEFT_TURN_PENALTY
     *                         LEFT_TURN_PENALTY}: This will add an additional
     *                         weight over the edges labeled as 'left turn' if
     *                         the 'add_turn' option parameter of the {@link
     *                         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *                         GPUdb.createGraph} was invoked at graph
     *                         creation. The default value is '0.0'.
     *                     <li>{@link Options#RIGHT_TURN_PENALTY
     *                         RIGHT_TURN_PENALTY}: This will add an additional
     *                         weight over the edges labeled as' right turn' if
     *                         the 'add_turn' option parameter of the {@link
     *                         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *                         GPUdb.createGraph} was invoked at graph
     *                         creation. The default value is '0.0'.
     *                     <li>{@link Options#INTERSECTION_PENALTY
     *                         INTERSECTION_PENALTY}: This will add an
     *                         additional weight over the edges labeled as
     *                         'intersection' if the 'add_turn' option
     *                         parameter of the {@link
     *                         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *                         GPUdb.createGraph} was invoked at graph
     *                         creation. The default value is '0.0'.
     *                     <li>{@link Options#SHARP_TURN_PENALTY
     *                         SHARP_TURN_PENALTY}: This will add an additional
     *                         weight over the edges labeled as 'sharp turn' or
     *                         'u-turn' if the 'add_turn' option parameter of
     *                         the {@link
     *                         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *                         GPUdb.createGraph} was invoked at graph
     *                         creation. The default value is '0.0'.
     *                     <li>{@link Options#NUM_BEST_PATHS NUM_BEST_PATHS}:
     *                         For {@link SolverType#MULTIPLE_ROUTING
     *                         MULTIPLE_ROUTING} solvers only; sets the number
     *                         of shortest paths computed from each node. This
     *                         is the heuristic criterion. Default value of
     *                         zero allows the number to be computed
     *                         automatically by the solver. The user may want
     *                         to override this parameter to speed-up the
     *                         solver. The default value is '0'.
     *                     <li>{@link Options#MAX_NUM_COMBINATIONS
     *                         MAX_NUM_COMBINATIONS}: For {@link
     *                         SolverType#MULTIPLE_ROUTING MULTIPLE_ROUTING}
     *                         solvers only; sets the cap on the combinatorial
     *                         sequences generated. If the default value of two
     *                         millions is overridden to a lesser value, it can
     *                         potentially speed up the solver. The default
     *                         value is '2000000'.
     *                     <li>{@link Options#OUTPUT_EDGE_PATH
     *                         OUTPUT_EDGE_PATH}: If true then concatenated
     *                         edge IDs will be added as the EDGE path column
     *                         of the solution table for each source and target
     *                         pair in shortest path solves.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#OUTPUT_WKT_PATH OUTPUT_WKT_PATH}:
     *                         If true then concatenated wkt line segments will
     *                         be added as the Wktroute column of the solution
     *                         table for each source and target pair in
     *                         shortest path solves.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}
     *                             <li>{@link Options#FALSE FALSE}
     *                         </ul>
     *                         The default value is {@link Options#TRUE TRUE}.
     *                     <li>{@link Options#SERVER_ID SERVER_ID}: Indicates
     *                         which graph server(s) to send the request to.
     *                         Default is to send to the server, amongst those
     *                         containing the corresponding graph, that has the
     *                         most computational bandwidth. For SHORTEST_PATH
     *                         solver type, the input is split amongst the
     *                         server containing the corresponding graph.
     *                     <li>{@link Options#CONVERGENCE_LIMIT
     *                         CONVERGENCE_LIMIT}: For {@link
     *                         SolverType#PAGE_RANK PAGE_RANK} solvers only;
     *                         Maximum percent relative threshold on the page
     *                         rank scores of each node between consecutive
     *                         iterations to satisfy convergence. Default value
     *                         is 1 (one) percent. The default value is '1.0'.
     *                     <li>{@link Options#MAX_ITERATIONS MAX_ITERATIONS}:
     *                         For {@link SolverType#PAGE_RANK PAGE_RANK}
     *                         solvers only; Maximum number of page rank
     *                         iterations for satisfying convergence. Default
     *                         value is 100. The default value is '100'.
     *                     <li>{@link Options#MAX_RUNS MAX_RUNS}: For all
     *                         {@link SolverType#CENTRALITY CENTRALITY} solvers
     *                         only; Sets the maximum number of shortest path
     *                         runs; maximum possible value is the number of
     *                         nodes in the graph. Default value of 0 enables
     *                         this value to be auto computed by the solver.
     *                         The default value is '0'.
     *                     <li>{@link Options#OUTPUT_CLUSTERS OUTPUT_CLUSTERS}:
     *                         For {@link SolverType#STATS_ALL STATS_ALL}
     *                         solvers only; the cluster index for each node
     *                         will be inserted as an additional column in the
     *                         output.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#TRUE TRUE}: An additional
     *                                 column 'CLUSTER' will be added for each
     *                                 node
     *                             <li>{@link Options#FALSE FALSE}: No extra
     *                                 cluster info per node will be available
     *                                 in the output
     *                         </ul>
     *                         The default value is {@link Options#FALSE
     *                         FALSE}.
     *                     <li>{@link Options#SOLVE_HEURISTIC SOLVE_HEURISTIC}:
     *                         Specify heuristic search criterion only for the
     *                         geo graphs and shortest path solves towards a
     *                         single target.
     *                         Supported values:
     *                         <ul>
     *                             <li>{@link Options#ASTAR ASTAR}: Employs
     *                                 A-STAR heuristics to speed up the
     *                                 shortest path traversal
     *                             <li>{@link Options#NONE NONE}: No heuristics
     *                                 are applied
     *                         </ul>
     *                         The default value is {@link Options#NONE NONE}.
     *                     <li>{@link Options#ASTAR_RADIUS ASTAR_RADIUS}: For
     *                         path solvers only when 'solve_heuristic' option
     *                         is 'astar'. The shortest path traversal front
     *                         includes nodes only within this radius
     *                         (kilometers) as it moves towards the target
     *                         location. The default value is '70'.
     *                 </ul>
     *                 The default value is an empty {@link Map}.
     */
    public SolveGraphRequest(String graphName, List<String> weightsOnEdges, List<String> restrictions, String solverType, List<String> sourceNodes, List<String> destinationNodes, String solutionTable, Map<String, String> options) {
        this.graphName = (graphName == null) ? "" : graphName;
        this.weightsOnEdges = (weightsOnEdges == null) ? new ArrayList<String>() : weightsOnEdges;
        this.restrictions = (restrictions == null) ? new ArrayList<String>() : restrictions;
        this.solverType = (solverType == null) ? "" : solverType;
        this.sourceNodes = (sourceNodes == null) ? new ArrayList<String>() : sourceNodes;
        this.destinationNodes = (destinationNodes == null) ? new ArrayList<String>() : destinationNodes;
        this.solutionTable = (solutionTable == null) ? "" : solutionTable;
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
    }

    /**
     * Name of the graph resource to solve.
     *
     * @return The current value of {@code graphName}.
     */
    public String getGraphName() {
        return graphName;
    }

    /**
     * Name of the graph resource to solve.
     *
     * @param graphName  The new value for {@code graphName}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public SolveGraphRequest setGraphName(String graphName) {
        this.graphName = (graphName == null) ? "" : graphName;
        return this;
    }

    /**
     * Additional weights to apply to the edges of an existing graph. Weights
     * must be specified using <a
     * href="../../../../../../graph_solver/network_graph_solver/#identifiers"
     * target="_top">identifiers</a>; identifiers are grouped as <a
     * href="../../../../../../graph_solver/network_graph_solver/#id-combos"
     * target="_top">combinations</a>. Identifiers can be used with existing
     * column names, e.g., 'table.column AS WEIGHTS_EDGE_ID', expressions,
     * e.g., 'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED', or constant values,
     * e.g., '{4, 15, 2} AS WEIGHTS_VALUESPECIFIED'. Any provided weights will
     * be added (in the case of 'WEIGHTS_VALUESPECIFIED') to or multiplied with
     * (in the case of 'WEIGHTS_FACTORSPECIFIED') the existing weight(s). If
     * using constant values in an identifier combination, the number of values
     * specified must match across the combination. The default value is an
     * empty {@link List}.
     *
     * @return The current value of {@code weightsOnEdges}.
     */
    public List<String> getWeightsOnEdges() {
        return weightsOnEdges;
    }

    /**
     * Additional weights to apply to the edges of an existing graph. Weights
     * must be specified using <a
     * href="../../../../../../graph_solver/network_graph_solver/#identifiers"
     * target="_top">identifiers</a>; identifiers are grouped as <a
     * href="../../../../../../graph_solver/network_graph_solver/#id-combos"
     * target="_top">combinations</a>. Identifiers can be used with existing
     * column names, e.g., 'table.column AS WEIGHTS_EDGE_ID', expressions,
     * e.g., 'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED', or constant values,
     * e.g., '{4, 15, 2} AS WEIGHTS_VALUESPECIFIED'. Any provided weights will
     * be added (in the case of 'WEIGHTS_VALUESPECIFIED') to or multiplied with
     * (in the case of 'WEIGHTS_FACTORSPECIFIED') the existing weight(s). If
     * using constant values in an identifier combination, the number of values
     * specified must match across the combination. The default value is an
     * empty {@link List}.
     *
     * @param weightsOnEdges  The new value for {@code weightsOnEdges}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public SolveGraphRequest setWeightsOnEdges(List<String> weightsOnEdges) {
        this.weightsOnEdges = (weightsOnEdges == null) ? new ArrayList<String>() : weightsOnEdges;
        return this;
    }

    /**
     * Additional restrictions to apply to the nodes/edges of an existing
     * graph. Restrictions must be specified using <a
     * href="../../../../../../graph_solver/network_graph_solver/#identifiers"
     * target="_top">identifiers</a>; identifiers are grouped as <a
     * href="../../../../../../graph_solver/network_graph_solver/#id-combos"
     * target="_top">combinations</a>. Identifiers can be used with existing
     * column names, e.g., 'table.column AS RESTRICTIONS_EDGE_ID', expressions,
     * e.g., 'column/2 AS RESTRICTIONS_VALUECOMPARED', or constant values,
     * e.g., '{0, 0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using constant
     * values in an identifier combination, the number of values specified must
     * match across the combination. If remove_previous_restrictions option is
     * set to true, any provided restrictions will replace the existing
     * restrictions. Otherwise, any provided restrictions will be added (in the
     * case of 'RESTRICTIONS_VALUECOMPARED') to or replaced (in the case of
     * 'RESTRICTIONS_ONOFFCOMPARED'). The default value is an empty {@link
     * List}.
     *
     * @return The current value of {@code restrictions}.
     */
    public List<String> getRestrictions() {
        return restrictions;
    }

    /**
     * Additional restrictions to apply to the nodes/edges of an existing
     * graph. Restrictions must be specified using <a
     * href="../../../../../../graph_solver/network_graph_solver/#identifiers"
     * target="_top">identifiers</a>; identifiers are grouped as <a
     * href="../../../../../../graph_solver/network_graph_solver/#id-combos"
     * target="_top">combinations</a>. Identifiers can be used with existing
     * column names, e.g., 'table.column AS RESTRICTIONS_EDGE_ID', expressions,
     * e.g., 'column/2 AS RESTRICTIONS_VALUECOMPARED', or constant values,
     * e.g., '{0, 0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using constant
     * values in an identifier combination, the number of values specified must
     * match across the combination. If remove_previous_restrictions option is
     * set to true, any provided restrictions will replace the existing
     * restrictions. Otherwise, any provided restrictions will be added (in the
     * case of 'RESTRICTIONS_VALUECOMPARED') to or replaced (in the case of
     * 'RESTRICTIONS_ONOFFCOMPARED'). The default value is an empty {@link
     * List}.
     *
     * @param restrictions  The new value for {@code restrictions}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public SolveGraphRequest setRestrictions(List<String> restrictions) {
        this.restrictions = (restrictions == null) ? new ArrayList<String>() : restrictions;
        return this;
    }

    /**
     * The type of solver to use for the graph.
     * Supported values:
     * <ul>
     *     <li>{@link SolverType#SHORTEST_PATH SHORTEST_PATH}: Solves for the
     *         optimal (shortest) path based on weights and restrictions from
     *         one source to destinations nodes. Also known as the Dijkstra
     *         solver.
     *     <li>{@link SolverType#PAGE_RANK PAGE_RANK}: Solves for the
     *         probability of each destination node being visited based on the
     *         links of the graph topology. Weights are not required to use
     *         this solver.
     *     <li>{@link SolverType#PROBABILITY_RANK PROBABILITY_RANK}: Solves for
     *         the transitional probability (Hidden Markov) for each node based
     *         on the weights (probability assigned over given edges).
     *     <li>{@link SolverType#CENTRALITY CENTRALITY}: Solves for the degree
     *         of a node to depict how many pairs of individuals that would
     *         have to go through the node to reach one another in the minimum
     *         number of hops. Also known as betweenness.
     *     <li>{@link SolverType#MULTIPLE_ROUTING MULTIPLE_ROUTING}: Solves for
     *         finding the minimum cost cumulative path for a round-trip
     *         starting from the given source and visiting each given
     *         destination node once then returning to the source. Also known
     *         as the traveling salesman problem.
     *     <li>{@link SolverType#INVERSE_SHORTEST_PATH INVERSE_SHORTEST_PATH}:
     *         Solves for finding the optimal path cost for each destination
     *         node to route to the source node. Also known as inverse Dijkstra
     *         or the service man routing problem.
     *     <li>{@link SolverType#BACKHAUL_ROUTING BACKHAUL_ROUTING}: Solves for
     *         optimal routes that connect remote asset nodes to the fixed
     *         (backbone) asset nodes.
     *     <li>{@link SolverType#ALLPATHS ALLPATHS}: Solves for paths that
     *         would give costs between max and min solution radia - Make sure
     *         to limit by the 'max_solution_targets' option. Min cost should
     *         be &gt;= shortest_path cost.
     *     <li>{@link SolverType#STATS_ALL STATS_ALL}: Solves for graph
     *         statistics such as graph diameter, longest pairs, vertex
     *         valences, topology numbers, average and max cluster sizes, etc.
     *     <li>{@link SolverType#CLOSENESS CLOSENESS}: Solves for the
     *         centrality closeness score per node as the sum of the inverse
     *         shortest path costs to all nodes in the graph.
     * </ul>
     * The default value is {@link SolverType#SHORTEST_PATH SHORTEST_PATH}.
     *
     * @return The current value of {@code solverType}.
     */
    public String getSolverType() {
        return solverType;
    }

    /**
     * The type of solver to use for the graph.
     * Supported values:
     * <ul>
     *     <li>{@link SolverType#SHORTEST_PATH SHORTEST_PATH}: Solves for the
     *         optimal (shortest) path based on weights and restrictions from
     *         one source to destinations nodes. Also known as the Dijkstra
     *         solver.
     *     <li>{@link SolverType#PAGE_RANK PAGE_RANK}: Solves for the
     *         probability of each destination node being visited based on the
     *         links of the graph topology. Weights are not required to use
     *         this solver.
     *     <li>{@link SolverType#PROBABILITY_RANK PROBABILITY_RANK}: Solves for
     *         the transitional probability (Hidden Markov) for each node based
     *         on the weights (probability assigned over given edges).
     *     <li>{@link SolverType#CENTRALITY CENTRALITY}: Solves for the degree
     *         of a node to depict how many pairs of individuals that would
     *         have to go through the node to reach one another in the minimum
     *         number of hops. Also known as betweenness.
     *     <li>{@link SolverType#MULTIPLE_ROUTING MULTIPLE_ROUTING}: Solves for
     *         finding the minimum cost cumulative path for a round-trip
     *         starting from the given source and visiting each given
     *         destination node once then returning to the source. Also known
     *         as the traveling salesman problem.
     *     <li>{@link SolverType#INVERSE_SHORTEST_PATH INVERSE_SHORTEST_PATH}:
     *         Solves for finding the optimal path cost for each destination
     *         node to route to the source node. Also known as inverse Dijkstra
     *         or the service man routing problem.
     *     <li>{@link SolverType#BACKHAUL_ROUTING BACKHAUL_ROUTING}: Solves for
     *         optimal routes that connect remote asset nodes to the fixed
     *         (backbone) asset nodes.
     *     <li>{@link SolverType#ALLPATHS ALLPATHS}: Solves for paths that
     *         would give costs between max and min solution radia - Make sure
     *         to limit by the 'max_solution_targets' option. Min cost should
     *         be &gt;= shortest_path cost.
     *     <li>{@link SolverType#STATS_ALL STATS_ALL}: Solves for graph
     *         statistics such as graph diameter, longest pairs, vertex
     *         valences, topology numbers, average and max cluster sizes, etc.
     *     <li>{@link SolverType#CLOSENESS CLOSENESS}: Solves for the
     *         centrality closeness score per node as the sum of the inverse
     *         shortest path costs to all nodes in the graph.
     * </ul>
     * The default value is {@link SolverType#SHORTEST_PATH SHORTEST_PATH}.
     *
     * @param solverType  The new value for {@code solverType}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public SolveGraphRequest setSolverType(String solverType) {
        this.solverType = (solverType == null) ? "" : solverType;
        return this;
    }

    /**
     * It can be one of the nodal identifiers - e.g: 'NODE_WKTPOINT' for source
     * nodes. For {@link SolverType#BACKHAUL_ROUTING BACKHAUL_ROUTING}, this
     * list depicts the fixed assets. The default value is an empty {@link
     * List}.
     *
     * @return The current value of {@code sourceNodes}.
     */
    public List<String> getSourceNodes() {
        return sourceNodes;
    }

    /**
     * It can be one of the nodal identifiers - e.g: 'NODE_WKTPOINT' for source
     * nodes. For {@link SolverType#BACKHAUL_ROUTING BACKHAUL_ROUTING}, this
     * list depicts the fixed assets. The default value is an empty {@link
     * List}.
     *
     * @param sourceNodes  The new value for {@code sourceNodes}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public SolveGraphRequest setSourceNodes(List<String> sourceNodes) {
        this.sourceNodes = (sourceNodes == null) ? new ArrayList<String>() : sourceNodes;
        return this;
    }

    /**
     * It can be one of the nodal identifiers - e.g: 'NODE_WKTPOINT' for
     * destination (target) nodes. For {@link SolverType#BACKHAUL_ROUTING
     * BACKHAUL_ROUTING}, this list depicts the remote assets. The default
     * value is an empty {@link List}.
     *
     * @return The current value of {@code destinationNodes}.
     */
    public List<String> getDestinationNodes() {
        return destinationNodes;
    }

    /**
     * It can be one of the nodal identifiers - e.g: 'NODE_WKTPOINT' for
     * destination (target) nodes. For {@link SolverType#BACKHAUL_ROUTING
     * BACKHAUL_ROUTING}, this list depicts the remote assets. The default
     * value is an empty {@link List}.
     *
     * @param destinationNodes  The new value for {@code destinationNodes}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public SolveGraphRequest setDestinationNodes(List<String> destinationNodes) {
        this.destinationNodes = (destinationNodes == null) ? new ArrayList<String>() : destinationNodes;
        return this;
    }

    /**
     * Name of the table to store the solution, in [schema_name.]table_name
     * format, using standard <a
     * href="../../../../../../concepts/tables/#table-name-resolution"
     * target="_top">name resolution rules</a>. The default value is
     * 'graph_solutions'.
     *
     * @return The current value of {@code solutionTable}.
     */
    public String getSolutionTable() {
        return solutionTable;
    }

    /**
     * Name of the table to store the solution, in [schema_name.]table_name
     * format, using standard <a
     * href="../../../../../../concepts/tables/#table-name-resolution"
     * target="_top">name resolution rules</a>. The default value is
     * 'graph_solutions'.
     *
     * @param solutionTable  The new value for {@code solutionTable}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public SolveGraphRequest setSolutionTable(String solutionTable) {
        this.solutionTable = (solutionTable == null) ? "" : solutionTable;
        return this;
    }

    /**
     * Additional parameters.
     * <ul>
     *     <li>{@link Options#MAX_SOLUTION_RADIUS MAX_SOLUTION_RADIUS}: For
     *         {@link SolverType#ALLPATHS ALLPATHS}, {@link
     *         SolverType#SHORTEST_PATH SHORTEST_PATH} and {@link
     *         SolverType#INVERSE_SHORTEST_PATH INVERSE_SHORTEST_PATH} solvers
     *         only. Sets the maximum solution cost radius, which ignores the
     *         {@link #getDestinationNodes() destinationNodes} list and instead
     *         outputs the nodes within the radius sorted by ascending cost. If
     *         set to '0.0', the setting is ignored. The default value is
     *         '0.0'.
     *     <li>{@link Options#MIN_SOLUTION_RADIUS MIN_SOLUTION_RADIUS}: For
     *         {@link SolverType#ALLPATHS ALLPATHS}, {@link
     *         SolverType#SHORTEST_PATH SHORTEST_PATH} and {@link
     *         SolverType#INVERSE_SHORTEST_PATH INVERSE_SHORTEST_PATH} solvers
     *         only. Applicable only when {@link Options#MAX_SOLUTION_RADIUS
     *         MAX_SOLUTION_RADIUS} is set. Sets the minimum solution cost
     *         radius, which ignores the {@link #getDestinationNodes()
     *         destinationNodes} list and instead outputs the nodes within the
     *         radius sorted by ascending cost. If set to '0.0', the setting is
     *         ignored. The default value is '0.0'.
     *     <li>{@link Options#MAX_SOLUTION_TARGETS MAX_SOLUTION_TARGETS}: For
     *         {@link SolverType#ALLPATHS ALLPATHS}, {@link
     *         SolverType#SHORTEST_PATH SHORTEST_PATH} and {@link
     *         SolverType#INVERSE_SHORTEST_PATH INVERSE_SHORTEST_PATH} solvers
     *         only. Sets the maximum number of solution targets, which ignores
     *         the {@link #getDestinationNodes() destinationNodes} list and
     *         instead outputs no more than n number of nodes sorted by
     *         ascending cost where n is equal to the setting value. If set to
     *         0, the setting is ignored. The default value is '1000'.
     *     <li>{@link Options#UNIFORM_WEIGHTS UNIFORM_WEIGHTS}: When specified,
     *         assigns the given value to all the edges in the graph. Note that
     *         weights provided in {@link #getWeightsOnEdges() weightsOnEdges}
     *         will override this value.
     *     <li>{@link Options#LEFT_TURN_PENALTY LEFT_TURN_PENALTY}: This will
     *         add an additional weight over the edges labeled as 'left turn'
     *         if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#RIGHT_TURN_PENALTY RIGHT_TURN_PENALTY}: This will
     *         add an additional weight over the edges labeled as' right turn'
     *         if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#INTERSECTION_PENALTY INTERSECTION_PENALTY}: This
     *         will add an additional weight over the edges labeled as
     *         'intersection' if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#SHARP_TURN_PENALTY SHARP_TURN_PENALTY}: This will
     *         add an additional weight over the edges labeled as 'sharp turn'
     *         or 'u-turn' if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#NUM_BEST_PATHS NUM_BEST_PATHS}: For {@link
     *         SolverType#MULTIPLE_ROUTING MULTIPLE_ROUTING} solvers only; sets
     *         the number of shortest paths computed from each node. This is
     *         the heuristic criterion. Default value of zero allows the number
     *         to be computed automatically by the solver. The user may want to
     *         override this parameter to speed-up the solver. The default
     *         value is '0'.
     *     <li>{@link Options#MAX_NUM_COMBINATIONS MAX_NUM_COMBINATIONS}: For
     *         {@link SolverType#MULTIPLE_ROUTING MULTIPLE_ROUTING} solvers
     *         only; sets the cap on the combinatorial sequences generated. If
     *         the default value of two millions is overridden to a lesser
     *         value, it can potentially speed up the solver. The default value
     *         is '2000000'.
     *     <li>{@link Options#OUTPUT_EDGE_PATH OUTPUT_EDGE_PATH}: If true then
     *         concatenated edge IDs will be added as the EDGE path column of
     *         the solution table for each source and target pair in shortest
     *         path solves.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#OUTPUT_WKT_PATH OUTPUT_WKT_PATH}: If true then
     *         concatenated wkt line segments will be added as the Wktroute
     *         column of the solution table for each source and target pair in
     *         shortest path solves.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#SERVER_ID SERVER_ID}: Indicates which graph
     *         server(s) to send the request to. Default is to send to the
     *         server, amongst those containing the corresponding graph, that
     *         has the most computational bandwidth. For SHORTEST_PATH solver
     *         type, the input is split amongst the server containing the
     *         corresponding graph.
     *     <li>{@link Options#CONVERGENCE_LIMIT CONVERGENCE_LIMIT}: For {@link
     *         SolverType#PAGE_RANK PAGE_RANK} solvers only; Maximum percent
     *         relative threshold on the page rank scores of each node between
     *         consecutive iterations to satisfy convergence. Default value is
     *         1 (one) percent. The default value is '1.0'.
     *     <li>{@link Options#MAX_ITERATIONS MAX_ITERATIONS}: For {@link
     *         SolverType#PAGE_RANK PAGE_RANK} solvers only; Maximum number of
     *         page rank iterations for satisfying convergence. Default value
     *         is 100. The default value is '100'.
     *     <li>{@link Options#MAX_RUNS MAX_RUNS}: For all {@link
     *         SolverType#CENTRALITY CENTRALITY} solvers only; Sets the maximum
     *         number of shortest path runs; maximum possible value is the
     *         number of nodes in the graph. Default value of 0 enables this
     *         value to be auto computed by the solver. The default value is
     *         '0'.
     *     <li>{@link Options#OUTPUT_CLUSTERS OUTPUT_CLUSTERS}: For {@link
     *         SolverType#STATS_ALL STATS_ALL} solvers only; the cluster index
     *         for each node will be inserted as an additional column in the
     *         output.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: An additional column
     *                 'CLUSTER' will be added for each node
     *             <li>{@link Options#FALSE FALSE}: No extra cluster info per
     *                 node will be available in the output
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#SOLVE_HEURISTIC SOLVE_HEURISTIC}: Specify
     *         heuristic search criterion only for the geo graphs and shortest
     *         path solves towards a single target.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#ASTAR ASTAR}: Employs A-STAR heuristics
     *                 to speed up the shortest path traversal
     *             <li>{@link Options#NONE NONE}: No heuristics are applied
     *         </ul>
     *         The default value is {@link Options#NONE NONE}.
     *     <li>{@link Options#ASTAR_RADIUS ASTAR_RADIUS}: For path solvers only
     *         when 'solve_heuristic' option is 'astar'. The shortest path
     *         traversal front includes nodes only within this radius
     *         (kilometers) as it moves towards the target location. The
     *         default value is '70'.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @return The current value of {@code options}.
     */
    public Map<String, String> getOptions() {
        return options;
    }

    /**
     * Additional parameters.
     * <ul>
     *     <li>{@link Options#MAX_SOLUTION_RADIUS MAX_SOLUTION_RADIUS}: For
     *         {@link SolverType#ALLPATHS ALLPATHS}, {@link
     *         SolverType#SHORTEST_PATH SHORTEST_PATH} and {@link
     *         SolverType#INVERSE_SHORTEST_PATH INVERSE_SHORTEST_PATH} solvers
     *         only. Sets the maximum solution cost radius, which ignores the
     *         {@link #getDestinationNodes() destinationNodes} list and instead
     *         outputs the nodes within the radius sorted by ascending cost. If
     *         set to '0.0', the setting is ignored. The default value is
     *         '0.0'.
     *     <li>{@link Options#MIN_SOLUTION_RADIUS MIN_SOLUTION_RADIUS}: For
     *         {@link SolverType#ALLPATHS ALLPATHS}, {@link
     *         SolverType#SHORTEST_PATH SHORTEST_PATH} and {@link
     *         SolverType#INVERSE_SHORTEST_PATH INVERSE_SHORTEST_PATH} solvers
     *         only. Applicable only when {@link Options#MAX_SOLUTION_RADIUS
     *         MAX_SOLUTION_RADIUS} is set. Sets the minimum solution cost
     *         radius, which ignores the {@link #getDestinationNodes()
     *         destinationNodes} list and instead outputs the nodes within the
     *         radius sorted by ascending cost. If set to '0.0', the setting is
     *         ignored. The default value is '0.0'.
     *     <li>{@link Options#MAX_SOLUTION_TARGETS MAX_SOLUTION_TARGETS}: For
     *         {@link SolverType#ALLPATHS ALLPATHS}, {@link
     *         SolverType#SHORTEST_PATH SHORTEST_PATH} and {@link
     *         SolverType#INVERSE_SHORTEST_PATH INVERSE_SHORTEST_PATH} solvers
     *         only. Sets the maximum number of solution targets, which ignores
     *         the {@link #getDestinationNodes() destinationNodes} list and
     *         instead outputs no more than n number of nodes sorted by
     *         ascending cost where n is equal to the setting value. If set to
     *         0, the setting is ignored. The default value is '1000'.
     *     <li>{@link Options#UNIFORM_WEIGHTS UNIFORM_WEIGHTS}: When specified,
     *         assigns the given value to all the edges in the graph. Note that
     *         weights provided in {@link #getWeightsOnEdges() weightsOnEdges}
     *         will override this value.
     *     <li>{@link Options#LEFT_TURN_PENALTY LEFT_TURN_PENALTY}: This will
     *         add an additional weight over the edges labeled as 'left turn'
     *         if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#RIGHT_TURN_PENALTY RIGHT_TURN_PENALTY}: This will
     *         add an additional weight over the edges labeled as' right turn'
     *         if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#INTERSECTION_PENALTY INTERSECTION_PENALTY}: This
     *         will add an additional weight over the edges labeled as
     *         'intersection' if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#SHARP_TURN_PENALTY SHARP_TURN_PENALTY}: This will
     *         add an additional weight over the edges labeled as 'sharp turn'
     *         or 'u-turn' if the 'add_turn' option parameter of the {@link
     *         com.gpudb.GPUdb#createGraph(CreateGraphRequest)
     *         GPUdb.createGraph} was invoked at graph creation. The default
     *         value is '0.0'.
     *     <li>{@link Options#NUM_BEST_PATHS NUM_BEST_PATHS}: For {@link
     *         SolverType#MULTIPLE_ROUTING MULTIPLE_ROUTING} solvers only; sets
     *         the number of shortest paths computed from each node. This is
     *         the heuristic criterion. Default value of zero allows the number
     *         to be computed automatically by the solver. The user may want to
     *         override this parameter to speed-up the solver. The default
     *         value is '0'.
     *     <li>{@link Options#MAX_NUM_COMBINATIONS MAX_NUM_COMBINATIONS}: For
     *         {@link SolverType#MULTIPLE_ROUTING MULTIPLE_ROUTING} solvers
     *         only; sets the cap on the combinatorial sequences generated. If
     *         the default value of two millions is overridden to a lesser
     *         value, it can potentially speed up the solver. The default value
     *         is '2000000'.
     *     <li>{@link Options#OUTPUT_EDGE_PATH OUTPUT_EDGE_PATH}: If true then
     *         concatenated edge IDs will be added as the EDGE path column of
     *         the solution table for each source and target pair in shortest
     *         path solves.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#OUTPUT_WKT_PATH OUTPUT_WKT_PATH}: If true then
     *         concatenated wkt line segments will be added as the Wktroute
     *         column of the solution table for each source and target pair in
     *         shortest path solves.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}
     *             <li>{@link Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link Options#TRUE TRUE}.
     *     <li>{@link Options#SERVER_ID SERVER_ID}: Indicates which graph
     *         server(s) to send the request to. Default is to send to the
     *         server, amongst those containing the corresponding graph, that
     *         has the most computational bandwidth. For SHORTEST_PATH solver
     *         type, the input is split amongst the server containing the
     *         corresponding graph.
     *     <li>{@link Options#CONVERGENCE_LIMIT CONVERGENCE_LIMIT}: For {@link
     *         SolverType#PAGE_RANK PAGE_RANK} solvers only; Maximum percent
     *         relative threshold on the page rank scores of each node between
     *         consecutive iterations to satisfy convergence. Default value is
     *         1 (one) percent. The default value is '1.0'.
     *     <li>{@link Options#MAX_ITERATIONS MAX_ITERATIONS}: For {@link
     *         SolverType#PAGE_RANK PAGE_RANK} solvers only; Maximum number of
     *         page rank iterations for satisfying convergence. Default value
     *         is 100. The default value is '100'.
     *     <li>{@link Options#MAX_RUNS MAX_RUNS}: For all {@link
     *         SolverType#CENTRALITY CENTRALITY} solvers only; Sets the maximum
     *         number of shortest path runs; maximum possible value is the
     *         number of nodes in the graph. Default value of 0 enables this
     *         value to be auto computed by the solver. The default value is
     *         '0'.
     *     <li>{@link Options#OUTPUT_CLUSTERS OUTPUT_CLUSTERS}: For {@link
     *         SolverType#STATS_ALL STATS_ALL} solvers only; the cluster index
     *         for each node will be inserted as an additional column in the
     *         output.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#TRUE TRUE}: An additional column
     *                 'CLUSTER' will be added for each node
     *             <li>{@link Options#FALSE FALSE}: No extra cluster info per
     *                 node will be available in the output
     *         </ul>
     *         The default value is {@link Options#FALSE FALSE}.
     *     <li>{@link Options#SOLVE_HEURISTIC SOLVE_HEURISTIC}: Specify
     *         heuristic search criterion only for the geo graphs and shortest
     *         path solves towards a single target.
     *         Supported values:
     *         <ul>
     *             <li>{@link Options#ASTAR ASTAR}: Employs A-STAR heuristics
     *                 to speed up the shortest path traversal
     *             <li>{@link Options#NONE NONE}: No heuristics are applied
     *         </ul>
     *         The default value is {@link Options#NONE NONE}.
     *     <li>{@link Options#ASTAR_RADIUS ASTAR_RADIUS}: For path solvers only
     *         when 'solve_heuristic' option is 'astar'. The shortest path
     *         traversal front includes nodes only within this radius
     *         (kilometers) as it moves towards the target location. The
     *         default value is '70'.
     * </ul>
     * The default value is an empty {@link Map}.
     *
     * @param options  The new value for {@code options}.
     *
     * @return {@code this} to mimic the builder pattern.
     */
    public SolveGraphRequest setOptions(Map<String, String> options) {
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
        return this;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @return The schema object describing this class.
     */
    @Override
    public Schema getSchema() {
        return schema$;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @param index  the position of the field to get
     *
     * @return value of the field with the given index.
     *
     * @throws IndexOutOfBoundsException
     */
    @Override
    public Object get(int index) {
        switch (index) {
            case 0:
                return this.graphName;

            case 1:
                return this.weightsOnEdges;

            case 2:
                return this.restrictions;

            case 3:
                return this.solverType;

            case 4:
                return this.sourceNodes;

            case 5:
                return this.destinationNodes;

            case 6:
                return this.solutionTable;

            case 7:
                return this.options;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     *
     * @param index  the position of the field to set
     * @param value  the value to set
     *
     * @throws IndexOutOfBoundsException
     */
    @Override
    @SuppressWarnings("unchecked")
    public void put(int index, Object value) {
        switch (index) {
            case 0:
                this.graphName = (String)value;
                break;

            case 1:
                this.weightsOnEdges = (List<String>)value;
                break;

            case 2:
                this.restrictions = (List<String>)value;
                break;

            case 3:
                this.solverType = (String)value;
                break;

            case 4:
                this.sourceNodes = (List<String>)value;
                break;

            case 5:
                this.destinationNodes = (List<String>)value;
                break;

            case 6:
                this.solutionTable = (String)value;
                break;

            case 7:
                this.options = (Map<String, String>)value;
                break;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if( obj == this ) {
            return true;
        }

        if( (obj == null) || (obj.getClass() != this.getClass()) ) {
            return false;
        }

        SolveGraphRequest that = (SolveGraphRequest)obj;

        return ( this.graphName.equals( that.graphName )
                 && this.weightsOnEdges.equals( that.weightsOnEdges )
                 && this.restrictions.equals( that.restrictions )
                 && this.solverType.equals( that.solverType )
                 && this.sourceNodes.equals( that.sourceNodes )
                 && this.destinationNodes.equals( that.destinationNodes )
                 && this.solutionTable.equals( that.solutionTable )
                 && this.options.equals( that.options ) );
    }

    @Override
    public String toString() {
        GenericData gd = GenericData.get();
        StringBuilder builder = new StringBuilder();
        builder.append( "{" );
        builder.append( gd.toString( "graphName" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.graphName ) );
        builder.append( ", " );
        builder.append( gd.toString( "weightsOnEdges" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.weightsOnEdges ) );
        builder.append( ", " );
        builder.append( gd.toString( "restrictions" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.restrictions ) );
        builder.append( ", " );
        builder.append( gd.toString( "solverType" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.solverType ) );
        builder.append( ", " );
        builder.append( gd.toString( "sourceNodes" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.sourceNodes ) );
        builder.append( ", " );
        builder.append( gd.toString( "destinationNodes" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.destinationNodes ) );
        builder.append( ", " );
        builder.append( gd.toString( "solutionTable" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.solutionTable ) );
        builder.append( ", " );
        builder.append( gd.toString( "options" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.options ) );
        builder.append( "}" );

        return builder.toString();
    }

    @Override
    public int hashCode() {
        int hashCode = 1;
        hashCode = (31 * hashCode) + this.graphName.hashCode();
        hashCode = (31 * hashCode) + this.weightsOnEdges.hashCode();
        hashCode = (31 * hashCode) + this.restrictions.hashCode();
        hashCode = (31 * hashCode) + this.solverType.hashCode();
        hashCode = (31 * hashCode) + this.sourceNodes.hashCode();
        hashCode = (31 * hashCode) + this.destinationNodes.hashCode();
        hashCode = (31 * hashCode) + this.solutionTable.hashCode();
        hashCode = (31 * hashCode) + this.options.hashCode();
        return hashCode;
    }
}
